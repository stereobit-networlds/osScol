/* gps Plugin - DMS2 - JUNE 2014 - by stereobit */

typeof class=S;;

var maxDownloadSize=3145728;;/*1048576;; 204800;;*/

/*xyz obj calibration */
var iIX = -24700;;/*-24700;; 25700 pour 100% */
var iIY = 1;;/*1600;;15500;; 120% 1500, 110% 1600 */
var iIZ = 1300;;

/* delta computation */
var sIX = "00202.5776";;
var sIY = "610.0";;/*"510.0";;*/
var sIZ =  "4846.0024";;

typeof iX = I;;
typeof iY = I;;
typeof iZ = I;;

typeof iOldX = I;;
typeof iOldY = I;;
typeof iOldZ = I;;
var iMaxDHor = 500;;
var iMaxDVer = 500;;
typeof iErrH = I;;
typeof iErrV = I;;

var sFoot   = "30.48";; /*Y delta */
var sMScale = "25000.0";; /*xy delta */
var sWScale = "0.204";; /* x delta */
var sHScale = "0.135";; /* z delta */

/*scene orientation */
var iScale = 110;;     /* 100% */
var iAng   = -5900;;   /* 5640,5790*/

/*scene global rotation */
var sIAng = "164.3";;

typeof lInpData = [S r1];;
typeof lNMEAData = [S r1];;	
var iniPath="locked/conf/stereobit/";;

typeof sno = I;;	
typeof nsno = S;;
typeof sesfile = S;;
typeof sesdata = [[S r1] r1];;
var sesfile = "gpsbuf.txt";;

var log=0;;
var verbose=0;;	
var gps_verbose=0;;
var rLog=1;;

var interpoleRate = 0;;/*6;;*/ /*internal param not ui*/

typeof timer = Timer;;
typeof timerOn = S;;
var calibrationtime = 20000;; /* 20 sec at start of geo update */
var posCheck = 6000;;        /* check every n seconds for position capture */

/*c3d vars */
typeof old_fog = [I I];;
typeof old_boxcoll = S;;
typeof old_speed = I;;
typeof old_gravity = I;;
typeof old_backgroundcolor = I;;
typeof old_darkbase = I;;

/*av3d cam vars */
typeof avfile=S;;/*local avatar mesh file*/

var configPath="locked/conf/av3d/viewLevel_";;
var viewLevelF3=0;; 
var viewLevelF4=0;;
var viewLevelF5=0;;
var viewLevelF6=0;;
var viewLevel=0;;
var anim_walk_begin=0;;
var anim_walk_end=39;;
var anim_stop_begin=40;;
var anim_stop_end=100;;
var delta_b=0;; 
var bottom_limit_first_person_view=-15;;
var top_limit_first_person_view=90;;
var bottom_limit_third_person_view=200;;
var top_limit_third_person_view=300;;

typeof coll_enabled=I;; 
typeof ArrivalZoneSize=I;;

var hauteurAvatarSol=0;;
var hauteurOrientation=170;;
var canFly=0;;

var av3dCamSpeed=5;;

typeof av3dCamAngle=F;;
typeof av3dCamDist=I;;
typeof ModeVue = S;;
typeof linkCamAvatar=I;;
typeof shcamColl=H3d;;
typeof h=H3d;;
typeof oldav3CamDist=I;;
typeof shcam=H3d;; 
typeof sh0 = H3d;;
typeof sh = H3d;;
typeof dummyCam=H3d;;
typeof dummyTarget=H3d;;
typeof collCam=InBox;;
typeof anim_list=[[S I I] r1];;

typeof av3dplugin = I;;


proto GetSessionData = fun [] [S r1];;

fun getSessionParam(line, word) = 
  let nth_list sesdata (line-1) -> l in 
  nth_list l (word-1);;  

fun modifySessionParam(line, word, param) = 
  let hd sesdata -> [ l _] in
  mutate hd sesdata <- [ param _]
  /*let strbuild l -> text in
  _echo strcat "SESSION:"::text::nil*/
;;

/*fun addSessionParam(param) = 
  set sesdata = sesdata::param::nil;
1;;
*/  

fun sessionpath() = 
   strcatn iniPath::DMSname::"/"::(nsno)::"/"::nil;;	
   
fun fooCoord (coord) =
	let coord -> [iX iY iZ] in
	strcatn (itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil;;

fun saveLog(fname, s)=
 if (log==1) then
 (
    let strcatn (sessionpath)::fname::nil -> logBuf in
 
	let _appendpack s _getmodifypack logBuf ->append in
	if (append==-1) then
		_createpack s _getmodifypack logBuf
	else nil
 )
 else nil;;

fun echo(x,s)= 
  saveLog "echo.txt" strcat x "\n";
  if (verbose == 1) then
	_DMSevent this "hear" strcat strcat ">> " x "\n" nil
  else nil;;
  
fun _echo(x,s)= 
_DMSevent this "hear" strcat strcat ">> " x "\n" nil;
saveLog "_echo.txt" strcat x "\n";; 
   
fun gps_echo(x,s)= 
  if (gps_verbose == 1) then
	_DMSevent this "hear" strcat strcat ">> " x "\n" nil
  else nil;;  
  
fun recordLog(fname, s)=
 if (rLog==1) then
 (
    let strcatn (sessionpath)::fname::nil -> logBuf in
 
	let _appendpack s _getmodifypack logBuf ->append in
	if (append==-1) then
		_createpack s _getmodifypack logBuf
	else nil
 )
 else nil;;  

/* return true if physics (gravity and collision)
   is currently activated for local client */
fun C3D_IsPhysicsActivated () = cel.Cel3dphysics;;

/* return true if physics (gravity and collision)
   is currently activated for server */
fun C3D_IsGlobalPhysicsActivated () = cel.Cel3dglobalphysics;;

/**** c3d settings ********/
fun chgFog(val)=  /* = fog & backclipping dans l'éditeur du C3D3 */
  let val -> [fog clip] in
  let M3getObj session "camera" -> cam in
  (
   if clip == nil then
     nil
   else
     let M3getCamera session cam->[dx sx [z0 _ _]] in
      M3setCamera  session
                   cam
                   [dx sx [z0
                           if fog==nil then clip else fog
                           clip
                          ]
                   ];
   set old_fog = [cel.Cel3dfog cel.Cel3dclip];
   set cel.Cel3dfog = fog; /* inutile actuellement car pas de fun dans le C3D3 2.4 pour sa mise à jour dynamique */
   set cel.Cel3dclip = clip; /* inutile actuellement car pas de fun dans le C3D3 2.4 pour sa mise à jour dynamique */
  );;
  
fun chgSpeedAv(val)=
  set old_speed = cel.Cel3dspeed;
  set cel.Cel3dspeed = val;;

fun chgGravity(g)=
  set old_gravity = cel.Cel3dgrav;
  set cel.Cel3dgrav = if g == nil then 0 else g;;

fun chgBackgroundColor(c)=
  set old_backgroundcolor = w3d.V3dfond;
  ObSetBackground w3d c;
  0;;  
  
fun chgDarkbase(val)= 
  set old_darkbase = atoi cel.Cel3ddarkbase; 
 /* C3DsetGlobalLight val 1;*/           /* pour tout le monde */
  C3DopSetGlobalLight (itoa val)::nil;   /* que chez le client */
  0;;  
  
/*** collision box replacement ************/  
fun modifyBox(file)=
  if (_checkpack file) == nil then
    nil
  else
    (
     if cel.Cel3dcol == nil then
       nil
     else
       inboxClosing coll;
     let cel.Cel3dcol -> [_ i j] in
     set coll = mkInBox [file nil nil i j]; /* [nameIB :S, sIB :SBox, curboxIB :Box, rayonIB :I, gravityIB :I] */
     inboxLoading coll;
     OB_ForceCurrentPos owner session
    );
  0;;
  
fun newBox(path)=
  let cel.Cel3dcol -> [s i j] in
  (
   set old_boxcoll = s;
   set cel.Cel3dcol = [path i j]
  );
  set cel.Cel3dphysics = 1;
  _RSCdownload this path path @modifyBox 3;
  0;;    

/********** interpolate  **************/
fun linearInterpolate(a, b, mu) = M3interpVec a b mu;;
/*(a*(1-mu)+b*mu)*/

fun Interpolate(a, b) =
  if (av3dplugin!=nil) then 
    M3setObjVec session (M3getObj session "avatar") (linearInterpolate a b interpoleRate) 
  else 
    M3setObjVec session M3getFather session (ObGetMain owner) (linearInterpolate a b interpoleRate)
;;			

/******* interpolate Angle *************/
fun linearInterpolateAng(a, b, mu) = M3interpAng a b mu;;

fun InterpolateAng(ra, rb) =
  if (av3dplugin!=nil) then 
    M3setObjAng session (M3getObj session "avatar") (linearInterpolateAng ra rb interpoleRate)
  else 
    M3setObjAng session M3getFather session (ObGetMain owner) (linearInterpolateAng ra rb interpoleRate)
;;			

/******** Avatar functions ***************/
fun GetAvatarAngle() = 
  if (av3dplugin!=nil) then 
    M3getObjAng session (M3getObj session "avatar") 
  else 
	M3getObjAng session M3getFather session (ObGetMain owner)
;;

fun SetAvatarAngle(ang) = 
   
    let OptimizeDestOrientation GetAvatarAngle ang -> optAng in 	

	if interpoleRate then
	    InterpolateAng GetAvatarAngle optAng
	else
    (
        if (av3dplugin!=nil) then 
		  M3setObjAng session (M3getObj session "avatar") optAng 
        else 
		  M3setObjAng session M3getFather session (ObGetMain owner) optAng;
	);;

fun GetAvatarPosition() = 
   if (av3dplugin!=nil) then 
     M3getObjVec session (M3getObj session "avatar") 
   else 
     M3getObjVec session M3getFather session (ObGetMain owner)
	
;;
	
/*when smooth avatar moves check at advance 3ds 
 is on remark pos interpolation here */	
fun SetAvatarPosition(pos) = 

  /*if interpoleRate then
	Interpolate GetAvatarPosition pos
  else*/	
  (
	if (av3dplugin!=nil) then 
	  M3setObjVec session (M3getObj session "avatar") pos 
    else 
	  M3setObjVec session M3getFather session (ObGetMain owner) pos
  );;
	
/**** Camera functions *******************/
fun SetCamPosition(pos) = 
	M3setObjVec session cam pos;
0;;

fun SetCamAngle(ang) = 
	M3setObjAng session cam ang;
0;;

fun GetCamPosition() = 
    M3getObjVec session cam;;
  
fun GetCamAngle() = 
    M3getObjAng session cam;;	
	
/**** camera settings *********************/
fun updateCamPos()=
 let [0 0] -> [yc zc] in
 (
  set yc = (ftoi ((itof av3dCamDist) *. sin av3dCamAngle));
  set zc = (- (ftoi ((itof av3dCamDist) *. cos av3dCamAngle)))+20;
  if linkCamAvatar then
  (
   M3setObjVec session shcam [0 yc zc];
   M3setObjVec session shcamColl [0 yc zc];
   M3setObjAng session shcam (M3angularTarget (M3getObjVec session shcam) (M3getObjVec session dummyTarget));
   0
  )
  else
   (
    M3setObjVec session dummyCam [0 yc zc];
    M3setObjAng session dummyCam (M3angularTarget (M3getObjVec session dummyCam) (M3getObjVec session dummyTarget));
    0
   );
 );;
 
fun CamDefault() = 
  set delta_b=0; /*init angle suivant x*/  
  
  set ModeVue = "PremierePersonne";		
  set oldav3CamDist= av3dCamDist;
  set av3dCamDist = 140;
  
  set av3dCamAngle = atof "1.5";
  updateCamPos;
  
  M3setObjVec session cam [0 0 0];
  M3setObjAng session cam [0 0 0];  
  M3setObjVec session cam [0 0 0];  
0;;  

fun CamOnTop(distanceCamera) = 

  if viewLevel then
    CamDefault /*reset if come from non default view*/
  else nil;

  set viewLevel=distanceCamera;
  
  let strcatn iniPath::DMSname::".conf"::nil -> configFileName in
    _storepack strbuild ("viewLevel"::(itoa distanceCamera)::nil)::nil configFileName; 
      
  M3setObjVec session cam [0 0 0];
  M3setObjAng session cam [0 (-16384) 0];  
  M3setObjVec session cam [0 distanceCamera 3000];
0;;	

 
fun moveCamera(objb,i2,param)= 
 let param ->[o sh] in  
 let M3getObjVec session shcam -> [xc yc zc] in
 let M3calcPosRef session dummyCam shell -> [[xdw ydw zdw] _] in
 (
   /* calcul des nouveaux coordonnees de la camera (interpolation )*/
  /*let (xc + (xdw - xc) / av3dCamSpeed) -> a in
  let (yc + (ydw - yc) / av3dCamSpeed) -> b in
  let (zc + (zdw - zc) / av3dCamSpeed) -> c in
  */
  let (xc + (xdw - xc) / cel.Cel3dspeed) -> a in
  let (yc + (ydw - yc) / cel.Cel3dspeed) -> b in
  let (zc + (zdw - zc) / cel.Cel3dspeed) -> c in
  
  
  let M3calcPosRef session dummyCam shcam -> [[x y z] _] in
  (
    M3setObjVec session shcamColl [xc yc zc];
	let inboxTesting collCam session shcamColl [0 0 0] ->[newbox _] in
    set collCam.curboxIB = newbox;
	 
	let inboxTesting collCam session shcamColl [(a-xc) (b-yc) (c-zc)] ->[newb [npx npy npz]] in
	(
     M3setObjVec session shcam [npx npy npz];
     M3setObjVec session shcamColl [npx npy npz];
    );	
	
    let M3calcPosRef session dummyTarget shell -> [t _] in
    M3setObjAng session shcam (M3angularTarget (M3getObjVec session shcam) t);
	
    if !strcmp ModeVue "PremierePersonne" then
     if (( (oldav3CamDist>500)  && (z<50) && (z>(-50)) ) || ( (oldav3CamDist<=500) && (z<60) && (z>(-60)) )) then 
     (    	    
      M3link session shcam sh;		
      set linkCamAvatar = 1;			
      ObCbPostRender o nil;	     
      updateCamPos;
     ) 
     else nil
	else nil; 
  );
  0
 );;

fun CamDistance(o,sh,distanceCamera) =

 if viewLevel==viewLevelF6 then
   CamDefault /*reset if come from top view*/
 else nil;

 set delta_b=0; /*init angle suivant x*/
 
 let strcatn iniPath::DMSname::".conf"::nil -> configFileName in
    _storepack strbuild ("viewLevel"::(itoa distanceCamera)::nil)::nil configFileName; 
    
 set viewLevel=distanceCamera;
 set ModeVue = "TroisiemePersonne";
 ObCbPostRender o mkfun3 @moveCamera [o sh];
 
 let M3calcPosRef session cam shell -> [coord_t CamMatrix] in
 let M3angularFromMatrix CamMatrix -> angle_t in
  (
   //M3setObjVec session shcamColl coord_t;                           
   M3setObjVec session cam coord_t;
   M3setObjAng session cam angle_t
  );
  
 set linkCamAvatar = 0;						     
 set oldav3CamDist= av3dCamDist;
 set av3dCamDist = distanceCamera;
 set av3dCamAngle = atof "0.5";  
 updateCamPos;; 
 
fun cbCameraKey(o,t,sh)=
 let t -> [_ code] in  
  if code==65471 then  /*<F2>*/
   (
    CamDefault;
    let strcatn configPath::DMSname::".conf"::nil -> configFileName in
      _storepack strbuild ("viewLevel"::"0"::nil)::nil configFileName;
    set viewLevel=0
   ) 
  else if ((code==65472)&&(viewLevelF3!=0)) then 
   (
	CamDistance o sh viewLevelF3;
	0
   ) 	
  else if ((code==65473)&&(viewLevelF4!=0)) then /*<F7>*/
  (
    CamDistance o sh viewLevelF4;
    0	
  )	
  else if ((code==65474)&&(viewLevelF5!=0)) then /*<F8>*/
  (
    CamDistance o sh viewLevelF5;
	0
  )	
  else if ((code==65475)&&(viewLevelF6!=0)) then /*<F9>*/
  (
    CamOnTop viewLevelF6;
	0
  )	  
  else nil;; 
  
fun Setpos(o,v,a)=

 let M3getFather session o.o3Ob -> f in
 let v->[xn yn zn] in
 let a->[an bn cn] in
 let M3getObjVec session o.o3Ob ->[_ yo _] in 
 //let (if ArrivalZoneSize>0 then ((mod rand 2*ArrivalZoneSize)-ArrivalZoneSize) else 0)  -> xrand in
 //let (if ArrivalZoneSize>0 then ((mod rand 2*ArrivalZoneSize)-ArrivalZoneSize) else 0)  -> zrand in  
 (  
  //if v==nil then nil else M3setObjVec session f [xn+xrand yn-yo-170 zn+zrand];  
  M3setObjAng session f [an 0 0];      
  
  /*M3setObjAng session o.o3Ob [0 bn cn];*/
  M3setObjAng session o.o3Ob [0 0 cn]; 
  
  /*to do : reprendre l'angle x pour la dummy cam !!! */
  
  //if coll==nil || o!=owner then nil
  //else 
  inboxPlacing coll session f;
  0;
  
  if viewLevel!=0 then
   CamDistance o sh viewLevel
  else nil;
   
  0;
 );;  
  
fun movcam2av3d(s,h,f,v,ang)=
 let ang->[an bn cn] in
 let v->[x y z] in   
 
 let M3getObjVec s f -> oldpos in
 let coll.curboxIB ->oldbox in
 (if coll==nil then
   let M3getGlobalVec s f v->w in
   let M3testColl s f shell w 2 -> [_ cl wc nc] in
   if wc==nil then
   (M3movObjExt s f w;
    0)
   else if nc==nil then let M3getFather s cl->oldfath in
   (M3unLink s cl;
    movcam2av3d s h f v ang;
    M3link s cl oldfath;
    0)
   else let w->[wx wy wz] in let nc->[nx ny nz] in
   let [wx+nx wy+ny wz+nz]-> ww in
   (if nil==M3testColl s f shell ww 2
    then M3movObjExt s f ww
    else M3movObjExt s f wc;
    0)
  else
   (let inboxTesting coll s f v->[newb [npx npy npz]] in
    let oldpos->[opx opy opz] in
    let [npx-opx npy-opy npz-opz]->w in
    let M3testColl s f shell w 2 -> [_ cl wc nc] in
    if wc==nil then
    (M3movObjExt s f w;
     set coll.curboxIB=newb;
     0)
    else if nc==nil then let M3getFather s cl->oldfath in
    (M3unLink s cl;
     movcam2av3d s h f v ang;
     M3link s cl oldfath;
     0)
    else let w->[wx wy wz] in let nc->[nx ny nz] in
    let [wx+nx wy+ny wz+nz]-> ww in
    if nil==M3testColl s f shell ww 2 then
    (M3movObjExt s f ww;
     let M3getObjVec s f -> [ox2 oy2 oz2] in
     let inboxTesting coll s f [0 0 0] ->[newb2 [npx npy npz]] in
     if ox2==npx && oy2==npy && oz2==npz then
     (set coll.curboxIB=newb2;
      0)
     else
     (M3setObjVec s f oldpos;
      M3movObjExt s f wc;
      set coll.curboxIB=newb;
      0))
    else
    (M3movObjExt s f wc;
     set coll.curboxIB=newb;
     0);
    0);
  if ang==nil then nil else
  (M3rotateObjExt s h [0 bn cn];
   M3rotateObjExt s f [an 0 0]);
  if nil==M3testInter s f shell then nil
  else
  (M3setObjVec s f oldpos;
   set coll.curboxIB=oldbox);
  0);;  
  
fun controlAv3d(o,z,param)= 
 let param->[avatar] in 
 let z->[v ang] in
 let ang -> [a b c] in
 let v -> [x y z] in  
 (
  /*the local avatar is moving*/
  
  /*
  if linkCamAvatar then nil 
   else 
  if y+z then   
   let search_in_list anim_list @animbyName (ObName o) -> [_ a _] in  
    if a==1 then nil
    else              
      runAnimWalk o avatar
  else nil;    
  */       
  
  let o.o3Ob -> h in
  let session -> s in
 
  let M3getFather s h -> f in  
  (                      
   /*gestion deplacement caméra suivant angle x*/  
   if linkCamAvatar then /*first person view*/     
    if b>0 then
     let if b<500 then 500 else b -> b2 in     
       if delta_b<top_limit_first_person_view then set delta_b=delta_b+b2/500 else nil
    else if b<0 then
     let if b>-500 then -500 else b -> b2 in     
       if delta_b>bottom_limit_first_person_view then set delta_b=delta_b+b2/500 else nil
    else nil    

   else /*third person view*/  
    if b>0 then
      if delta_b<(top_limit_third_person_view+viewLevel) then set delta_b=delta_b+b/100 else nil
    else if b<0 then
      if delta_b>(bottom_limit_third_person_view-viewLevel) then set delta_b=delta_b+b/100 else nil
    else nil;
    
   let M3getObjVec session avatar -> [xa ya za] in             
   (     
     if linkCamAvatar then
       M3setObjVec session dummyTarget [xa 138+delta_b za+40]
     else 
       M3setObjVec session dummyTarget [xa 135+delta_b za+40];    
   );
    
   updateCamPos;      
       
   if canFly then
     movcam2av3d s h f [x y z] [a 0 c]
   else   
     movcam2av3d s h f [x 0 z] [a 0 c];
    
   //if gravity then 
     //movcam2av3d s h f [0 (-gravity) 0] nil   
   if (C3D_IsGlobalPhysicsActivated && cel.Cel3dgrav) then
     movcam2av3d s h f [0 (-cel.Cel3dgrav) 0] nil
   else nil;	 
   
   0;
  );        
 );;  
 
fun applyPhotoToMaterial(mat,image,f)=
 let M3copyMaterialTexture session mat -> t in   
  if f then 
  let _GETpixel16 image 0 0 -> colRGB in  
  let ((colRGB&16252928)>>16)+(colRGB&63488)+((colRGB&248)<<16) -> colBGR in
   (M3setType session mat MAT_TRANSP|M3getType session mat;
    M3setTransparencyColor session t colBGR)    
  else nil;  
 M3blitTexture16 session (M3copyMaterialTexture session mat) image;;

fun setMaterial(h,mat,image,f)=
 if h==nil then nil else
 (
  let M3copyObjMaterial session h mat -> mat2 in
   if mat2!=nil then applyPhotoToMaterial mat2 image f
   else nil;

  setMaterial (M3getFirstSon session h) mat image f;
  setMaterial (M3getBrother session h) mat image f;
  0
 );;

fun applyface(s,o,f)=
 let _LDbitmap _channel _checkpack s -> imagebmp in
 let if imagebmp==nil then _LDjpeg _channel _checkpack s else imagebmp -> image in
 (
  /*_DLGMessageBox _channel nil "applyface" ObName o 0;*/ /*DEBUG SEB*/
  let M3getMat session "photo" -> mat in
   setMaterial (ObGetMain o) mat image f;
  _DSbitmap image;
  0
 );; 
 
fun applyMesh(o,meshFileName)=

  /*_DLGMessageBox _channel nil "applyMesh" meshFileName 0;*/

  //let search_in_list anim_list @animbyName (ObName o) -> a in
   //mutate a <- [_ _ if !strcmp meshFileName avfile then 1 else 0];

  let ObGetMain o -> OB in
  let M3getObjVec session OB -> pos in
  let M3getObjAng session OB -> ang in
  (
    M3unLink session (M3getFirstSon session OB);
    M3delObj session (M3getFirstSon session OB);

    M3load session meshFileName nil;
    let (M3getObj session "avatar") -> avatar in
    (
      M3recursFillMatObj session avatar;
      let M3getObjVec session avatar -> [x y z] in
      (
          M3setObjVec session avatar [x y+hauteurAvatarSol-hauteurOrientation z]; 
      );

      if o==owner then
        let M3createSphere session 50 -> chnew in
        (
           M3setObjVec session chnew [0 100 0];
           M3link session chnew OB;
        )
      else                                    
      if coll_enabled then 
        /*let M3createObb session [coll_x coll_y coll_z] -> chnew in*/
        let M3createSphere session 1 -> chnew in
        (
           M3setObjVec session chnew [0 100 0];
           M3link session chnew OB;
        )
      else nil;

      M3link session avatar OB;        
       
      //if o==owner then 
        //(
		ObCbControl o mkfun3 @controlAv3d [avatar];
		//0)
      //else   
        //(ObCbSetpos o mkfun4 @SetposOthersAvatars [avatar];0); 

      //runAnimStop o avatar;/*run the anim on the mesh*/

    );
        
    M3setObjVec session (ObGetMain o) pos;
    M3setObjAng session (ObGetMain o) ang;
    M3freeMemory session;
    0;
  );; 
 
fun destroyLocalAvatar(o)=
 //set anim_list=remove_from_list anim_list (search_in_list anim_list @animbyName (ObName o));
 M3delObj session M3getFather session ObGetMain o;
 0;; 

/** Conversions ***************************/
/*http://gis.stackexchange.com/questions/2951/algorithm-for-offsetting-a-latitude-longitude-by-some-amount-of-meters*/ 
fun latlonOffset (lat, lon, dn, de) =

 /*Earths radius, sphere*/
 let 6378137.0 -> R in 

 /*Coordinate offsets in radians*/
 let dn /. R -> dLat in
 let de /. (R *. cos (PIf *. lat /. 180.0)) -> dLon in

 /*OffsetPosition, decimal degrees*/
 let lat +. dLat *. 180.0 /. PIf -> newLat in
 let lon +. dLon *. 180.0 /. PIf -> newLon in
 
 strcatn (ftoa newLat)::" "::(ftoa newLon)::nil
;;	

proto latlon2vector = fun [S] [I I I];;
fun latlon2vector(position) =
		
	let getSessionParam 1 2 -> centerX in	  
	let getSessionParam 1 1 -> centerZ in
	let getSessionParam 1 5 -> MScale in	  
	let getSessionParam 1 6 -> XScale in
	let getSessionParam 1 7 -> ZScale in	
    let atoi getSessionParam 2 1 -> offsetX in 
	let atoi getSessionParam 2 3 -> offsetZ	in 
	let substr position 0 9 -> latitude in
	let substr position 10 9 -> longitude in
	
	let (ftoi (((atof longitude) -. (atof centerX)) *. ((atof MScale) /. (atof XScale)))) + offsetX -> iX in
    let (ftoi (((atof latitude) -. (atof centerZ)) *. ((atof MScale) /. (atof ZScale)))) + offsetZ -> iZ in		  
	
    /*set iY = 0  or  (atoi getSessionParam 2 2);*/	
    let GetAvatarPosition -> [_ iY _] in 
	
	let [iX iY iZ] -> vector in
    vector
;;	

fun vector2latlon(v) =
   let v -> [iX _ iZ] in
   
   /*distance from 0,0 in 100m  - 3900 - 4200*/
   let (itof iX) /. 4000.0 -> m100x in 
   let (itof iZ) /. 4000.0 -> m100z in
   
   /*0,0 lat lon*/
   let atof getSessionParam 1 2 -> centerX in	  
   let atof getSessionParam 1 1 -> centerZ in
   
   latlonOffset centerZ centerX (100.0 *. m100z) (100.0 *. m100x)
;;  	  	

/******save/read location data for scene manager*****/
fun saveLocation (coords) =
  /*let strcatn iniPath::DMSname::"/clocation"::(itoa DMSid)::".txt"::nil -> flocation in	*/
  let strcatn iniPath::DMSname::"/clocation.txt"::nil -> flocation in
  _createpack coords _getmodifypack flocation
;;

fun readLocation () = 
  /*let strcatn iniPath::DMSname::"/clocation"::(itoa DMSid)::".txt"::nil -> posfile in	 */
  let strcatn iniPath::DMSname::"/clocation.txt"::nil -> posfile in
  _getpack _checkpack posfile
;; 

/* update position file while manual moving (rtimer) */
fun updateLocation (t, o)=
  let M3getObjVec session M3getFather session (ObGetMain owner) -> curPos in
  let vector2latlon curPos -> coords in
  saveLocation coords;		
  0;;   
 			
/*read data from line array	*/
fun GetData(line, n) =
  let 1 -> i in
  let 0 -> ind1 in
  let 0 -> ind2 in
  (
    while (i < n) do
    (
      set ind1 = 1 + strfind "," line ind1;
      set i = i + 1;
    );
    set ind1 = 1 + strfind "," line ind1;
    set ind2 = strfind "," line ind1;
    substr line ind1 (ind2 - ind1);
  );;

fun CheckNumChars(str, sta, end) =
  if (sta == end) then
    0 
  else
    let nth_char str sta -> c in
      if (((c >= '0) && (c <= '9)) || (c == '.)) then
        CheckNumChars str (sta + 1) end
      else
        1;;
		
/*NMEA GPGGA lon lat to degrees */
fun NMEA2dec(n, islat) = 
  //_echo "NMEA2dec:"::n::nil 
  let atoi getSessionParam 2 5 -> c2 in
  let atoi getSessionParam 2 6 -> c3 in		
  let (c2-2) -> lenLat in
  let (c3-3) -> lenLon in  
  
  if (islat) then
  (
    let atof substr n 0 2 -> p1 in
    let atof substr n 2 lenLat -> q1 in
	
	p1 +. (q1 /. 60.0)
  )	
  else
  (
    let atof substr n 0 3 -> p1 in
    let atof substr n 3 lenLon -> q1 in
	
	p1 +. (q1 /. 60.0)
  );;			

//read and check data lines		
proto CheckIntegrity = fun [S] [S r1];;
fun CheckIntegrity(line) =

      /* SAVE ROUTE LOG */
      saveLog "backroute.txt" strcat line "\n";

      if (!strcmp (substr line 0 6) "$PGRME") then
      (
        nil;
      )
      else if (!strcmp (substr line 0 6) "$PGRMZ") then
      (
        let GetData line 1 -> data in
          if ((atoi data) != nil) then
            "$PGRMZ"::data::nil
          else
            nil;
      )
      else if (!strcmp (substr line 0 6) "$GPRMC") then
      (
        let GetData line 1 -> dataTim in
        let GetData line 2 -> dataVal in
        let GetData line 3 -> dataLat in
        let GetData line 4 -> dataNor in
        let GetData line 5 -> dataLon in
        let GetData line 6 -> dataEas in
        let GetData line 7 -> dataRun in
        let GetData line 8 -> dataAng in
		
		let atoi getSessionParam 2 4 -> c1 in
		let atoi getSessionParam 2 5 -> c2 in
		let atoi getSessionParam 2 6 -> c3 in		
		
        let if ((strlen dataTim) == c1) then 0 else 1 -> errTim in
        let if !strcmp dataVal "A" then 0 else 1 -> errVal in
        let if (((strlen dataLat) == c2) && (dataLat != nil) && (strcmp dataLat nil) && (strcmp dataLat "")) then 0 else 1 -> errLat in
        let if !strcmp dataNor "N" then 0 else 1 -> errNor in
        let if (((strlen dataLon) == c3) && (dataLon != nil) && (strcmp dataLon nil) && (strcmp dataLon "")) then 0 else 1 -> errLon in
        let if !strcmp dataEas "E" then 0 else 1 -> errEas in
        /* No control for dataRun */
        let (errTim + errVal + errLat + errNor + errLon + errEas) -> error in
        let strfind "." dataAng 0 -> ind in
        let strlen dataAng -> len in
          if ((error == 0) && ((atof dataAng) != nil) && (ind == (len - 2)) && (ind != 0) && ((CheckNumChars dataAng 0 len) == 0)) then
            "$GPRMC"::dataAng::nil
          else
            nil;
      )
      else if (!strcmp (substr line 0 6) "$GPGGA") then
      (
        let GetData line 1 -> dataTim in
        let GetData line 2 -> dataLat in
        let GetData line 3 -> dataNor in
        let GetData line 4 -> dataLon in
        let GetData line 5 -> dataEas in
		
		let atoi getSessionParam 2 4 -> c1 in
		let atoi getSessionParam 2 5 -> c2 in
		let atoi getSessionParam 2 6 -> c3 in		
		
        let if ((strlen dataTim) == c1) then 0 else 1 -> errTim in
        let if (((strlen dataLat) == c2) && (dataLat != nil) && (strcmp dataLat nil) && (strcmp dataLat "")) then 0 else 1 -> errLat in
        let if !strcmp dataNor "N" then 0 else 1 -> errNor in
        let if (((strlen dataLon) == c3) && (dataLon != nil) && (strcmp dataLon nil) && (strcmp dataLon "")) then 0 else 1 -> errLon in
        let if !strcmp dataEas "E" then 0 else 1 -> errEas in
        let (errTim + errLat + errNor + errLon + errEas) -> error in
          if (error ==0) then
            "$GPGGA"::dataLat::dataLon::nil
          else
            nil;
      )
      else if (!strcmp (substr line 0 6) "cbTick") then
      (
        "cbTick"::nil;
      )
      else
        nil;;
    		
/*calculate - transfrom lat lot ang to vectors from url calls*/
fun readGeo (param) =  	
	
	set lInpData = lineextr param;
	let hd lInpData -> line in
    let CheckIntegrity line -> l in
    (
	  
      if (l == nil) then
      (
	    gps_echo strcat "LINE:" "0"			
        0;
      )
      else if (!strcmp (hd l) "$PGRME") then
      (
	    gps_echo "PGRME:0"
		
	    /* SAVE OBJECT ROUTE IN GPS CMD */
	    let strcatn "PGRME 0,0"::nil -> vline in
        recordLog strcat "cam" "-backroute-gps.txt" strcat vline "\n";			
        0;
      )
      else if (!strcmp (hd l) "$PGRMZ") then
      (
	    let getSessionParam 1 3 -> ssIY in
		let getSessionParam 1 4 -> ssFoot in		
	  
        let (hd tl l) -> data in
        let ftoi (((itof atoi data) -. (atof ssIY)) *. (atof ssFoot)) -> delta in
        (
          set iY = (atoi getSessionParam 2 2) + delta;
		  
		  /*<<<<<<<<<<<<< get object's current x,z*/
		  let GetAvatarPosition -> [iX Oy iZ] in
          //let GetCamPosition -> [iX Oy iZ] in
		  
          if ((atoi data) == nil) then
          (
            set iErrV = iErrV + 1;
			_echo strcat "Err (data):" (itoa iErrV)
            0;
          )
          else if ((iOldY != nil) && ((abs (iY - iOldY)) > (iMaxDVer * iErrV))) then
		  /*else if ((Oy != 0) && ((abs (iY - Oy)) > (iMaxDVer * iErrV))) then*/
          (
            set iErrV = iErrV + 1;
			_echo strcatn "Err (pos Y):"::(itoa iErrV)::"-["::(itoa Oy)::"-"::(itoa iY)::"]"::"["::(itoa iIY)::"+"::(itoa delta)::"]"::nil
            0;
          )
          else
          (
            set iErrV = 1;
            set iOldY = iY; /*<<<<<<<<<<<<<<*/
			
			SetAvatarPosition [iX iY iZ];

			_echo strcatn "Go (pos Y):"::(itoa iErrV)::"-["::(itoa Oy)::"-"::(itoa iY)::"]"::"["::(itoa iIY)::"+"::(itoa delta)::"]"::nil
			gps_echo strcatn "PGRMZ:"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil
			
	        /* SAVE OBJECT ROUTE IN GPS CMD / VECTORS */
	        let strcatn "PGRMZ:"::(data)::nil -> vline in
            recordLog strcat "cam" "-backroute-gps.txt" strcat vline "\n";				
			
			let strcatn "Pos Y,"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil -> out in
			recordLog strcat "cam" "-backroute-vectors.txt" strcat out "\n";
			
            0;
          );
        );
        0;
      )
      else if (!strcmp (hd l) "$GPRMC") then
      (
        let (hd tl l) -> data in
        (
          if ((atof data) == nil) then
            0
          else
          (
		    SetAvatarAngle [(ftoi (-.65536.0 *. ((atof data) /. 360.0))) 0 0];
	
			let (ftoi (-.65536.0 *. ((atof data) /. 360.0))) -> angle in
			gps_echo strcatn "GPRMC:" :: (itoa angle) :: ",0,0" ::nil
			
	        /* SAVE OBJECT ROUTE IN GPS CMD / VECTORS */
	        let strcatn "GPRMC:"::(data)::nil -> vline in
            recordLog strcat "cam" "-backroute-gps.txt" strcat vline "\n";				
			
			let strcatn "Ang,"::(itoa (ftoi (-.65536.0 *. ((atof data) /. 360.0))))::",0,0"::nil -> out in
			recordLog strcat "cam" "-backroute-vectors.txt" strcat out "\n";
								
            0;
          );
        );
        0;
      )
      else if (!strcmp (hd l) "$GPGGA") then
      (
		let getSessionParam 1 2 -> centerX in	  
		let getSessionParam 1 1 -> centerZ in
		let getSessionParam 1 5 -> MScale in	  
		let getSessionParam 1 6 -> XScale in
		let getSessionParam 1 7 -> ZScale in	
        let atoi getSessionParam 2 1 -> offsetX in /* 0 when in map center*/
		let atoi getSessionParam 2 3 -> offsetZ	in /* 0 when in map center*/
        let NMEA2dec (hd tl l) 1 -> latitude in
  		let NMEA2dec (hd tl tl l) 0 -> longitude in
        ( 
		  set iX = (ftoi ((longitude -. (atof centerX)) *. ((atof MScale) /. (atof XScale)))) + offsetX;
          set iZ = (ftoi ((latitude -. (atof centerZ)) *. ((atof MScale) /. (atof ZScale)))) + offsetZ;		  

		  let GetAvatarPosition -> [Ox iY Oz] in		  	  

          if (((iOldX != nil) && (iOldZ != nil)) && ((ftoi sqrt (sqr itof (iX - iOldX)) +. (sqr itof (iZ - iOldZ))) > (iMaxDHor * iErrH)))then
		  /*else if (((Ox != 0) && (Oz != 0)) && ((ftoi sqrt (sqr itof (iX - Ox)) +. (sqr itof (iZ - Oz))) > (iMaxDHor * iErrH)))then*/
          (
            set iErrH = iErrH + 1;
			_echo strcatn "Err (pos XZ):"::(itoa iErrH)::"-["::(itoa Ox)::","::(itoa Oz)::"]-["::(itoa iY)::","::(itoa iZ)::"]"::nil
            0;
          )
          else
          (
            set iErrH = 1;
            /*set iOldX = iX;
            set iOldZ = iZ;<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
			
			SetAvatarPosition [iX iY iZ];

			gps_echo strcatn "GPGGA:"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil
			
	        /* SAVE OBJECT ROUTE IN GPS CMD / VECTORS */
	        let strcatn "GPGGA:"::(ftoa latitude)::","::(ftoa longitude)::nil -> vline in
            recordLog strcat "cam" "-backroute-gps.txt" strcat vline "\n";				
			
			let strcatn "Pos XZ,"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil -> out in
			recordLog strcat "cam" "-backroute-vectors.txt" strcat out "\n";

			saveLocation strcatn (ftoa latitude)::" "::(ftoa longitude)::nil
          );
        );        
        0;
      )
      else
        0;	
  );;
  	
fun CBgethttp(inet,z,s,reason) =
 let z->[content] in 
 if reason==0 then (mutate z <- [strcat content s];nil)
 else if reason==1 then 
   readGeo content
 else nil;;
 
/*calculate - transfrom lat lot ang to vectors from file source*/
fun readNMEA (o) =  	
	
  let hd lNMEAData -> line in
  if (strcmp line nil) then
  (
    let CheckIntegrity line -> l in
    (
	  
      if (l == nil) then
      (
	    gps_echo strcat "LINE:" "0"			
        0;
      )
      else if (!strcmp (hd l) "$PGRME") then
      (
	    gps_echo "NMEA PGRME:0"		
        0;
      )
      else if (!strcmp (hd l) "$PGRMZ") then
      (
	    let getSessionParam 1 3 -> ssIY in
		let getSessionParam 1 4 -> ssFoot in		
	  
        let (hd tl l) -> data in
        let ftoi (((itof atoi data) -. (atof ssIY)) *. (atof ssFoot)) -> delta in
        (
          set iY = (atoi getSessionParam 2 2) + delta;
		  
		  let GetAvatarPosition -> [iX Oy iZ] in
		  
          if ((atoi data) == nil) then
          (
            set iErrV = iErrV + 1;
			_echo strcat "NMEA Err (data):" (itoa iErrV)
            0;
          )
          else if ((iOldY != nil) && ((abs (iY - iOldY)) > (iMaxDVer * iErrV))) then
		  /*else if ((Oy != 0) && ((abs (iY - Oy)) > (iMaxDVer * iErrV))) then*/
          (
            set iErrV = iErrV + 1;
			_echo strcatn "NMEA Err (pos Y):"::(itoa iErrV)::"-["::(itoa Oy)::"-"::(itoa iY)::"]"::"["::(itoa iIY)::"+"::(itoa delta)::"]"::nil
            0;
          )
          else
          (
            set iErrV = 1;
            set iOldY = iY; /*<<<<<<<<<<<<<<*/
			
            if (av3dplugin!=nil) then /*update av3d */	
	          controlAv3d o [[iX iY iZ] GetAvatarAngle] [(M3getObj session "avatar")]
	        else			
			  SetAvatarPosition [iX iY iZ];

			_echo strcatn "NMEA Go (pos Y):"::(itoa iErrV)::"-["::(itoa Oy)::"-"::(itoa iY)::"]"::"["::(itoa iIY)::"+"::(itoa delta)::"]"::nil
			gps_echo strcatn "NMEA PGRMZ:"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil
            0;
          );
        );
        0;
      )
      else if (!strcmp (hd l) "$GPRMC") then
      (
        let (hd tl l) -> data in
        (
          if ((atof data) == nil) then
            0
          else
          (
            if (av3dplugin!=nil) then /*update av3d */	
	          controlAv3d o [GetAvatarPosition [(ftoi (-.65536.0 *. ((atof data) /. 360.0))) 0 0]] [(M3getObj session "avatar")]
	        else			  
		      SetAvatarAngle [(ftoi (-.65536.0 *. ((atof data) /. 360.0))) 0 0];

			let (ftoi (-.65536.0 *. ((atof data) /. 360.0))) -> angle in
			gps_echo strcatn "NMEA GPRMC:" :: (itoa angle) :: ",0,0" ::nil			
            0;
          );
        );
        0;
      )
      else if (!strcmp (hd l) "$GPGGA") then
      (
		let getSessionParam 1 2 -> centerX in	  
		let getSessionParam 1 1 -> centerZ in
		let getSessionParam 1 5 -> MScale in	  
		let getSessionParam 1 6 -> XScale in
		let getSessionParam 1 7 -> ZScale in	
        let atoi getSessionParam 2 1 -> offsetX in /* 0 when in map center*/
		let atoi getSessionParam 2 3 -> offsetZ	in /* 0 when in map center*/
        let NMEA2dec (hd tl l) 1 -> latitude in
  		let NMEA2dec (hd tl tl l) 0 -> longitude in
        ( 
		  set iX = (ftoi ((longitude -. (atof centerX)) *. ((atof MScale) /. (atof XScale)))) + offsetX;
          set iZ = (ftoi ((latitude -. (atof centerZ)) *. ((atof MScale) /. (atof ZScale)))) + offsetZ;		  

		  let GetAvatarPosition -> [Ox iY Oz] in		  		  

          if (((iOldX != nil) && (iOldZ != nil)) && ((ftoi sqrt (sqr itof (iX - iOldX)) +. (sqr itof (iZ - iOldZ))) > (iMaxDHor * iErrH)))then
		  /*else if (((Ox != 0) && (Oz != 0)) && ((ftoi sqrt (sqr itof (iX - Ox)) +. (sqr itof (iZ - Oz))) > (iMaxDHor * iErrH)))then*/
          (
            set iErrH = iErrH + 1;
			_echo strcatn "NMEA Err (pos XZ):"::(itoa iErrH)::"-["::(itoa Ox)::","::(itoa Oz)::"]-["::(itoa iY)::","::(itoa iZ)::"]"::nil
            0;
          )
          else
          (
            set iErrH = 1;
            /*set iOldX = iX;
            set iOldZ = iZ;<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
			
            if (av3dplugin!=nil) then /*update av3d */	
	          controlAv3d o [[iX iY iZ] GetAvatarAngle] [(M3getObj session "avatar")]
	        else				
			  SetAvatarPosition [iX iY iZ];
			  
			gps_echo strcatn "NMEA GPGGA:"::(itoa iX)::","::(itoa iY)::","::(itoa iZ)::nil
			saveLocation strcatn (ftoa latitude)::" "::(ftoa longitude)::nil
          );
        );        
        0;
      )
      else
        0;	
		
	  /*read next line */	
	  set lNMEAData = tl lNMEAData;	
	)
  )
  else nil;; 	 
 
/* if GpsRec flag is on and file exist */
/* read pre-recorded gps data file, not live gps calls*/
fun openNMEA(o) = 
   let atoi hd UgetParam ObUi o "GpsRec" -> GpsRec in
   let hd UgetParam ObUi o "GpsBuf" -> GpsBuf in
   if ((GpsBuf != "") && (GpsRec)) then 
   (
	 _getpack _checkpack GpsBuf;
   )	
  else nil;; 

fun UpdateGeo(param, o)= 
 /*play recorded -local file- mode */ 
 let atoi hd UgetParam ObUi o "GpsRec" -> GpsRec in 
 let atoi hd UgetParam ObUi o "BufReload" -> BufReload in
 
 if (GpsRec) then 
 (      
    if ((BufReload) && (!strcmp (hd lNMEAData) nil)) then
    (
        _echo strcat "Reload file" ""
        set lNMEAData = lineextr openNMEA o;
        0;  
	)
	else 0;	
			   
    readNMEA o;
    0;
 )
 else
 ( 
    INETGetURL _channel param 0 @CBgethttp [nil]; 
    echo strcat "get:" param
    0;
 );; 	
  
/*get the obj saved position to start */   
fun Init(param, o) =  

  let readLocation -> position in
  _echo strcatn "Init (restore user position):"::position::nil 
  
  /*_DMSsend this CsetPos [position]*/
  
  if (strlen position) then  		
    SetAvatarPosition latlon2vector position         	
  else 
	SetAvatarPosition [0 0 0]
;;

/* Load Static Scene **********************************************************/

fun GetSons(h3d) =
  if (h3d == nil) then
    nil
  else
    h3d::(GetSons M3getBrother session h3d);;
		
fun GetObjType(h3d) =  
  if (h3d == nil) then
    nil
  else
	let M3getObjType session h3d -> ret in
    ret;;
	
fun ApplyOrientation(l) =

  if (l == nil) then
    l
  else
    let M3getObjVec session (hd l) -> [x y z] in
    (
	
	  let M3getObjType session (hd l) -> mC3d_type in
      _echo strcatn "Object type in list:"::(itoa mC3d_type)::nil
  
      let M3objName session (hd l) -> mC3d_name in
      _echo strcatn "Object name in list:"::mC3d_name::nil  	  
	  
	  _echo strcatn "Orientation (x y z):"::(itoa x)::","::(itoa y)::","::(itoa z)::nil
	  
	  /*main scene Altitude réelle: 160m, Erreur de 30m prévue*/
      M3setObjVec session shell [0 15500 0];
	  
	  let atof getSessionParam 1 9 -> siAng in	  
      /*M3rotateObjExt session shell [siAng 0 0];*/ /* avatar back->front nav*/
	  
	  /*object in list*/
	  /*iScale */
      M3setObjVec session (hd l) [((x * (atoi getSessionParam 1 8)) / 100) 
	                              ((y * (atoi getSessionParam 1 8)) / 100) 
								  ((z * (atoi getSessionParam 1 8)) / 100)];
	  
	  /*_echo strcatn "Orientation vector (x y z * scale /100):"::(itoa (x * (getSessionParam 1 8) / 100)::","::(itoa (y * (getSessionParam 1 8) / 100)::","::(itoa (z * (getSessionParam 1 8) / 100)::nil*/
	  /*_echo strcatn "Orientation scale:"::(getSessionParam 1 8)::nil	*/  	  
	  
      M3setObjScale session (hd l) (atoi getSessionParam 1 8);
	  
      ApplyOrientation tl l;
    );;

fun SetOrientation(orientvalue) = 
 if orientvalue then 
 (
  let M3bigFather session cam -> H3d_Obj in
  /*let M3getFirstSon session H3d_Obj -> C3d_Obj in*/
  let M3getFirstSon session shell -> C3d_Obj in  
  
  /*get type*/
  let M3getObjType session C3d_Obj -> mC3d_type in
  _echo strcatn "Object type:"::(itoa mC3d_type)::nil
  /*get name*/
  let M3objName session C3d_Obj -> mC3d_name in
  _echo strcatn "Object name:"::mC3d_name::nil  
  
  let GetSons C3d_Obj -> lH3d in
  ApplyOrientation lH3d;
 )
 else  
 0;;
 
fun SetCamOnTop(camtopatstart) =
 if camtopatstart then
   CamOnTop viewLevelF6
 else 
   0;;

fun SetCamDefault() = 
  M3setObjVec session cam [0 0 0];
  M3setObjAng session cam [0 0 0];  
  M3setObjVec session cam [0 0 0];
  0;;
    
fun Init_Lights(lightvalue) =
 if lightvalue then
 (
  /* Ambient light */
  let M3createLight session LIGHT_AMBIENT lightvalue nil nil nil nil -> h3dALight in
  M3link session h3dALight shell;
 )
 else 
  0;;    
  
fun SetAvatar(avsetvalue) = 
 if avsetvalue then
 (
	  
  M3setObjVec session M3getFather session (ObGetMain owner) [(atoi getSessionParam 2 1) (atoi getSessionParam 2 2) (atoi getSessionParam 2 3)];
	
  set iIX = (((atoi getSessionParam 2 1) * (atoi getSessionParam 1 8)) / 100);
  set iIY = (((atoi getSessionParam 2 2) * (atoi getSessionParam 1 8)) / 100);
  set iIZ = (((atoi getSessionParam 2 3) * (atoi getSessionParam 1 8)) / 100);
  set iX = atoi getSessionParam 2 1;
  set iY = atoi getSessionParam 2 2;
  set iZ = atoi getSessionParam 2 3;
  set iOldX = nil;
  set iOldY = nil;
  set iOldZ = nil;
  set iErrH = 1;
  set iErrV = 1;

  M3setObjAng session M3getFather session (ObGetMain owner) [(ftoi (-.65536.0 *. ((atof getSessionParam 1 10) /. 360.0))) 0 0];
 )
 else 
  0;;	  
  
/*** ???? ****/  
fun Init_Collision(radius, height) = 
  //set shcamColl = 
  M3createSphere session radius;
  //M3setObjVec session shcamColl [0 height 0];
  //M3link session shcamColl shell;
  //let inboxTesting collCam session shcamColl [0 0 0] ->[newbox _] in
  //set collCam.curboxIB = newbox;
  0;;
    
  
fun InitializeScene(av, or, li, ca) =
  /* Avatar transformation..disabled */
  /*SetAvatar av;*/

  /*Add scene orientation */
  SetOrientation or;
  
  /*Add ligthing*/
  Init_Lights li;
  
  /*camera on top when start*/
  SetCamOnTop ca;
	
  /*collision */
  Init_Collision 50 50;  
0;;    

/* url read */
fun urlLocation (t, o)=

  UpdateGeo hd UgetParam ObUi o "starturl" nil;
  /*_echo strcatn "Timer:"::"onTop"::nil*/
  0;;
  
/*file read */  
fun fileLocation (t, o)=

   /*play recorded -local file- mode */ 
   let atoi hd UgetParam ObUi o "GpsRec" -> GpsRec in 
   let atoi hd UgetParam ObUi o "BufReload" -> BufReload in
   
   if ((BufReload) && (!strcmp (hd lNMEAData) nil)) then
   (
        /*get NMEA file from server */
        /*_echo strcatn "**RESOURCE REQUIRED :"::(ObName o)::nil   */
        /*UsendSrv this ObUi o "getFile" nil; */
   
        _echo strcat "Reload file" ""
        set lNMEAData = lineextr openNMEA o;
        0;  
   )
   else 0;	
  
   readNMEA o;
   /*_echo strcatn "Timer:"::"onTop2-"::param::nil*/
   0;; 
  
fun deleteTimer ()=
  _deltimer timer;
  0;;  
 
fun AutoStart(o) = 
 let atoi hd UgetParam ObUi o "auto" -> auto in
 let atoi hd UgetParam ObUi o "refresh" -> refresh in
 let hd UgetParam ObUi o "starturl" -> starturl in
 
 /*play recorded -local file- mode */ 
 let hd UgetParam ObUi o "GpsRec" -> GpsRec in 
  
 if (auto) then 
 (
    /*_DMSevent this "gpsupdate" starturl nil;*/
	/*UsendSrv this (ObUi o) "gpsupdate" (ObName o); */
	/*UsendCli this cli ui "gpsupdate" param */
	
	_echo strcatn "Auto start:"::(starturl)::nil
		
	if (atoi GpsRec) then 
	(
	  set timer = _rfltimer _starttimer _channel refresh @fileLocation o ;  
	  0;
	)  
	else
	(
      set timer = _rfltimer _starttimer _channel refresh @urlLocation o ;  
	  0;
	)  

 )
 else /* update position per n sec */
 (
   set timer = _rfltimer _starttimer _channel posCheck @updateLocation o ;   
   0;
 );;   
 
fun getSessionData() = 
   let strcatn "session_"::(itoa sno)::".txt"::nil -> ses in
   let strcat sessionpath ses -> sesfile in
   strextr _getpack _checkpack sesfile
;; 

fun activate(o,from,action,param,reply,l)=  

   if !strcmp action (strcatn (ObName o)::".gpsupdate"::nil) then 
     ( 
	  UpdateGeo param o;
	  echo strcatn "Update:"::(ObName o)::nil
	  0;
	 ) 
   else 
   if !strcmp action (strcatn (ObName o)::".gpswalkview"::nil) then
     ( 
	    SetCamDefault;	
		echo "Camera default position"
		0;
     )   
   else 
   if !strcmp action (strcatn (ObName o)::".gpsinit"::nil) then
    ( 
		 Init param o; 
		 echo "Initialize"
		 0;
   )
   else 
   if !strcmp action (strcatn (ObName o)::".gpstopview"::nil) then
    ( 
		 SetCamOnTop 1;
		 echo "Camera top position"
		 0;
   )   
   else nil;;

 
/*file has been downloaded*/
fun DownloadedFile(FileName,o)=

 let _checkpack FileName -> p in

 if p==nil then 
  ( _echo strcatn "**DOWNLOAD RESOURCE ERROR : file not found"::nil  0;)
 else
  ( _echo strcatn "**DOWNLOAD RESOURCE : file downloaded"::nil 0;)
;;

fun newOb2(o)= 
  //if o==owner then /*local avatar*/ 
  //( 
    //_echo strcat "OWNER:" "......................."
	
	set av3dplugin = 1; /*set plugin on*/
	
    let strcatn iniPath::DMSname::".conf"::nil -> configFileName in /*get the possible view <= previous view*/
    let strextr _getpack _checkpack configFileName -> l in
    let getInfo l "viewLevel" -> res in
	(
	    if res==nil then set viewLevel=0
        else         
        if (viewLevelF6!=0) && (atoi res)>=viewLevelF6 then set viewLevel = viewLevelF6
        else		
        if (viewLevelF5!=0) && (atoi res)>=viewLevelF5 then set viewLevel = viewLevelF5
        else
        if (viewLevelF4!=0) && (atoi res)>=viewLevelF4 then set viewLevel = viewLevelF4
        else
        if (viewLevelF3!=0) && (atoi res)>=viewLevelF3 then set viewLevel = viewLevelF3
        else
          set viewLevel=0;
	);
	
    set sh =    M3createShell session;
    set sh0 =   M3createShell session;        
    set shcam = M3createShell session; 	
	
	M3load session avfile nil;
	
    let M3getObj session "avatar" -> avatar in
    (                                   
       set avatar = M3getObj session "avatar";
       M3recursFillMatObj session avatar;                     
       M3link session avatar sh0;
       
       let M3getObjVec session avatar -> [x y z] in
         M3setObjVec session avatar [x y+hauteurAvatarSol-hauteurOrientation z]; /**MODIF SD pour s'orienter correctement vers l'avatar (a partir des autres classes)**/
              
       /*collisions avatar*/
       /*set h = M3createObb session [coll_x coll_y coll_z];*/
       set h = M3createSphere session 50;
       M3setObjVec session h [0 100 0];

       M3link session h sh;                

       set shcamColl = M3createSphere session 20; /*sphere de collision pour la camera*/

       M3link session sh0 sh; /*link yeux*/
       M3link session shcam sh;  	
	
       /****************************************/
       set dummyCam = M3createShell session;
       M3link session dummyCam sh;

       /****************************************/
       set dummyTarget = M3createShell session;	     
       let M3getObjVec session avatar -> [xa ya za] in
       (                  
         if linkCamAvatar then
          M3setObjVec session dummyTarget [xa 138+delta_b za+40]
         else
          M3setObjVec session dummyTarget [xa 135+delta_b za+40];
       );

       M3link session dummyTarget sh;

       M3link session sh shellav; 
       ObSetMain o shcam;
	   
       ObCbDestroy o @destroyLocalAvatar;
       //runAnimStop o avatar;/*run the anim on the mesh*/	   
	   ObSetCam o;
	   M3setObjVec session sh0 [0 hauteurOrientation 0];
	   ObSetMain o sh0;	
	    
       M3link session shcam sh;
       set linkCamAvatar = 1;
       ObCbPostRender o nil;
       CamDefault;	   
	      
       ObCbControlKeyDown o mkfun3 @cbCameraKey sh; 
       ObCbControl o mkfun3 @controlAv3d [avatar]; 
	
	   /* systeme de collision pour la camera initialise avec celui de l'avatar */
       set collCam=mkInBox [coll.nameIB coll.sIB coll.curboxIB coll.rayonIB coll.gravityIB];
       
       ObCbSetpos  o @Setpos; /*first time only*/	   
	   Usend this ObUi o "getMeshPhoto" nil; /*ask the server for the avatar mesh and photo*/
	   0
	)
    /*	
  )
  else nil;;  */
  ;;
  
/**** create distance dummy avatar ****************/ 
var avfile="Dms/3d/Plugins/SnapAv22/av.m3d";;
typeof avatar=H3d;;

fun updateCamPos3(sh)=

 /*real avatar*/
 let M3getFather session (ObGetMain owner) -> main in

 let [0 0] -> [yc zc] in
 (
  set yc = (ftoi ((itof av3dCamDist) *. sin av3dCamAngle));
  set zc = (- (ftoi ((itof av3dCamDist) *. cos av3dCamAngle)))+20;

  M3setObjVec session sh [0 yc zc];
  M3setObjAng session sh (M3angularTarget (M3getObjVec session sh) (M3getObjVec session main));
  0
 );;
 

fun moveCamera3(objb,i2,param)= 
 let param ->[o sh] in  
 let M3getObjVec session shcam -> [xc yc zc] in
 let M3calcPosRef session dummyCam shell -> [[xdw ydw zdw] _] in
 (
   /* calcul des nouveaux coordonnees de la camera (interpolation )*/
  let (xc + (xdw - xc) / cel.Cel3dspeed) -> a in
  let (yc + (ydw - yc) / cel.Cel3dspeed) -> b in
  let (zc + (zdw - zc) / cel.Cel3dspeed) -> c in
  
  
  let M3calcPosRef session dummyCam shcam -> [[x y z] _] in
  (
    M3setObjVec session shcamColl [xc yc zc];
	let inboxTesting collCam session shcamColl [0 0 0] ->[newbox _] in
    set collCam.curboxIB = newbox;
	 
	let inboxTesting collCam session shcamColl [(a-xc) (b-yc) (c-zc)] ->[newb [npx npy npz]] in
	(
     M3setObjVec session shcam [npx npy npz];
     M3setObjVec session shcamColl [npx npy npz];
    );	
	
    let M3calcPosRef session dummyTarget shell -> [t _] in
    M3setObjAng session shcam (M3angularTarget (M3getObjVec session shcam) t);
	
    if !strcmp ModeVue "PremierePersonne" then
     if (( (oldav3CamDist>500)  && (z<50) && (z>(-50)) ) || ( (oldav3CamDist<=500) && (z<60) && (z>(-60)) )) then 
     (    	    
      M3link session shcam sh;		
      set linkCamAvatar = 1;			
      ObCbPostRender o nil;	     
      updateCamPos3 sh;
     ) 
     else nil
	else nil; 
  );
  0
 );;

fun CamDistance3(o,sh,distanceCamera) =

 if viewLevel==viewLevelF6 then
   CamDefault /*reset if come from top view*/
 else nil;

 
 let strcatn iniPath::DMSname::".conf"::nil -> configFileName in
    _storepack strbuild ("viewLevel"::(itoa distanceCamera)::nil)::nil configFileName; 
    
 set viewLevel=distanceCamera;
 set ModeVue = "TroisiemePersonne";
 //ObCbPostRender o mkfun3 @moveCamera3 [o sh]; 
 
 //M3setObjVec session sh [0 distanceCamera 0]; /*test*/
 /*real avatar*/
 let M3getFather session (ObGetMain owner) -> main in
 
 let M3calcPosRef session sh shell -> [coord_t CamMatrix] in
 let M3angularFromMatrix CamMatrix -> angle_t in
  (                           
   M3setObjVec session sh coord_t;
   M3setObjAng session sh angle_t
  ); 

 set linkCamAvatar = 0;						     
 set oldav3CamDist= av3dCamDist;
 set av3dCamDist = distanceCamera;
 set av3dCamAngle = atof "0.5";  
 updateCamPos3 sh; 
 0;; 

fun cbCameraKey3(o,t,sh)=
 let t -> [_ code] in  
  if code==65471 then  /*<F2>*/
   (
    ObSetCam owner;
    CamDefault;
    let strcatn configPath::DMSname::".conf"::nil -> configFileName in
      _storepack strbuild ("viewLevel"::"0"::nil)::nil configFileName;
    set viewLevel=0
   ) 
  else if ((code==65472)&&(viewLevelF3!=0)) then 
   (
    ObSetCam o;
	CamDistance3 o sh viewLevelF3;
	0
   ) 	
  else if ((code==65473)&&(viewLevelF4!=0)) then /*<F7>*/
  (
    ObSetCam o;
    CamDistance3 o sh viewLevelF4;
    0	
  )	
  else if ((code==65474)&&(viewLevelF5!=0)) then /*<F8>*/
  (
    ObSetCam o;
    CamDistance3 o sh viewLevelF5;
	0
  )	
  else if ((code==65475)&&(viewLevelF6!=0)) then 
  (
    ObSetCam owner;
    CamOnTop viewLevelF6;
	0
  )	  
  else nil;; 

fun destroyPho(o)=
  M3delObj session ObGetMain o;
  0
;;

fun animPho(o, q) =
  let q->[h x] in
  let (100+x)&4095 -> x in
  let if x&2048 then 3072-x else x-1024 -> z in
  (
    let M3getObjAng session h -> [a _ c] in
    M3setObjAng session h [a z c];
    let M3getObjVec session h -> [a _ c] in
    M3setObjVec session h [a (z>>6) c];
    mutate q<-[_ x];
    0
  )
;;
  
fun newOb3(o)=  

  set av3dplugin = 1; /*set plugin on*/
	
  let strcatn iniPath::DMSname::".conf"::nil -> configFileName in /*get the possible view <= previous view*/
  let strextr _getpack _checkpack configFileName -> l in
  let getInfo l "viewLevel" -> res in
  (
	    if res==nil then set viewLevel=0
        else         
        if (viewLevelF6!=0) && (atoi res)>=viewLevelF6 then set viewLevel = viewLevelF6
        else		
        if (viewLevelF5!=0) && (atoi res)>=viewLevelF5 then set viewLevel = viewLevelF5
        else
        if (viewLevelF4!=0) && (atoi res)>=viewLevelF4 then set viewLevel = viewLevelF4
        else
        if (viewLevelF3!=0) && (atoi res)>=viewLevelF3 then set viewLevel = viewLevelF3
        else
          set viewLevel=0;
  );
	
  M3load session avfile nil;
  set avatar = M3getObj session "snap";
  let M3createShell session -> sh in
  let M3copyObj session avatar -> hnew in
  (
    M3recursFillMatObj session hnew;
    M3link session hnew sh;
    ObSetMain o sh;
    ObCbAnim o mkfun2 @animPho [hnew 0];
    ObCbDestroy o @destroyPho;
    ObCbControlKeyDown o mkfun3 @cbCameraKey3 sh; 
    //ObCbControl o mkfun3 @controlAv3d3 [avatar]; 	
    0
  );;  
  
  
  

fun cbcomm(ui,action,param,o)=
 if !strcmp action "setFile" then
 (
   let lineextr param -> [name[long _]] in
   if (atoi long) <= maxDownloadSize then
   (
	   /*_echo strcatn "**RESOURCE : ObName = "::(ObName o)::"-"::(name)::nil*/
	   /*_echo "**RESOURCE : download..."*/
	   _RSCdownload this name name mkfun2 @DownloadedFile o 1;
	   0;
	)
    else
    (
	   _echo strcatn "**RESOURCE : ObName = "::(ObName o)::"-"::(name)::nil
	   _echo "**RESOURCE : not download"
	   DownloadedFile name o;
	   0;
	)
 )	
 else if !strcmp action "changeView" then 
 (
    let strextr param -> l in
    let hd switchstr l "viewLevel" -> level in
    if level==nil || (!strcmp level "0") || param==nil then
    (
	  CamDefault;
      let strcatn configPath::DMSname::".conf"::nil -> configFileName in
      _storepack strbuild ("viewLevel"::"0"::nil)::nil configFileName;
      set viewLevel=0
	)
    else
      CamDistance o sh atoi level 
 )
 else if !strcmp action "setMeshPhoto" then
    let strextr param -> l in
    let getInfo l "sign" -> sign in
    let getInfo l "f" -> f in
    let getInfo l "meshFileName" -> meshFileName in  
    ( _DLGMessageBox _channel nil "setMeshPhoto" param 0; /*DEBUG SEB*/
      if meshFileName==nil then nil else applyMesh o meshFileName;
      if sign==nil then nil else applyface sign o atoi f
    ) 
 else if !strcmp action "setAvDefFile" then
    (
	  set avfile=param;
	  newOb2 o
	) 
 else nil;; 

fun newOb(o)=
   /*begin session*/
   set sno = rand;
   set nsno = strcatn (ObName o)::"/"::(itoa sno)::nil;
   let hd UgetParam ObUi o "initsession" -> isession in
   let hd UgetParam ObUi o "initparser" -> iparser in
   
   /*in this file write static params */   
   let strcatn "session_"::(itoa sno)::".txt"::nil -> ses in
   let strcat sessionpath ses -> sesfile in
   _storepack strcatn isession::"\n"::iparser::nil sesfile;
   
   /*read session to variable */
   set sesdata = getSessionData;
   _echo strcatn "Session:"::(strbuild sesdata)::nil  

   UcbComm this ObUi o mkfun4 @cbcomm o;
   
   /*get NMEA file from server */
   _echo strcatn "**RESOURCE REQUIRED :"::(ObName o)::nil   
   UsendSrv this ObUi o "getFile" nil;    
   
   /*read NMEA file (if defined) for first time */
   /*if reload parameter recall (see code up)*/     
   set lNMEAData = lineextr openNMEA o;
            
   /*play recorded -local file- mode */
   let hd UgetParam ObUi o "GpsRec" -> GpsRec in 
   _echo strcatn "Local data:"::(ObName o)::"-"::GpsRec::nil 			

  /*instance ui values*/
  let atoi hd UgetParam ObUi o "initav" -> av in
  let atoi hd UgetParam ObUi o "initor" -> or in
  let atoi hd UgetParam ObUi o "initli" -> li in
  let atoi hd UgetParam ObUi o "initca" -> ca in
  
  /*init scene */  
  InitializeScene av or li ca;
  
  /*init avatar position*/
  Init nil o; 
  
  /*auto start gps route*/
  AutoStart o;  
  
  ObRegisterAction o (strcatn (ObName o)::".gpsupdate"::nil) mkfun6 @activate nil;
  ObRegisterAction o (strcatn (ObName o)::".gpswalkview"::nil) mkfun6 @activate nil;
  ObRegisterAction o (strcatn (ObName o)::".gpsinit"::nil) mkfun6 @activate nil;    
  ObRegisterAction o (strcatn (ObName o)::".gpstopview"::nil) mkfun6 @activate nil;
  
  /*av3d*/
  if o==owner then Usend this ObUi o "init" nil else nil; /*SD*/
  
  /*if avfile==nil then //get default avfile
    Usend this ObUi o "avDefFile" nil
  else
    newOb2 o;  */
  newOb3 o;	
0;; 

fun destroyPlug()=  

  deleteTimer;
  
  /* let strcatn "destroy_"::(itoa sno)::".txt"::nil -> ses in
   let strcat sessionpath ses -> sesfile in
   _storepack strcatn "A"::"\n"::"B"::nil sesfile;  
   */
  /*can't in cache...
  let strcatn (sessionpath)::"gpsroute.txt"::nil -> routeBuf in
  _deletepack routeBuf;
  */
 0;;   

fun IniPlug(file)=
 set class=getInfo strextr _getpack _checkpack file "name";
 
 set viewLevelF3 = 100;
 set viewLevelF4 = 200;
 set viewLevelF5 = 400;
 set viewLevelF6 = 110000;
 set coll_enabled = 1;
 set canFly = 1;
 set ArrivalZoneSize = 100;
 
 /*override with c3d settings */
 let hd Obgetglobalress "viewLevelF6" -> res in
   if res==nil then nil else set viewLevelF3 = atoi res;
 
 let hd Obgetglobalress "viewLevelF7" -> res in
   if res==nil then nil else set viewLevelF4 = atoi res;
  
 let hd Obgetglobalress "viewLevelF8" -> res in
   if res==nil then nil else set viewLevelF5 = atoi res;
   
 let hd Obgetglobalress "arrivalZoneSize" -> res in
   if res==nil then nil else set ArrivalZoneSize = atoi res;  
   
 let hd Obgetglobalress "collEnabled" -> res in
   if res==nil then nil else set coll_enabled = atoi res;  
   
 let hd Obgetglobalress "canFly" -> res in
   if res==nil then nil else set canFly = atoi res;   
 
 /*set timer = _rfltimer _starttimer _channel calibrationtime @rflTimer 0 ;   */ 
 
 PlugRegister class @newOb nil;  
 0;;