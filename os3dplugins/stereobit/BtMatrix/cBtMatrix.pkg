/*
-----------------------------------------------------------------------------
This source file is part of OpenSpace3D
For the latest info, see http://scol.stereobit.gr

Copyright (c) 2016 stereobit.networlds

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA, or go to
http://www.gnu.org/copyleft/lesser.txt

-----------------------------------------------------------------------------
*/

/*******************************************************************************
 Plugin BtMatrix
 Client part
 Version: 1.0
 Author: stereobit.networlds, Bastien BOURINEAU
 Date: 21/01/2016
 Last update: 21/01/2016
*******************************************************************************/

struct PlugPicture = [
  PICT_instance                : PInstance,
  PICT_iRightAlign             : I,
  PICT_iOffset                 : I,
  PICT_ifsep                   : I,
  PICT_ifmsize                 : I,
  PICT_iUrl                    : S,
  
  PICT_win                     : SO3_WIDGET,
  PICT_AlphaBuffer             : AlphaBitmap,
  
  PICT_iPosX                   : I,
  PICT_iPosY                   : I,
  PICT_iWidth                  : I,
  PICT_iHeight                 : I,
  PICT_tPercent                : [I I I I I I I I],
  PICT_tAlign                  : [I I],
  
  PICT_bTransparency           : I,
  PICT_iOpacity                : I,
  PICT_iTransition             : I,
  PICT_fTransOpacity           : F,
  
  PICT_bUrl                    : I,
  PICT_sPath                   : S,  
  PICT_bBackground             : I,
  PICT_bShow                   : I,
  PICT_httpReq                 : ObjCURL,
  
  PICT_imgpath                 : S,
  PICT_isimgurl                : I,  
  PICT_imgurl                  : S, 
  PICT_linfoImages             : [[AlphaBitmap S I I I I S I SO3_WIDGET] r1], 
  
  //PICT_bUrl                    : I,
  //PICT_sPath                   : S,  
  PICT_iClick                  : I,
  PICT_bLastCursor             : I,
  PICT_bShowCursor             : I,
  PICT_bEnableMouse            : I,
  //PICT_bShow                   : I,
  PICT_iAvStates               : I,
  PICT_iState                  : I,
  PICT_iNbFrames               : I,
  PICT_iCurFrame               : I,
  PICT_iTick                   : I,
  PICT_iLastInputState         : I,
  PICT_tLastPos                : [I I],
  PICT_lInputs                 : [[S [I I]] r1],
  PICT_trmMouseState           : Timer // to enable the mouse after touch manipulation
  //PICT_httpReq                 : ObjCURL  

  ] MkPlugPicture;;


var sTmpDownloadPath = "tmp/pictures/";;

var iTexWidth = 512;;
var iTexHeight = 512;;


/*IMG bitmaps*/
/*bmp name width height xonscreen yonscreen alphachannel url inzone*/ 
typeof linfoImages = [[AlphaBitmap S I I I I S I SO3_WIDGET] r1];; 

var log=1;;
var debug=0;;

var MXWidgetLayer=300;;
var sHandCursor = "os3dlib/res/link_cursor.bmp";;
typeof cHandCursor = ObjCursor;;
typeof cPrevCursor = ObjCursor;;

var server=0;; /*when scol server is on */



fun _echo(pictstr,s)= 
   if (log==1) then
	SendPluginEvent pictstr.PICT_instance "echo" s nil
   else
     nil;;
	 
/*** see at contextHelp event ***/
fun eventParam(a, b) = 
  strbuild ("ref"::a::nil)::("userParam"::b::nil)::nil;;

fun searchSlash(string, pos)=
  let strfind "/" string pos -> r in
  if r != nil then
    searchSlash string r+1
  else
    pos;;
	
fun print_r	(list) = 
  if list == nil then
    nil
  else 
  ( let hd list -> [_ x y sx sy c v _ _ ] in
    _fooS strcatn "print_r:"::(itoa x)::"-"::(itoa y)::"-"::(itoa v)::"-"::c::nil;
    print_r tl list;
	0
  );; 	
	

fun createImage(ch,w,h) = _CRbitmap ch w h;; 
fun cpyImage(dest, dx, dy, source, sx, sy, sw, sh, trans)= _CPbitmap24 dest 0 0 source sx sy sw sh trans;; 

fun createAlphaImage(ch,w,h) = _CRalphaBitmap ch (_CRbitmap ch w h) (_CRbitmap8 ch w h) nil 0;;


fun computePosSize(pictstr, vw, vh)=
  let pictstr.PICT_tPercent -> [px py pw ph xo yo wo ho] in
  let pictstr.PICT_tAlign -> [ax ay] in
  let if pw then (ftoi (((itof pictstr.PICT_iWidth) /. 100.0) *. (itof vw))) + wo else pictstr.PICT_iWidth -> pw in
  let if ph then (ftoi (((itof pictstr.PICT_iHeight) /. 100.0) *. (itof vh))) + ho else pictstr.PICT_iHeight -> ph in
  let if px then (ftoi (((itof pictstr.PICT_iPosX) /. 100.0) *. (itof vw))) + xo else pictstr.PICT_iPosX -> px in
  let if (ax == 1) then ((vw / 2) - (pw / 2)) + px else if (ax == 2) then (vw - pw) - px  else px -> px in
  let if py then (ftoi (((itof pictstr.PICT_iPosY) /. 100.0) *. (itof vh))) + yo else pictstr.PICT_iPosY -> py in
  let if (ay == 1) then ((vh / 2) - (ph / 2)) + py else if (ay == 2) then (vh - ph) - py else py -> py in
    [px py pw ph];;	



fun updateButton(btnstr)=0;;
/*
  if (pictstr.PICT_win == nil) then nil else
  let _GETalphaBitmapSize pictstr.PICT_AlphaBuffer -> [bw bh] in
  let _GETalphaBitmapSize pictstr.PICT_AlphaDraw -> [dbw dbh] in
  let bw / pictstr.PICT_iNbFrames -> width in
  let bh / (pictstr.PICT_iAvStates + 1) -> height in
  let (bw / pictstr.PICT_iNbFrames) * pictstr.PICT_iCurFrame -> wpos in
  let if (!pictstr.PICT_iAvStates) then 0 else height * pictstr.PICT_iState -> ypos in
  (
    if ((pictstr.PICT_AlphaDraw == nil) || (dbw != width) || (dbh != height)) then
    (
      _DSalphaBitmap pictstr.PICT_AlphaDraw;
      
      let _CRbitmap _channel width height -> bmp24 in
      let _CRbitmap8 _channel width height -> bmp8 in
        set pictstr.PICT_AlphaDraw = _CRalphaBitmap _channel bmp24 bmp8 nil nil;
    )
    else nil;
    
    let _GETalphaBitmaps pictstr.PICT_AlphaBuffer -> [colorLayer alphaLayer] in 
    let _GETalphaBitmaps pictstr.PICT_AlphaDraw -> [colorDraw alphaDraw] in
    (
      _CPbitmap24 colorDraw 0 0 colorLayer wpos ypos width height nil;
      _CPbitmap8 alphaDraw 0 0 alphaLayer wpos ypos width height nil;
    );
    
    drawLabel pictstr.PICT_AlphaDraw btnstr;
    SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaDraw;
  );
  0;;*/  
  	
	
fun cbMouseIn(widget, pictstr)=
  if(pictstr.PICT_iState == 3) || (pictstr.PICT_iClick != 0) then nil else
  (
    set pictstr.PICT_iState = 1;
    let V3DgetSessionView c3dXsession -> viewstr in
    if (!pictstr.PICT_bShowCursor || pictstr.PICT_bLastCursor || (!V3DgetCursorVisible viewstr)) then nil else
    (
      set pictstr.PICT_bLastCursor = 1;
      let V3DgetCursor viewstr -> pcursor in
      if (pcursor == cHandCursor) then nil else
        set cPrevCursor = pcursor;
      
      V3DsetCursor viewstr cHandCursor;
    );
    
    //update bitmap
    if(pictstr.PICT_iAvStates <= 0) then nil else
    (
      updateButton pictstr;
      0;
    );
    
    SendPluginEvent pictstr.PICT_instance "MouseOver" nil nil;
  );
  0;;


fun cbMouseOut(widget, pictstr)=
  if(pictstr.PICT_iState == 3) then nil else
  (
    if (pictstr.PICT_iClick != 0) then nil else
    (
      let V3DgetSessionView c3dXsession -> viewstr in
      if (!pictstr.PICT_bShowCursor || !pictstr.PICT_bLastCursor || (!V3DgetCursorVisible viewstr)) then nil else
      (
        set pictstr.PICT_bLastCursor = 0;
        V3DsetCursor viewstr cPrevCursor;
        set cPrevCursor = nil;
      );
    
      set pictstr.PICT_iState = 0;
      
      //update bitmap
      if(pictstr.PICT_iAvStates <= 0) then nil else
      (
        updateButton pictstr;
        0;
      );
      
      //SendPluginEvent pictstr.PICT_instance "Released" nil nil;
      SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
    );
  );
  0;;


fun cbClick(widget, pictstr, x, y, btn)=
  if(pictstr.PICT_iState == 3) then nil else
  (
    if (pictstr.PICT_iState == 2) && (pictstr.PICT_iClick == 0) then nil else
    (
      SendPluginEvent pictstr.PICT_instance "Pushed" nil nil;
      set pictstr.PICT_tLastPos = [x y];
    );
    
    set pictstr.PICT_iClick = pictstr.PICT_iClick|btn;
    set pictstr.PICT_iState = 2;
    
    if(pictstr.PICT_iAvStates <= 1) then nil else
    //update bitmap
    (
      updateButton pictstr;
      0;
    );
  );
  0;;


fun cbUnClick(widget, pictstr, x, y, btn)=
  if (pictstr.PICT_iState == 3) then nil else
  (
    if (pictstr.PICT_iState != 2) then nil else
    (
      set pictstr.PICT_tLastPos = nil;
      SendPluginEvent pictstr.PICT_instance "Released" nil nil;
      if (SO3WidgetIsMouseOver pictstr.PICT_win) then nil else
      (
        SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
      );
    );
    
    if (!SO3WidgetIsMouseOver pictstr.PICT_win) then
    (
      let V3DgetSessionView c3dXsession -> viewstr in
      if (!pictstr.PICT_bShowCursor || !pictstr.PICT_bLastCursor || (!V3DgetCursorVisible viewstr)) then nil else
      (
        set pictstr.PICT_bLastCursor = 0;
        V3DsetCursor viewstr cPrevCursor;
        set cPrevCursor = nil;
      );
      SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
      0;
    )
    else
    (
      if btn == 1 then
        SendPluginEvent pictstr.PICT_instance "LeftClick" nil nil
      else if btn == 2 then
        SendPluginEvent pictstr.PICT_instance "RightClick" nil nil
      else if btn == 16 then
        SendPluginEvent pictstr.PICT_instance "MiddleClick" nil nil
      else nil;
      0;
    );
    
    set pictstr.PICT_iState = if (SO3WidgetIsMouseOver pictstr.PICT_win) then 1 else 0;

    //update bitmap
    if(pictstr.PICT_iAvStates <= 0) then nil else
    (
      updateButton pictstr;
      0;
    );
  );
  set pictstr.PICT_iClick = 0;
  0;;


fun cbMouseMove(widget, pictstr, x, y, btn)=
  if (pictstr.PICT_iClick == 0) || (pictstr.PICT_tLastPos == nil) then nil else
  let pictstr.PICT_tLastPos -> [px py] in
  let (min pictstr.PICT_iWidth pictstr.PICT_iHeight) -> msize in
  let (itof (x - px)) /. (itof msize) -> fx in
  let if (fx >. 1.0) then 1.0 else if (fx <. (-.1.0)) then (-.1.0) else fx -> fx in
  let (itof (py - y)) /. (itof msize) -> fy in
  let if (fy >. 1.0) then 1.0 else if (fy <. (-.1.0)) then (-.1.0) else fy -> fy in
  (
    SendPluginEvent pictstr.PICT_instance "Pushed move" strcatn (ftoa fx)::" "::(ftoa fy)::nil nil;
  );
  0;;


fun cbFocused(widget, pictstr, state)=
  if (state || (pictstr.PICT_iState != 2) || (pictstr.PICT_iClick == 0)) then nil else
  (
    set pictstr.PICT_tLastPos = nil;
    SendPluginEvent pictstr.PICT_instance "Released" nil nil;

    let V3DgetSessionView c3dXsession -> viewstr in
    if (!pictstr.PICT_bShowCursor || !pictstr.PICT_bLastCursor || (!V3DgetCursorVisible viewstr)) then nil else
    (
      set pictstr.PICT_bLastCursor = 0;
      V3DsetCursor viewstr cPrevCursor;
      set cPrevCursor = nil;
    );
    
    SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
    
    set pictstr.PICT_iClick = 0;
    set pictstr.PICT_iState = 0;

    //update bitmap
    if(pictstr.PICT_iAvStates <= 0) then nil else
    (
      updateButton pictstr;
      0;
    );
  );
  0;;	
	
	 
/************** info images *********************/

fun createMXWidget(viewportstr, id, x, y, sx, sy) = 
  SO3BitmapWidgetCreate (V3DgetSession c3dXsession) viewportstr.V3D_viewport (strcat "matrixCtrl_" id) x y sx sy MXWidgetLayer;;
  
 /* let SO3BitmapWidgetCreate (V3DgetSession c3dXsession) viewportstr.V3D_viewport (strcat "matrixCtrl_" id) x y sx sy 100 -> mxwidget in
  (
    SO3WidgetSetTopOnFocus mxwidget 0;
    SO3WidgetSetForeground mxwidget 1;	 
    V3DaddWidgetControl viewportstr mxwidget;
    SO3WidgetSetKeyboardEnable mxwidget 0;
    SO3WidgetSetMouseEnable mxwidget 0;
    //SO3WidgetSetTransparency mxwidget Transparency;
    SO3WidgetSetOpacity mxwidget (itof 100) *. 0.01;
    SO3WidgetSetVisibility mxwidget 0;
    mxwidget
  );;*/

fun setUrl(inst, pictstr, images) =
  if images==nil then
    nil
  else
    /*additional a file list can replace urls... ?*/
    let (getPluginInstanceParam inst "url") -> url in	
    ( 
	  mutate hd images <- [_ _ _ _ _ _ url _ _];		
      setUrl inst pictstr (tl images);
	  0
    );; 	  
	  
/*create dynamic matrix*/	  
fun makeMatrix(pictstr) = 
  //let [0 0 0]::[1 0 0]::[2 0 0]::[3 0 0]::[4 0 0]::nil -> matrix in

  let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [_ ScreenH] in
  
  let (ScreenH/(pictstr.PICT_ifmsize+pictstr.PICT_ifsep))-pictstr.PICT_iOffset-1 -> hMatrix in
  let nil -> matrix in
  let 0 -> i in
  (
    while (i<=hMatrix) do
    (
      set matrix = [(hMatrix-i) 0 0]::matrix;
	  set i = i + 1;
    );
    matrix
  );;
  
/*matrix 90x90=mbox 5x5 or dynamic*/	  
fun showInfoImagesMatrix(pictstr,matrix,i,images,params,viewportstr) =
  if images==nil then
    nil
  else 
    let sizelist matrix -> msize in
    let if (i<msize) then nth_list matrix i 
	    else (set i=0; nth_list matrix i) 
		-> [ln m _] in
	let hd images -> [_ n w h _ _ u _ mxwidget] in
    (
	    //_echo strcatn "Matrix:"::n::","::(itoa m)::","::(itoa i)::","::(itoa ln)::nil		
		
		/******************** init widget ***************/
        SO3WidgetEnterEventCb mxwidget @cbMouseIn pictstr;
        SO3WidgetExitEventCb mxwidget @cbMouseOut pictstr;
        SO3WidgetMouseDownEventCb mxwidget @cbClick pictstr;
        SO3WidgetMouseUpEventCb mxwidget @cbUnClick pictstr;
        SO3WidgetMouseMoveEventCb mxwidget @cbMouseMove pictstr;
        SO3WidgetFocusEventCb mxwidget @cbFocused pictstr;
    
        //V3DaddWidgetControl viewportstr mxwidget; //!!!slow not moving
        SO3WidgetSetTopOnFocus mxwidget 0;
        SO3WidgetSetForeground mxwidget 1;	
        SO3WidgetSetKeyboardEnable mxwidget 0;
        SO3WidgetSetMouseEnable mxwidget pictstr.PICT_bEnableMouse;
        SO3WidgetSetTransparency mxwidget pictstr.PICT_bTransparency;
        SO3WidgetSetOpacity mxwidget (itof pictstr.PICT_iOpacity) *. 0.01;
        SO3WidgetSetVisibility mxwidget 0;	
		
		let if (u!=nil) then u else pictstr.PICT_iUrl -> goto in /*if pre inserted*/
	    let m +(w/pictstr.PICT_ifmsize) -> nlrx in
		let if (h<=pictstr.PICT_ifmsize) then 1 else (h/pictstr.PICT_ifmsize) -> nlry in /*next line reserve 1+ if bigger than PICT_ifmsize(=90) on y*/			
		let if (m>=msize) && (nlrx>msize) then
		(
		  let i -> spin in
		  let m -> m2 in
		  let 0 -> wayout in
		  ( /*spin matrix, jump line to find place */
		    while ((w/pictstr.PICT_ifmsize)<(msize-m2)) || (wayout<100) do 
		    ( set wayout = wayout + 1;	
			  if (spin<msize) then
		        set spin = spin + 1
			  else
                set spin = 0;
			  let nth_list matrix spin -> [_ m2 _] in			
			  /*last line default place when imgs out of matrix range*/
			  if wayout==100 then msize-1 else spin 
            )
		  )		
		)  
		else i -> iy in
		
		( 
		  //_echo strcatn "Matrix:"::n::","::(itoa iy)::nil
		  let params -> [xstart ystart xwidth ywidth] in
		  let if (pictstr.PICT_iRightAlign==1) then 
		    (xwidth-((m*pictstr.PICT_ifmsize)+(m*pictstr.PICT_ifsep)+w+pictstr.PICT_ifsep)) 
		  else 
		    (xstart+(m*pictstr.PICT_ifmsize)+(m*pictstr.PICT_ifsep)) -> nx in
			
		  let (ystart+(ln*pictstr.PICT_ifmsize)+(ln*pictstr.PICT_ifsep)) -> ny in
          (
		     let 0 -> z in
			 let iy -> iz in
			 (
		       while (z < nlry) do  /*inplace image, spin matrix */		
			   (		  
			     mutate nth_list matrix iz <- [_ nlrx _];
			     if (iz+1<msize) then
			       set iz = iz + 1
			     else
                   set iz = 0;
                 set z = z + 1;
                 0			   		   
               );
		       mutate hd images <- [_ _ _ _ nx ny goto _ _];
		       //_echo strcatn "Matrix:"::n::","::(itoa ln)::","::(itoa nlr1)::","::(itoa nlr2)::","::(itoa nx)::","::(itoa ny)::nil
		       showInfoImagesMatrix pictstr matrix (iz) (tl images) params viewportstr ;
		       0
			 )
		  )
		)    
    );;  

   	
	
/** DOWNLOAD INFO IMAGES *************************************************/

/** web server version **/   
fun endDownloadImage(file, data, x)= 
  let strfind ".png" file 0 -> r in  
  let x -> [i fsize viewportstr pictstr] in    
  if data == nil then nil else
  let strcatn sTmpDownloadPath::file::".tmp"::nil -> tmpfile in
  (
    _storepack data tmpfile;
    let G2DloadAlphaBmp _channel tmpfile -> abmp in 
    if abmp == nil then nil else
	(
	    let _GETalphaBitmapSize abmp -> [w h] in
	    ( 
          let substr file 0 r -> s in
          let searchSlash s 0 -> poslastslash in
          let substr s poslastslash strlen s -> name in			  
          set linfoImages = [abmp name w h 0 0 nil 0 createMXWidget viewportstr name 0 0 1 1]::linfoImages
	    );
        if (i < fsize) then nil else 
		  let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [ScreenW ScreenH] in
		  let makeMatrix pictstr -> matrix in
		  showInfoImagesMatrix pictstr matrix 0 linfoImages [pictstr.PICT_iPosX pictstr.PICT_iPosY ScreenW ScreenH] viewportstr 
	);
  );;	
  
/*** web server dnload description file (images list) ***/
fun endDownloadFile(file, data, z)=
  if data == nil then nil else
  let z -> [pictstr viewportstr] in
  let lineextr data -> files in /*start dnload font files from list file readed before */
  let getFileDirectory pictstr.PICT_imgurl -> url in
  let 0 -> i in  
  let (sizelist files) -> fsize in
  while i < fsize do 
    let nth_list files i -> file in
    (
	 //_echo strcat "Download web images...............:" file
	 _fooS strcat "DnLoading web file:" file;
	 let strcat url file -> url in
	 downloadFile url mkfun3 @endDownloadImage [i fsize viewportstr pictstr];
     set i = i+1
	); 
	0;; 
	
/** scol server version **/   	
fun endDownloadImageS(file, data, x)=
  let strfind ".png" file 0 -> r in 
  let x -> [i fsize pictstr viewportstr] in
  let G2DloadAlphaBmp _channel file -> abmp in
  if abmp == nil then nil else
  (  
    let _GETalphaBitmapSize abmp -> [w h] in
    ( 
      let substr file 0 r -> s in
      let searchSlash s 0 -> poslastslash in
      let substr s poslastslash strlen s -> name in 	  
      set linfoImages = [abmp name w h 0 0 nil 0 createMXWidget viewportstr name 0 0 1 1]::linfoImages	
    );	
	if (i < fsize) then nil else 
	  let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [ScreenW ScreenH] in
	  let makeMatrix pictstr -> matrix in
	  showInfoImagesMatrix pictstr matrix 0 linfoImages [pictstr.PICT_iPosX pictstr.PICT_iPosY ScreenW ScreenH] viewportstr 
  );;		
  
fun downloadInfoImages(pictstr, param, files)=
  _fooS strcat "DnLoading: start" param;
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in  
  let 0 -> i in
  if (files!=nil) then
  (  
     _fooS "(SCOL Server)\n";
	 //_echo strcat "Download server fonts...............:" file
	 //_RSCdownload this file file mkfun3 @endDownloadImageS [i fsize pictstr viewportstr]; 
	 nil
  )
  else if pictstr.PICT_isimgurl then
  ( /* web server load */
    _fooS "(WEB Server)\n";
	let strcat pictstr.PICT_imgurl param -> webinfopath in
    downloadFile webinfopath mkfun3 @endDownloadFile [pictstr viewportstr];
	nil
  )
  else
  (
    /* local load */
	_fooS "(LOCAL)\n";
    let getFileDirectory pictstr.PICT_imgpath -> path in
	let strcat path param -> infopath in
    let getFilesFromDir infopath "png"::nil -> files in 
    let (sizelist files) -> fsize in
    while i < fsize do
      let nth_list files i -> file in
	  let strfind ".png" file 0 -> r in
	  let G2DloadAlphaBmp _channel file -> abmp in
      if (abmp == nil) then nil else
		let _GETalphaBitmapSize abmp -> [w h] in
        (   
		   _fooS strcat "DnLoading info images:" file;
           let substr file 0 r -> s in
           let searchSlash s 0 -> poslastslash in
           let substr s poslastslash strlen s -> name in
		   (
             set linfoImages = [abmp name w h 0 0 nil 0 createMXWidget viewportstr name 0 0 1 1]::linfoImages;	
             set i = i+1;
		     if (i < fsize) then nil else 
			   let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [ScreenW ScreenH] in
			   let makeMatrix pictstr -> matrix in
			   showInfoImagesMatrix pictstr matrix 0 linfoImages [pictstr.PICT_iPosX pictstr.PICT_iPosY ScreenW ScreenH] viewportstr  
		    )
        );
		//set pictstr.PICT_linfoImages = linfoImages;
		0
  );;	 
  
/********************************************************************/ 

fun deleteInfoImages(list, viewportstr) = 
  if list == nil then
    nil
  else 
    let hd list -> [abmp _ _ _ _ _ _ _ mxwidget] in
    (   
	  if (mxwidget==nil) then nil else
        SO3WidgetDestroy mxwidget;
	  
	  if (abmp==nil) then nil else
        _DSalphaBitmap abmp;
	  
	  mutate hd list <- [nil nil nil nil nil nil nil nil nil];
	  deleteInfoImages tl list viewportstr;
	  0
    );;	 
	
fun clearInfoImages(list, viewportstr) = 	
  deleteInfoImages list viewportstr;
  set linfoImages = nil;
  0;;

fun showInfoImages(inst, pictstr, param, files) =
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in
  if (param==nil) then
   nil
  else	   
   clearInfoImages linfoImages viewportstr; //init-delete previous info images
   downloadInfoImages pictstr param files; //(lineextr param); fethced file list from scol srv (old method) now an anchor name
   0;; 

//fun openUrl(param) = _openbrowserhttp param;;

fun clickInfoImages(inst, pictstr, images, b) = 
  let b -> [_ [xclick yclick bt]] in
  
  if images == nil then
    nil
  else  
  (  
    let hd images -> [_ name w h x y url inzone] in
	if (bt==1) && (inzone==1) && (xclick > x) && (xclick < x+w) && (yclick > y) && (yclick < y+h) then
	( 
 	  //let (_DMSgetName this) -> worldname in
	  let "world" -> worldname in
	  (
	    //_DMSevent this strcat class ".click" (strcatn worldname::"."::name::nil) nil;
		SendPluginEvent inst (strcat "click" name) nil nil;
        /*_openbrowserhttp strcatn url::"/"::worldname::"/"::name::"/"::nil;*/
	    0
	  )
	)	
    else
      nil;	

    clickInfoImages inst pictstr tl images b;
    0
  );;   

fun moveInfoImages(inst, images, o, b) = 
  let b -> [_ [xmove ymove _]] in
  
  if images == nil then
	nil
  else   
  (
    let hd images -> [_ name w h x y _ inzone _] in
	
    if (xmove > x) && (xmove < x+w) && (ymove > y) && (ymove < y+h) then 
      if !inzone then
      (
		mutate hd images <- [_ _ _ _ _ _ _ 1 _];
        //_DMSevent this "contextHelp" strbuild ("ref"::name::nil)::("userParam"::"1"::nil)::nil nil;
		SendPluginEvent inst "contextHelp" nil nil;
        //OB_TakeMouse o;
        //OB_TakeCursor o;
        //OB_SetCursor o HandCursor;
      )
      else
        nil
    else if inzone then
    (
      mutate hd images <- [_ _ _ _ _ _ _ 0 _];
      //_DMSevent this "contextHelp" nil nil;
	  SendPluginEvent inst "contextHelp" nil nil;
      //OB_ReleaseMouse o;
      //OB_ReleaseCursor o;
      //OB_SetCursor o StdCursor
    )		
    else
	  nil;	
	  
	//_SETfocus w3d.V3dwin; 
	moveInfoImages inst tl images o b;
  0);;	   
  
fun blitInfoImages(list) = 	
  if list == nil then
    nil
  else
  let hd list -> [abmp name w h x y _ _ mxwidget] in
  (   
    SO3WidgetSetPosition mxwidget x y;
    SO3WidgetSetSize mxwidget w h;
    SO3WidgetSetVisibility mxwidget 1;
    SO3BitmapWidgetBlitAlpha mxwidget abmp;
	
    blitInfoImages tl list;
	0
  );;     
   	  
fun resizeInfoImages(pictstr, rx, ry, dim) =
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in 
  clearInfoImages linfoImages viewportstr;
  0;;
  
fun hideInfoImages(pictstr, images) =
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in   
  clearInfoImages linfoImages viewportstr;
  0;;   


/***********************************************************************/

/**************......ANIM to be implemented into pre renders
// button animation is updated at 10 FPS
fun cbControlPreRenderAnim(inst, sessionstr, etime, pictstr)=
  let (set pictstr.PICT_iTick = pictstr.PICT_iTick + etime) -> rtick in
  if (rtick < (1000 / 10)) then nil else
  (
    set pictstr.PICT_iCurFrame = pictstr.PICT_iCurFrame + 1;
    
    if (pictstr.PICT_iCurFrame < (pictstr.PICT_iNbFrames - 1)) then nil else
      set pictstr.PICT_iCurFrame = 0;
    
    updateButton pictstr;
    set pictstr.PICT_iTick = 0;
  );
  0;;
*/

fun cbControlPreRenderShow(inst, sessionstr, etime, pictstr)=
  let (itof pictstr.PICT_iOpacity) /. (itof pictstr.PICT_iTransition) -> step in
  (
    set pictstr.PICT_fTransOpacity = pictstr.PICT_fTransOpacity +. (step *. (itof etime));
    if pictstr.PICT_fTransOpacity >=. (itof pictstr.PICT_iOpacity) then
    (
      SO3WidgetSetOpacity pictstr.PICT_win (itof pictstr.PICT_iOpacity) *. 0.01;
      setPluginInstanceCbScenePreRender inst nil;
      SendPluginEvent inst "Shown" nil nil;
      0;
    )
    else
    (
      SO3WidgetSetOpacity pictstr.PICT_win (pictstr.PICT_fTransOpacity *. 0.01);
      0;
    );
  );
  0;;


fun cbControlPreRenderHide(inst, sessionstr, etime, pictstr)=
  let (itof pictstr.PICT_iOpacity) /. (itof pictstr.PICT_iTransition) -> step in
  (
    set pictstr.PICT_fTransOpacity = pictstr.PICT_fTransOpacity -. (step *. (itof etime));
    if pictstr.PICT_fTransOpacity <=. 0.0 then
    (
      SO3WidgetSetOpacity pictstr.PICT_win 0.0;
      setPluginInstanceCbScenePreRender inst nil;
      SO3WidgetSetVisibility pictstr.PICT_win 0;
      SendPluginEvent inst "Hidden" nil nil;
      0;
    )
    else
    (
      SO3WidgetSetOpacity pictstr.PICT_win (pictstr.PICT_fTransOpacity *. 0.01);
      0;
    );
  );
  0;;


fun cbShow(inst, from, action, param, reply, pictstr)=
  if (pictstr.PICT_iTransition == 0) then
  (
    SO3WidgetSetVisibility pictstr.PICT_win 1;
	
	showInfoImages inst pictstr nil nil;
    
    //force render update (used for loading screens)
    let V3DgetSessionView c3dXsession -> viewstr in
      SO3BufferUpdate viewstr.V3D_buffer;
    
    SendPluginEvent inst "Shown" nil nil;
    0;
  )
  else
  (
    SO3WidgetSetOpacity pictstr.PICT_win (pictstr.PICT_fTransOpacity *. 0.01);
    SO3WidgetSetVisibility pictstr.PICT_win 1;
    setPluginInstanceCbScenePreRender inst mkfun4 @cbControlPreRenderShow pictstr;
    0;
  );
  
  set pictstr.PICT_bShow = 1;
  0;;


fun cbHide(inst, from, action, param, reply, pictstr)=
  if (pictstr.PICT_iTransition == 0) then
  (
    SO3WidgetSetVisibility pictstr.PICT_win 0;
	
	hideInfoImages pictstr linfoImages; 
    
    //force render update (used for loading screens)
    //let V3DgetSessionView c3dXsession -> viewstr in
      //SO3BufferUpdate viewstr.V3D_buffer;
    SendPluginEvent inst "Hidden" nil nil;
    0;
  )
  else
  (
    SO3WidgetSetOpacity pictstr.PICT_win (pictstr.PICT_fTransOpacity *. 0.01);
    setPluginInstanceCbScenePreRender inst mkfun4 @cbControlPreRenderHide pictstr;
    0;
  );
  
  set pictstr.PICT_bShow = 0;
  0;;


fun cbResizeCtrl(inst, viewstr, vw, vh, pictstr)=
  if pictstr.PICT_win == nil then nil else
  let computePosSize pictstr vw vh -> [px py pw ph] in
  (
    SO3WidgetSetPosition pictstr.PICT_win px py;
    SO3WidgetSetSize pictstr.PICT_win pw ph;
    SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaBuffer;
	
	resizeInfoImages pictstr vw vh [px py pw ph];
	blitInfoImages linfoImages;
	//_fooS strcat "blitBlt info images :" "resize\n";
  );
  0;;
  
  
fun cbControlPreRenderBlitInfoMatrix(inst, sessionstr, etime, pictstr) = 
  blitInfoImages linfoImages;
  //_fooS strcat "blitBlt info images:" "PreRender\n";
  0;;  
  
fun cb3dClick(inst, viewstr, x, y, b, pictstr)= 
  setPluginInstanceCbScenePreRender inst mkfun4 @cbControlPreRenderBlitInfoMatrix pictstr;
  0;; 

fun cb3dDbClick(inst, viewstr, x, y, b, pictstr)= 
  setPluginInstanceCbScenePreRender inst mkfun4 @cbControlPreRenderBlitInfoMatrix pictstr;
  0;;
  
  
  
/** Mouse *************************************************************************/  


fun cbSendLeftClick(inst, from, action, param, reply, pictstr)=
  if (!pictstr.PICT_bShow) then nil else
    SendPluginEvent pictstr.PICT_instance "LeftClick" nil nil;
  0;;


fun cbSendRightClick(inst, from, action, param, reply, pictstr)=
  if (!pictstr.PICT_bShow) then nil else
    SendPluginEvent pictstr.PICT_instance "RightClick" nil nil;
  0;;


fun cbSendMiddleClick(inst, from, action, param, reply, pictstr)=
  if (!pictstr.PICT_bShow) then nil else
    SendPluginEvent pictstr.PICT_instance "MiddleClick" nil nil;
  0;;


fun cbSetState(inst, from, action, param, reply, pictstr)=
  let strtrim param -> param in
  if (!strcmpi param "Active") || ((atoi param) == 1) then
  (
    // active state
    set pictstr.PICT_iState = 0;
    
    if(pictstr.PICT_iAvStates <= 0) then nil else
    //update bitmap
    (
      updateButton pictstr;
      0;
    );
    0;
  )
  else if (!strcmpi param "Hover") || ((atoi param) == 2) then
  (
    // hover state
    set pictstr.PICT_iState = 1;
    
    if(pictstr.PICT_iAvStates <= 0) then nil else
    //update bitmap
    (
      updateButton pictstr;
      0;
    );
    0;
  )
  else if (!strcmpi param "Down") || ((atoi param) == 3) then
  (
    // hover state
    set pictstr.PICT_iState = 2;
    
    if(pictstr.PICT_iAvStates <= 0) then nil else
    //update bitmap
    (
      updateButton pictstr;
      0;
    );
    0;
  )
  else if (!strcmpi param "Disable") || ((atoi param) == 4) then
  (
    // disable state
    set pictstr.PICT_iState = 3;
    
    if(pictstr.PICT_iAvStates <= 1) then nil else
    //update bitmap
    (
      updateButton pictstr;
      0;
    );
    0;
  )
  else nil;
  0;;
  
// multi touch
fun cbAddCursor(inst, viewstr, id, sx, sy, pictstr)=
  if (!pictstr.PICT_bShow) || (pictstr.PICT_win == nil) then nil else
  (
    if (pictstr.PICT_trmMouseState == nil) then nil else
    (
      _deltimer pictstr.PICT_trmMouseState;
      set pictstr.PICT_trmMouseState = nil;
    );
    
    //disable mouse
    SO3WidgetEnterEventCb pictstr.PICT_win nil nil;
    SO3WidgetExitEventCb pictstr.PICT_win nil nil;
    SO3WidgetMouseDownEventCb pictstr.PICT_win nil nil;
    SO3WidgetMouseUpEventCb pictstr.PICT_win nil nil;
    SO3WidgetMouseMoveEventCb pictstr.PICT_win nil nil;
    SO3WidgetFocusEventCb pictstr.PICT_win @cbFocused nil;
    set pictstr.PICT_iClick = 0;
    
    let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in
    let SO3ViewportGetPixelPositionSize viewportstr.V3D_viewport -> [_ _ vw vh] in
    let computePosSize pictstr vw vh -> [px py pw ph] in
    (
      if ((sx > px) && (sx < (px + pw)) && (sy > py) && (sy < (py + ph))) then
      let switchstr pictstr.PICT_lInputs (itoa id) -> icontrol in
      (
        // if not already int the list we add it
        if (icontrol == nil) then
        (
          set pictstr.PICT_lInputs = [(itoa id) [sx sy]]::pictstr.PICT_lInputs;
          0;
        )
        else
        (
          mutate icontrol <- [sx sy];
          0;
        );
        
        if (pictstr.PICT_iState == 3) || (pictstr.PICT_iState == 2) then nil else
        (
          set pictstr.PICT_iState = 1;
          //update bitmap
          if(pictstr.PICT_iAvStates <= 0) then nil else
          (
            updateButton pictstr;
            0;
          );
          SendPluginEvent pictstr.PICT_instance "MouseOver" nil nil;
          
          set pictstr.PICT_iState = 2;      
          //update bitmap
          if(pictstr.PICT_iAvStates <= 1) then nil else
          (
            updateButton pictstr;
            0;
          );
          SendPluginEvent pictstr.PICT_instance "Pushed" nil nil;
          set pictstr.PICT_tLastPos = [sx sy];
        );
      )
      else nil;
    );
  );
  0;;


fun cbUpdateCursor(inst, viewstr, id, sx, sy, vx, vy, pictstr)=
  if (!pictstr.PICT_bShow) || (pictstr.PICT_win == nil) then nil else
  (
    let switchstr pictstr.PICT_lInputs (itoa id) -> icontrol in
    if (icontrol == nil) || (pictstr.PICT_tLastPos == nil) then nil else
    (
      let icontrol -> [ppx ppy] in
      if ((ppx == sx) && (ppy == sy)) then nil else
      (
        mutate icontrol <- [sx sy];
        
        let pictstr.PICT_tLastPos -> [px py] in
        let (min pictstr.PICT_iWidth pictstr.PICT_iHeight) -> msize in
        let (itof (sx - px)) /. (itof msize) -> fx in
        let if (fx >. 1.0) then 1.0 else if (fx <. (-.1.0)) then (-.1.0) else fx -> fx in
        let (itof (py - sy)) /. (itof msize) -> fy in
        let if (fy >. 1.0) then 1.0 else if (fy <. (-.1.0)) then (-.1.0) else fy -> fy in
          SendPluginEvent pictstr.PICT_instance "Pushed move" strcatn (ftoa fx)::" "::(ftoa fy)::nil nil;
       );
    );
  );
  
  /*
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in
  let SO3ViewportGetPixelPositionSize viewportstr.V3D_viewport -> [_ _ vw vh] in
  let computePosSize pictstr vw vh -> [px py pw ph] in
  (
    let switchstr pictstr.PICT_lInputs (itoa id) -> icontrol in
    if (icontrol == nil) then nil else
    if ((sx > px) && (sx < (px + pw)) && (sy > py) && (sy < (py + ph))) then
    (
      mutate icontrol <- [sx sy];
      
      if (pictstr.PICT_iState == 3) || (pictstr.PICT_iState == 2) then nil else
      (
        set pictstr.PICT_iState = 1;
        //update bitmap
        if(pictstr.PICT_iAvStates <= 0) then nil else
        (
          updateButton pictstr;
          0;
        );
        SendPluginEvent pictstr.PICT_instance "MouseOver" nil nil;
       
        set pictstr.PICT_iState = 2;
        //update bitmap
        if(pictstr.PICT_iAvStates <= 1) then nil else
        (
          updateButton pictstr;
          0;
        );
        SendPluginEvent pictstr.PICT_instance "Pushed" nil nil;
      );
    )
    else
    (
      mutate icontrol <- [sx sy];
            
      let sizelist pictstr.PICT_lInputs -> size in
      let 0 -> i in
      let 0 -> over in
      (
        while (i < size) do
        (
          let nth_list pictstr.PICT_lInputs i -> [n [sx sy]] in
          if ((sx > px) && (sx < (px + pw)) && (sy > py) && (sy < (py + ph))) then
            set over = 1
          else nil;
          
          set i = i + 1;
        );
      
        if (over == 1) then nil else
        (
          if(pictstr.PICT_iState == 3) || (pictstr.PICT_iState == 0) then nil else
          (
            set pictstr.PICT_iState = 0;
            //update bitmap     
            if(pictstr.PICT_iAvStates <= 0) then nil else
            (
              updateButton pictstr;
              0;
            );
            
            SendPluginEvent pictstr.PICT_instance "Released" nil nil;
            SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
          );
        );
      );
    );
  );*/
  0;;


fun cbResetMouse(trm, pictstr)=
  _deltimer trm;
  set pictstr.PICT_trmMouseState = nil;
  
  SO3WidgetEnterEventCb pictstr.PICT_win @cbMouseIn pictstr;
  SO3WidgetExitEventCb pictstr.PICT_win @cbMouseOut pictstr;
  SO3WidgetMouseDownEventCb pictstr.PICT_win @cbClick pictstr;
  SO3WidgetMouseUpEventCb pictstr.PICT_win @cbUnClick pictstr;
  SO3WidgetMouseMoveEventCb pictstr.PICT_win @cbMouseMove pictstr;
  SO3WidgetFocusEventCb pictstr.PICT_win @cbFocused pictstr;
  0;;  
  
fun cbRemoveCursor(inst, viewstr, id, pictstr)=
  let switchstr pictstr.PICT_lInputs (itoa id) -> icontrol in
  if (icontrol == nil) then nil else
  let icontrol -> [sx sy] in
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in
  let SO3ViewportGetPixelPositionSize viewportstr.V3D_viewport -> [_ _ vw vh] in
  let computePosSize pictstr vw vh -> [px py pw ph] in
  (
    let sizelist pictstr.PICT_lInputs -> size in
    let 0 -> i in
    let 0 -> over in
    (
      while (i < size) do
      (
        let nth_list pictstr.PICT_lInputs i -> [n [sx sy]] in
        if ((sx > px) && (sx < (px + pw)) && (sy > py) && (sy < (py + ph)) && (id != (atoi n))) then
          set over = 1
        else nil;
        
        set i = i + 1;
      );
    
      if (over == 1) then nil else
      (
        if (pictstr.PICT_iState == 3) || (pictstr.PICT_iState == 0) then nil else
        (
          set pictstr.PICT_iState = 0;          
          if(pictstr.PICT_iAvStates <= 0) then nil else
          //update bitmap
          (
            updateButton pictstr;
            0;
          );
          SendPluginEvent pictstr.PICT_instance "Released" nil nil;
          SendPluginEvent pictstr.PICT_instance "MouseOut" nil nil;
          
          if ((sx > px) && (sx < (px + pw)) && (sy > py) && (sy < (py + ph))) then
            SendPluginEvent pictstr.PICT_instance "LeftClick" nil nil
          else nil;
          
          set pictstr.PICT_tLastPos = nil;
        );
      );
    );
  );
  
  set pictstr.PICT_lInputs = remove_sid_from_list pictstr.PICT_lInputs (itoa id);

  //enable mouse again
  if ((sizelist pictstr.PICT_lInputs) > 0) then nil else
  (
    set pictstr.PICT_trmMouseState = _rfltimer _starttimer _channel 500 @cbResetMouse pictstr;
  );
  0;;  
  
/*************************************************************************************/  
  

fun createPicture(inst, pictstr)=
  let (V3DgetDefaultViewport (V3DgetSessionView c3dXsession)) -> viewportstr in
  if pictstr.PICT_win != nil then nil else
  (
    V3DremoveWidgetControl viewportstr pictstr.PICT_win;
    SO3WidgetDestroy pictstr.PICT_win;
    (
      let SO3ViewportGetPixelPositionSize viewportstr.V3D_viewport -> [_ _ vw vh] in
      let computePosSize pictstr vw vh -> [px py pw ph] in
        set pictstr.PICT_win = SO3BitmapWidgetCreate (V3DgetSession c3dXsession) viewportstr.V3D_viewport (strcat (getPluginInstanceName inst) "_pictureCtrl") px py pw ph 100;

      SO3WidgetSetTopOnFocus pictstr.PICT_win 0;
      SO3WidgetSetForeground pictstr.PICT_win 1;
      0;
    );
	
    SO3WidgetEnterEventCb pictstr.PICT_win @cbMouseIn pictstr;
    SO3WidgetExitEventCb pictstr.PICT_win @cbMouseOut pictstr;
    SO3WidgetMouseDownEventCb pictstr.PICT_win @cbClick pictstr;
    SO3WidgetMouseUpEventCb pictstr.PICT_win @cbUnClick pictstr;
    SO3WidgetMouseMoveEventCb pictstr.PICT_win @cbMouseMove pictstr;
    SO3WidgetFocusEventCb pictstr.PICT_win @cbFocused pictstr;	
    
    V3DaddWidgetControl viewportstr pictstr.PICT_win;
    SO3WidgetSetKeyboardEnable pictstr.PICT_win 0;
    SO3WidgetSetMouseEnable pictstr.PICT_win 0;
    SO3WidgetSetTransparency pictstr.PICT_win pictstr.PICT_bTransparency;
    SO3WidgetSetOpacity pictstr.PICT_win (itof pictstr.PICT_iOpacity) *. 0.01;
    SO3WidgetSetVisibility pictstr.PICT_win 0;
  );
  0;;


fun cbDownloaded(file, data, pictstr)=
  if data == nil then nil else
  let strcatn sTmpDownloadPath::(getPluginInstanceName pictstr.PICT_instance)::".tmp"::nil -> tmpfile in
  (
    _storepack data tmpfile;
    let G2DloadAlphaBmp _channel tmpfile -> bmp in
    if bmp == nil then nil else
    (
      _DSalphaBitmap pictstr.PICT_AlphaBuffer;
      set pictstr.PICT_AlphaBuffer = bmp;
      
      SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaBuffer;
    );
  );
  0;;


fun cbSetPosition(inst, from, action, param, reply, pictstr)=
if param == nil then nil else
  let strextr param -> lp in
  let (nth_list (hd lp) 0) -> sx in
  let (nth_list (hd lp) 1) -> sy in
  let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [vw vh] in
  (
    let 0 -> xpercent in
    let if (!strcmp "%" (substr sx ((strlen sx) - 1) 1)) then
        (
          set xpercent = 1;
          atoi sx;
        )
        else
          atoi sx
    -> px in
    let 0 -> ypercent in
    let if (!strcmp "%" (substr sy ((strlen sy) - 1) 1)) then
        (
          set ypercent = 1;
          atoi sy;
        )
        else
          atoi sy
    -> py in
    let [(if px == nil then 0 else px) (if py == nil then 0 else py)] -> [px py] in
    (
      mutate pictstr.PICT_tPercent <- [xpercent ypercent _ _ _ _ _ _];
      set pictstr.PICT_iPosX = px;
      set pictstr.PICT_iPosY = py;
      
      let computePosSize pictstr vw vh -> [px py pw ph] in
      (
        SO3WidgetSetPosition pictstr.PICT_win px py;
        SO3WidgetSetSize pictstr.PICT_win pw ph;
      );
    );
  );
  0;;


fun cbSetSize(inst, from, action, param, reply, pictstr)=
  if param == nil then nil else
  let strextr param -> lp in
  let (nth_list (hd lp) 0) -> sx in
  let (nth_list (hd lp) 1) -> sy in
  let V3DgetViewSize (V3DgetSessionView c3dXsession) -> [vw vh] in
  (
    let 0 -> wpercent in
    let if (!strcmp "%" (substr sx ((strlen sx) - 1) 1)) then
        (
          set wpercent = 1;
          atoi sx;
        )
        else
          atoi sx
    -> px in
    let 0 -> hpercent in
    let if (!strcmp "%" (substr sy ((strlen sy) - 1) 1)) then
        (
          set hpercent = 1;
          atoi sy;
        )
        else
          atoi sy
    -> py in
    let [(if px == nil then 0 else px) (if py == nil then 0 else py)] -> [px py] in
    (
      mutate pictstr.PICT_tPercent <- [_ _ wpercent hpercent _ _ _ _];
      set pictstr.PICT_iWidth = px;
      set pictstr.PICT_iHeight = py;
      
      let computePosSize pictstr vw vh -> [px py pw ph] in
      (
        SO3WidgetSetPosition pictstr.PICT_win px py;
        SO3WidgetSetSize pictstr.PICT_win pw ph;
      );
    );
  );
  0;;


fun cbSetOpacity(inst, from, action, param, reply, pictstr)=
  if (param == nil) || (!strcmp "" strtrim param) || ((atoi param) == nil) then nil else
  let atoi param -> opacity in
  (
    set pictstr.PICT_iOpacity = opacity;
    SO3WidgetSetOpacity pictstr.PICT_win (itof pictstr.PICT_iOpacity) *. 0.01;
  );
  0;;


fun cbChangeData(inst, from, action, param, reply, pictstr)=
  if (param == nil) then nil else
  let !strcmpi (substr param 0 1) "Z" -> iszip in
  let (strfindi "_" param 2) -> fp in
  let atoi (substr param 2 fp - 2) -> width in
  let (strfind "_" param fp + 1) -> fp2 in
  let atoi (substr param (fp + 1) (fp2 - fp - 1)) -> height in
  let if !iszip then substr param (fp2 + 1) (strlen param) else unzip substr param (fp2 + 1) (strlen param) -> data in
  let G2DconvertBmpToAlphaBmp _channel (_BTUnCompBitmap data (_FILLbitmap _CRbitmap _channel width height 0)) -> bmp in
  if bmp == nil then nil else
  (
    _DSalphaBitmap pictstr.PICT_AlphaBuffer;
    set pictstr.PICT_AlphaBuffer = bmp;
    
    SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaBuffer;
	
	//blitInfoImages infoImages;
	//_fooS strcat "blitBlt info images:" "changed data\n";
  );
  0;;


fun cbChange(inst, from, action, param, reply, pictstr)=
  let if param == nil then pictstr.PICT_bUrl else strIsUrl param -> isurl in
  let if param == nil then pictstr.PICT_sPath else param -> url in
  if !isurl then
  (
    let G2DloadAlphaBmp _channel url -> bmp in
    if bmp == nil then nil else
    (
      _DSalphaBitmap pictstr.PICT_AlphaBuffer;
      set pictstr.PICT_AlphaBuffer = bmp;
      
      SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaBuffer;
	  
	  //blitInfoImages infoImages;
	  //_fooS strcat "blitBlt info Images:" "change\n";
    );
    0;
  )
  else
  (
    if (pictstr.PICT_httpReq == nil) then nil else
    (
      killHttpRequest pictstr.PICT_httpReq;
      set pictstr.PICT_httpReq = nil;
    );
      
    set pictstr.PICT_httpReq = downloadFile url mkfun3 @cbDownloaded pictstr;
    0;
  );
  0;;
  
fun cbObClicked(inst, from, action, param, reply, pictstr) = 
  showInfoImages inst pictstr param nil;
  0;;

fun cbOpenUrl(inst, from, action, param, reply, pictstr) = 0;;    //<<<<<<<<<<<<<<<<<<<<<<<<  


// Destroy instance
fun deleteOb(inst, pictstr)=
  setPluginInstanceCbScenePreRender inst nil;
  if (pictstr.PICT_httpReq == nil) then nil else
  (
    killHttpRequest pictstr.PICT_httpReq;
    set pictstr.PICT_httpReq = nil;
  );
  0;;
  
  

fun cbNewOb(inst)=
  let (getPluginInstanceParam inst "object") -> objname in
  let (getPluginInstanceParam inst "material") -> matname in
  let atoi (getPluginInstanceParam inst "technique") -> technique in
  let if (technique == nil) || (technique < 0) then 0 else technique -> technique in
  let atoi (getPluginInstanceParam inst "pass") -> pass in
  let if (pass == nil) || (pass < 0) then 0 else pass -> pass in
  let atoi (getPluginInstanceParam inst "texture") -> texture in
  let if (texture == nil) || (texture < 0) then 0 else texture -> texture in
  let atoi (getPluginInstanceParam inst "isrightalign") -> isrightalign in
  let if isrightalign == nil then 0 else isrightalign -> isrightalign in
  
  let (getPluginInstanceParam inst "path") -> path in
  let atoi (getPluginInstanceParam inst "isurl") -> isurl in
  let if isurl == nil then 0 else isurl -> isurl in
  let (getPluginInstanceParam inst "url") -> url in   

  let atoi (getPluginInstanceParam inst "btnstates") -> btnstates in
  let if btnstates == nil then 0 else btnstates -> btnstates in
  let atoi (getPluginInstanceParam inst "nbframes") -> nbframes in
  let if (nbframes == nil) || (nbframes < 1) then 1 else nbframes -> nbframes in  
  
  let (getPluginInstanceParam inst "imgpath") -> imgpath in
  let atoi (getPluginInstanceParam inst "isimgurl") -> isimgurl in
  let if isimgurl == nil then 0 else isimgurl -> isimgurl in
  let (getPluginInstanceParam inst "imgurl") -> imgurl in    

  let (getPluginInstanceParam inst "fontpath") -> fontpath in
  let atoi (getPluginInstanceParam inst "isfonturl") -> isfonturl in
  let if isfonturl == nil then 0 else isfonturl -> isfonturl in
  let (getPluginInstanceParam inst "fonturl") -> fonturl in      
  
  let atoi (getPluginInstanceParam inst "xpercent") -> xpercent in
  let if xpercent == nil then 0 else xpercent -> xpercent in
  let atoi (getPluginInstanceParam inst "xalign") -> xalign in
  let if xalign == nil then 0 else xalign -> xalign in
  let atoi (getPluginInstanceParam inst "posx") -> posx in
  let if posx == nil then 0 else posx -> posx in
  let atoi (getPluginInstanceParam inst "ypercent") -> ypercent in
  let if ypercent == nil then 0 else ypercent -> ypercent in
  let atoi (getPluginInstanceParam inst "yalign") -> yalign in
  let if yalign == nil then 0 else yalign -> yalign in
  let atoi (getPluginInstanceParam inst "posy") -> posy in
  let if posy == nil then 0 else posy -> posy in
  let atoi (getPluginInstanceParam inst "wpercent") -> wpercent in
  let if wpercent == nil then 1 else wpercent -> wpercent in
  let atoi (getPluginInstanceParam inst "width") -> width in
  let if width == nil then 100 else width -> width in
  let atoi (getPluginInstanceParam inst "hpercent") -> hpercent in
  let if hpercent == nil then 1 else hpercent -> hpercent in
  let atoi (getPluginInstanceParam inst "xoffset") -> xoffset in
  let if xoffset == nil then 0 else xoffset -> xoffset in
  let atoi (getPluginInstanceParam inst "yoffset") -> yoffset in
  let if yoffset == nil then 0 else yoffset -> yoffset in
  let atoi (getPluginInstanceParam inst "woffset") -> woffset in
  let if woffset == nil then 0 else woffset -> woffset in
  let atoi (getPluginInstanceParam inst "hoffset") -> hoffset in
  let if hoffset == nil then 0 else hoffset -> hoffset in
  let atoi (getPluginInstanceParam inst "height") -> height in
  let if height == nil then 100 else height -> height in
  
  let atoi (getPluginInstanceParam inst "background") -> background in
  let if (background == nil) then 1 else background -> background in
  
  let atoi (getPluginInstanceParam inst "opacity") -> opacity in
  let if opacity == nil then 100 else opacity -> opacity in
  let atoi (getPluginInstanceParam inst "transition") -> transition in
  let if transition == nil then 0 else transition -> transition in
    
  let atoi (getPluginInstanceParam inst "transparency") -> trans in
  let if (trans == nil) then 0 else trans -> trans in
  
  let atoi (getPluginInstanceParam inst "enablemouse") -> enablemouse in
  let if enablemouse == nil then 1 else enablemouse -> enablemouse in
  
  let atoi (getPluginInstanceParam inst "cursor") -> cursor in
  let if cursor == nil then 1 else cursor -> cursor in  
  
  let atoi (getPluginInstanceParam inst "show") -> show in
  let if (show == nil) then 1 else show -> show in
  let if !isurl then path else url -> file in

  let SO3SceneGetObject (V3DgetSession c3dXsession) objname -> obj in
  //let if !istexture then nil else SO3SceneGetMaterial (V3DgetSession c3dXsession) (SO3EntityGetResourceGroup obj) matname -> mat in
  let MkPlugPicture [inst isrightalign 2 10 90 "" nil nil posx posy width height [xpercent ypercent wpercent hpercent xoffset yoffset woffset hoffset] [xalign yalign] trans opacity transition 0.0 isurl file background show nil imgpath isimgurl imgurl nil 0 0 cursor enablemouse btnstates 0 nbframes 0 0 0 nil nil nil ] -> pictstr in
  (
    createPicture inst pictstr;
	//_fooS "Start";
	
	SendPluginEvent inst "startLoad" nil nil;
    showInfoImages inst pictstr nil nil;		
    
      setPluginInstanceCbResizeView inst mkfun5 @cbResizeCtrl pictstr;
	  setPluginInstanceCbClick inst mkfun6 @cb3dClick pictstr;         /*add click callback */
	  //setPluginInstanceCbDbClick inst mkfun6 @cb3dDbClick pictstr;     /*add db click callback */
    
      if !pictstr.PICT_bUrl then
      (
        let G2DloadAlphaBmp _channel pictstr.PICT_sPath -> bmp in
        if bmp == nil then nil else
        (
          set pictstr.PICT_AlphaBuffer = bmp;
          
          SO3BitmapWidgetBlitAlpha pictstr.PICT_win pictstr.PICT_AlphaBuffer;
		  
		  //blitInfoImages linfoImages; 
		  //_fooS strcat "blitBlt info Images:" "init\n";
        );
        0;
      )
      else
      (
        set pictstr.PICT_httpReq = downloadFile pictstr.PICT_sPath mkfun3 @cbDownloaded pictstr;
        0;
      );
    
    if pictstr.PICT_bShow then
      cbShow inst nil nil nil nil pictstr
    else
      cbHide inst nil nil nil nil pictstr;
    
    PluginRegisterAction inst "Show" mkfun6 @cbShow pictstr;
    PluginRegisterAction inst "Hide" mkfun6 @cbHide pictstr;
    PluginRegisterAction inst "Change" mkfun6 @cbChange pictstr;
    PluginRegisterAction inst "Change data" mkfun6 @cbChangeData pictstr;
    PluginRegisterAction inst "Set position" mkfun6 @cbSetPosition pictstr;
    PluginRegisterAction inst "Set size" mkfun6 @cbSetSize pictstr;
    PluginRegisterAction inst "Set opacity" mkfun6 @cbSetOpacity pictstr;
	
    PluginRegisterAction inst "Set state" mkfun6 @cbSetState pictstr;
    PluginRegisterAction inst "Send left click" mkfun6 @cbSendLeftClick pictstr;
    PluginRegisterAction inst "Send right click" mkfun6 @cbSendRightClick pictstr;
    PluginRegisterAction inst "Send middle click" mkfun6 @cbSendMiddleClick pictstr;	
	
    setPluginInstanceCbTouchPointAdd inst mkfun6 @cbAddCursor pictstr;
    setPluginInstanceCbTouchPointRemove inst mkfun4 @cbRemoveCursor pictstr;
    setPluginInstanceCbTouchPointUpdate inst mkfun8 @cbUpdateCursor pictstr;
	
	PluginRegisterAction inst "ObClicked" mkfun6 @cbObClicked pictstr;	
	PluginRegisterAction inst "openUrl" mkfun6 @cbOpenUrl pictstr;	
	
  	setPluginInstanceCbDel inst mkfun2 @deleteOb pictstr;   
	
	SendPluginEvent inst "endLoad" nil nil;
	
	SendPluginEvent inst "started" nil nil;
  );
  0;;


fun IniPlug(file) =
  set sHandCursor = strcat APPBASEDIR sHandCursor;
  let _LDbitmap _channel _checkpack sHandCursor -> bmpcursor in
  let _CRcursor _channel bmpcursor 12 6 0x000000 0xffffff -> cursor in
  (
    _DSbitmap bmpcursor;
    set cHandCursor = cursor;
  );
  
  PlugRegister @cbNewOb nil;
  setPluginEditor @dynamicedit;
  0;;