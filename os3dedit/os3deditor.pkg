/*
-----------------------------------------------------------------------------
This source file is part of OpenSpace3D
For the latest info, see http://www.openspace3d.com

Copyright (c) 2012 I-maginer

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA, or go to
http://www.gnu.org/copyleft/lesser.txt

-----------------------------------------------------------------------------
*/

/**************************************************
 OpenSpace 3D Editor
 Version: 0.1a
 Author: Bastien BOURINEAU / I-maginer
 First update: 02.04.2009

**************************************************/

/* ********************************************************************************************* /
  TODO
    - list of materials
    - Node animation editor    
      
    DEBUG SO3 ENGINE
    
    - object render priority
    - too much texture count crash on shadow texture
    
    - fullscreen on dual screen
    
/ ********************************************************************************************* */

proto loadOsGroup = fun [V3Dview Group XMLmark XMLmark SO3_OBJECT EdTreeItem I I] I;;
proto cbRewriteProgramFileAndLoad = fun [MessageBox [S XMLmark] I V3Dview] I;;
proto cbRewriteMaterialFileAndLoad = fun [MessageBox [S XMLmark] I V3Dview] I;;
proto playEditor = fun [V3Dview I] I;;
proto cbView3dClick = fun [V3Dview I I I] I;;
proto cbView3dUnClick = fun [V3Dview I I I] I;;

var bEnableHistoryState = 1;;

/* ********************************************************************************************* /
  Os scene manager
/ ********************************************************************************************* */
fun getGraphByValue(val)=
  let if (!strcmp val "Ogre/SceneRoot") || (val == nil) then "Scene" else val -> val in
    switchstri lSceneGraph val;;


fun getNewSceneIndex(id)=
  if id == nil then
    set iCurSceneIdx = iCurSceneIdx + 1
  else
  (
    set iCurSceneIdx = (if id > iCurSceneIdx then id else iCurSceneIdx);
    id;
  );;


fun getGraphItemsByType(ftype)=
  let nil -> nl in
  (
    let sizelist lSceneGraph -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lSceneGraph i -> elt in
      let elt -> [val [treenode type alias markstr path destgroup initstate staticgeometry]] in
      if ftype != type then nil else
        set nl = elt::nl;
      
      set i = i + 1;
    );
    nl;
  );;


fun setGraphItemInitState(val, state)=
  let getGraphByValue val -> params in
    mutate params <- [_ _ _ _ _ _ state _];
  0;;


fun setGraphItemStaticGeometryState(val, state)=
  let getGraphByValue val -> params in
    mutate params <- [_ _ _ _ _ _ _ state];
  0;;


fun setGraphItemAlias(val, alias)=
  let getGraphByValue val -> params in
    mutate params <- [_ _ alias _ _ _ _ _];
  0;;


fun addGraphItem(name, val, type, alias, markstr, path, destgroup, tbitmap, treefather, initstate, staticgeometry)=
  let addEdCtrlTreeItem ctrlSceneTree treefather if (alias == nil) || (!strcmp alias "") then name else strcatn alias::" ("::name::")"::nil val type tbitmap -> treenode in
  (
    if (treenode != nil) then nil else
      addLogMessage "Tree item creation failed !!!!!";
    set lSceneGraph = [val [treenode type alias markstr path destgroup initstate staticgeometry]]::lSceneGraph;
    treenode;
  );;


fun delGraphItem(name)=
  if name == nil then nil else
  set lSceneGraph = G2DremoveEdSidFromList lSceneGraph name;;


// test if the scene has been modified | new or not
fun isSceneModified()=
  setInfoMessage "Check scene for modification...";
  let XMLdiff xmlEditSceneFile if sCurrentScenePath == nil then xmlBaseScene else (XMLload sCurrentScenePath) -> ret in
  (
    setInfoMessage if ret then "Scene have been changed." else "No change on scene.";  
    ret;
  );;


fun getAllMaterialScheme(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let nil -> lscheme in
  (
    let sizelist lGroups -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lGroups i -> [_ grp] in
      let SO3SceneParseSchemeFromGroup (V3DgetSession sessionstr) grp.GRP_sName -> lsch in
        set lscheme = lcat lscheme lsch;
      
      set i = i + 1;
    );
    
    quicksort lscheme @suppDoublon;
  );;


fun storeResourceFile(groupstr, file)=
  let getFileResourceType file -> type in
  if type == SO3_RESOURCE_MATERIAL then
    set groupstr.GRP_lMaterialResources = addUniqueStri groupstr.GRP_lMaterialResources file
  else if type == SO3_RESOURCE_GPUPROGRAM then
    set groupstr.GRP_lProgramResources = addUniqueStri groupstr.GRP_lProgramResources file
  else if type == SO3_RESOURCE_HIGHLEVELGPUPROGRAM then
    set groupstr.GRP_lShaderResources = addUniqueStri groupstr.GRP_lShaderResources file
  else if type == SO3_RESOURCE_TEXTURE then
    set groupstr.GRP_lTextureResources = addUniqueStri groupstr.GRP_lTextureResources file
  else if type == SO3_RESOURCE_COMPOSITOR then
    set groupstr.GRP_lCompositorResources = addUniqueStri groupstr.GRP_lCompositorResources file
  else if type == SO3_RESOURCE_PARTICLE_SYSTEM then
    set groupstr.GRP_lParticleResources = addUniqueStri groupstr.GRP_lParticleResources file
  else if type == SO3_RESOURCE_SKELETON then
    set groupstr.GRP_lSkeletonResources = addUniqueStri groupstr.GRP_lSkeletonResources file
  else if type == SO3_RESOURCE_MESH then
    set groupstr.GRP_lMeshResources = addUniqueStri groupstr.GRP_lMeshResources file
  else
    set groupstr.GRP_lOtherResources = addUniqueStri groupstr.GRP_lOtherResources file;
  0;;


fun newOsSceneFile(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLcreate nil nil -> xmlfilestr in
  let XMLaddMark xmlfilestr "project" nil ["formatVersion" getVersionName]::["author" "OpenSpace 3D Objects group based on OgreMax Scene Exporter (www.ogremax.com)"]::nil nil -> projstr in
  
  let XMLaddMark xmlfilestr "scene" projstr ["px" "3"]::["py" "1"]::nil nil -> scenestr in
  let XMLaddMark xmlfilestr "resources" scenestr nil nil -> resourcemark in
  let XMLaddMark xmlfilestr "environment" scenestr nil nil -> envstr in
  
  let mkGroup ["Scene" nil currentProject nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] -> groupstr in  
  (
    shadowsInitScene xmlfilestr envstr sessionstr;
    renderingInitScene xmlfilestr envstr viewstr;
    physicsInitScene xmlfilestr envstr sessionstr;
  
    XMLaddMark xmlfilestr "plugins" scenestr nil nil;
    XMLaddMark xmlfilestr "graph" scenestr nil nil;
    set groupstr.GRP_xmlMark = scenestr;
    set groupstr.GRP_iWaitForLoad = 0;
    
    set lGroups = [scenestr groupstr]::lGroups;
    crEdCtrlModuleEditorBox mainInterf.MINT_meGroups "Scene" "Scene" nil 3 1 nil 0;    
    
    xmlfilestr;
  );;


fun newOsSceneGroup(viewstr, xmlfilestr, fathermark, name, id, alias, father, scale, pos, ang, treefather, plx, ply)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getNewSceneIndex id -> id in
  let XMLaddMark xmlfilestr "group" fathermark ["id" (itoa id)]::["name" name]::["alias" alias]::["px" (itoa plx)]::["py" (itoa ply)]::nil nil -> groupmark in
  let if scale == nil then [1.0 1.0 1.0] else scale -> scale in
  let if pos == nil then [0.0 0.0 0.0] else pos -> pos in
  let if ang == nil then [0.0 0.0 0.0 1.0] else ang -> ang in
  let V3DaddShell sessionstr name (itoa id) father pos ang -> shell in
  let scale -> [sx sy sz] in
  let pos -> [px py pz] in
  let ang -> [ax ay az aw] in
  
  let mkGroup [(strcatn (itoa id)::"."::name::nil) nil currentProject shell nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] -> groupstr in
  let addGraphItem strcatn name::" #"::(itoa id)::nil (strcatn (itoa id)::"."::name::nil) iTypeGroup alias groupmark nil fathermark sTreeBitmapGroup treefather 0 0 -> treenode in
  (
    V3DshowObjectHelper viewstr sessionstr shell iTypeNode 1;
    set groupstr.GRP_xmlMark = groupmark;
    set groupstr.GRP_iWaitForLoad = 0;
    
    SO3GroupCreate (V3DgetSession sessionstr) (strcatn (itoa id)::"."::name::nil);
    SO3ObjectSetScale shell scale;
    XMLaddMark xmlfilestr "scale" groupmark ["x" (XMLgetShortFloatToString sx)]::["y" (XMLgetShortFloatToString sy)]::["z" (XMLgetShortFloatToString sz)]::nil nil;
    XMLaddMark xmlfilestr "position" groupmark ["x" (XMLgetShortFloatToString px)]::["y" (XMLgetShortFloatToString py)]::["z" (XMLgetShortFloatToString pz)]::nil nil;
    XMLaddMark xmlfilestr "rotation" groupmark ["qx" (XMLgetShortFloatToString ax)]::["qy" (XMLgetShortFloatToString ay)]::["qz" (XMLgetShortFloatToString az)]::["qw" (XMLgetShortFloatToString aw)]::nil nil;          
    XMLaddMark xmlfilestr "resources" groupmark nil nil;
    XMLaddMark xmlfilestr "plugins" groupmark nil nil;
    XMLaddMark xmlfilestr "graph" groupmark nil nil;
    
    let XMLaddMark xmlfilestr "cinematics" groupmark nil nil -> cinematicsstr in
      addGraphItem "Cinematics" (strcatn (itoa id)::"."::name::"."::"Cinematics"::nil) iTypeCinematics nil cinematicsstr nil groupmark sTreeBitmapAnim treenode 1 0; 
    
    set lGroups = [groupmark groupstr]::lGroups;
    
    setEdCtrlModuleEditorBoxTooltip mainInterf.MINT_meGroups (crEdCtrlModuleEditorBox mainInterf.MINT_meGroups (strcatn (itoa id)::"."::name::nil) (if (alias == nil) || (!strcmp alias "") then (strcatn (itoa id)::"."::name::nil) else alias) nil plx ply nil 0) (strcatn (itoa id)::"."::name::nil);
    
    [groupstr shell treenode];
  );;


fun deleteOsGroup(viewstr, markstr)=
  let switch lGroups markstr -> groupstr in
  let mainInterf.MINT_winPlugins -> [plugswinstr [tbstr tabbarstr minmaxchk1]] in
  (
    dsEdTab tabbarstr groupstr.GRP_tabPlugins;
    
    // remove group plugITs instances
    deleteOsInstances groupstr;
    
    dsEdCtrlModuleEditorBox mainInterf.MINT_meGroups (getEdCtrlModuleEditorBoxByName mainInterf.MINT_meGroups groupstr.GRP_sName);
    paintEdCtrlModuleEditor mainInterf.MINT_meGroups;
    
    set lGroups = V3DremoveIdxFromList lGroups markstr;
  );
  0;;


fun addOsResourceDir(ldir)=
  if (ldir == nil) then nil else
  (
    set lResourcesPath = quicksort (lcat lResourcesPath ldir) @suppDoublon;
    fillEdCtrlList ctrlResourcesDirList lResourcesPath;
  );
  0;;


fun addOsSceneResource(xmlfilestr, groupmark, path, type)=
  let strlowercase path -> path in
  let if groupmark == nil then (XMLgetMarkByValue xmlfilestr "scene") else groupmark -> groupmark in
  let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcemark in
  let XMLgetMarkByValueAndParamValueFromMark resourcemark "resource" "path" path -> resexist in
  if (resexist != nil) then nil else
    XMLaddMark xmlfilestr "resource" resourcemark ["type" (getResourceNameByType type)]::["path" path]::nil nil;
  0;;


fun setViewWireMode(viewstr, mode)=
  set bShowWireMode = mode;
  let (V3DgetDefaultViewport viewstr) -> viewportstr in
  (
    V3DsetViewportPolygonMode viewportstr if bShowWireMode then SO3_POLY_WIREFRAME else SO3_POLY_SOLID;
    
    if (mode) then
    (
      set bLastSsaoMode = SO3ViewportGetSSAOEnabled viewportstr.V3D_viewport;
      set bLastHdrMode = SO3ViewportGetHDREnabled viewportstr.V3D_viewport;
      SO3ViewportSetSSAOEnabled viewportstr.V3D_viewport 0;   
      SO3ViewportSetShadowEnabled viewportstr.V3D_viewport 0;
      SO3ViewportSetHDREnabled viewportstr.V3D_viewport 0;
      0;
    )
    else
    (
      SO3ViewportSetSSAOEnabled viewportstr.V3D_viewport bLastSsaoMode;
      SO3ViewportSetShadowEnabled viewportstr.V3D_viewport 1;
      SO3ViewportSetHDREnabled viewportstr.V3D_viewport bLastHdrMode;
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  History
/ ********************************************************************************************* */
fun resetObjHistory()=
  set lObjUndoHistory = nil;
  set lObjRedoHistory = nil;
  0;;


fun getObjHistoryState(name, markstr, obj, type)=
  if ((name == nil) || (markstr == nil)) then nil else
  let nil -> pos in
  let nil -> quat in
  let nil -> scale in
  (
    if (type > 3) then nil else
    (
      let XMLgetMarkByValueFromMarkSons markstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
        set pos = [xpos ypos zpos];
      
      let XMLgetMarkByValueFromMarkSons markstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
        set quat = [xang yang zang wang];
      
      let XMLgetMarkByValueFromMarkSons markstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
        set scale = [xscale yscale zscale];
    );
    
    let XMLgetParam markstr "alias" -> alias in
      mkPRSHistoryState[type name markstr markstr.XMLfather obj (SO3ObjectGetParent obj) pos quat scale alias];
  );;


fun updateToolbarHistoryBtn()=
  let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ btnundo btnredo _ _ _ _ _ _ _ _ _]] in
  (
    let hd lObjUndoHistory -> nstate in
    let if nstate.OBJHS_iType == 0 then
          "Undo last hierarchy change (Ctrl + Z)"
        else if nstate.OBJHS_iType == 1 then
          "Undo last translation (Ctrl + Z)"
        else if nstate.OBJHS_iType == 2 then
          "Undo last rotation (Ctrl + Z)"
        else if nstate.OBJHS_iType == 3 then
          "Undo last scale (Ctrl + Z)"
        else if nstate.OBJHS_iType == 4 then
          "Undo last selection (Ctrl + Z)"
        else if nstate.OBJHS_iType == 5 then
          "Undo last alias change (Ctrl + Z)"
        else
          "Undo (Ctrl + Z)"
    -> bubble in
      setEdToolBarButtonToolTip tbstr btnundo bubble;
    
    let hd lObjRedoHistory -> nstate in
    let if nstate.OBJHS_iType == 0 then
          "Redo last hierarchy change (Ctrl + Y)"
        else if nstate.OBJHS_iType == 1 then
          "Redo last translation (Ctrl + Y)"
        else if nstate.OBJHS_iType == 2 then
          "Redo last rotation (Ctrl + Y)"
        else if nstate.OBJHS_iType == 3 then
          "Redo last scale (Ctrl + Y)"
        else if nstate.OBJHS_iType == 4 then
          "Redo last selection (Ctrl + Y)"
        else if nstate.OBJHS_iType == 5 then
          "Redo last alias change (Ctrl + Y)"
        else
          "Redo (Ctrl + Y)"
    -> bubble in
      setEdToolBarButtonToolTip tbstr btnredo bubble;
    
    setEdToolBarButtonEnable tbstr btnundo if lObjUndoHistory == nil then 0 else 1;
    setEdToolBarButtonEnable tbstr btnredo if lObjRedoHistory == nil then 0 else 1;
  );
  0;;


// ObjHistoryState
fun addObjHistoryState(name, markstr, obj, type)=
  if ((!bEnableHistoryState) || (markstr == nil)) then nil else
  (
    let getObjHistoryState name markstr obj type -> nstate in
    if (nstate == nil) then nil else
      set lObjUndoHistory = nstate::lObjUndoHistory;
    
    set lObjRedoHistory = nil;
    updateToolbarHistoryBtn;
  );
  0;;


fun applyObjHistoryState(state)=
  set bEnableHistoryState = 0;
  let SO3ObjectGetName state.OBJHS_obj -> objname in
  let getGraphByValue state.OBJHS_sName -> [item1 type _ _ _ _ _ _] in
  if (state.OBJHS_iType <= 3) then
  (
    let XMLgetMarkByValueFromMarkSons state.OBJHS_markstr "position" -> nodeposstr in
    let state.OBJHS_vPos -> [x y z] in
    (
      XMLsetParam nodeposstr "x" XMLgetShortFloatToString x;
      XMLsetParam nodeposstr "y" XMLgetShortFloatToString y;
      XMLsetParam nodeposstr "z" XMLgetShortFloatToString z;
    );
    
    let XMLgetMarkByValueFromMarkSons state.OBJHS_markstr "rotation" -> noderotstr in
    let state.OBJHS_vQuat -> [x y z w] in
    (
      XMLsetParam noderotstr "qx" XMLgetShortFloatToString x;
      XMLsetParam noderotstr "qy" XMLgetShortFloatToString y;
      XMLsetParam noderotstr "qz" XMLgetShortFloatToString z;
      XMLsetParam noderotstr "qw" XMLgetShortFloatToString w;
    );
    
    let XMLgetMarkByValueFromMarkSons state.OBJHS_markstr "scale" -> nodescalestr in
    let state.OBJHS_vScale -> [x y z] in
    (
      XMLsetParam nodescalestr "x" XMLgetShortFloatToString x;
      XMLsetParam nodescalestr "y" XMLgetShortFloatToString y;
      XMLsetParam nodescalestr "z" XMLgetShortFloatToString z;
    );
     
    SO3ObjectLink state.OBJHS_obj state.OBJHS_parent;
    SO3ObjectSetPosition state.OBJHS_obj state.OBJHS_vPos;
    SO3ObjectSetOrientation state.OBJHS_obj state.OBJHS_vQuat;
    SO3ObjectSetScale state.OBJHS_obj state.OBJHS_vScale;
    
    let winCoordsSetup -> [wobj wobjstr owinstr mode ctrlpx ctrlpy ctrlpz ctrlpgx ctrlpgy ctrlpgz x y] in
    if (wobj != state.OBJHS_obj) then nil else
    (
      let [0.0 0.0 0.0] -> vec in
      let [0.0 0.0 0.0] -> gvec in
      (
        if (mode == 1) then
        (
          set vec = SO3ObjectGetPosition state.OBJHS_obj;
          set gvec = SO3ObjectGetGlobalPosition state.OBJHS_obj;
        )
        else if (mode == 2) then
        (
          let SO3ObjectGetOrientation state.OBJHS_obj -> quat in
          let SO3MathsQuatToEulerYXZ quat -> [dx dy dz] in
            set vec = [SO3MathsRadianToDegree dx SO3MathsRadianToDegree dy SO3MathsRadianToDegree dz];
          
          let SO3ObjectGetGlobalOrientation state.OBJHS_obj -> gquat in
          let SO3MathsQuatToEulerYXZ gquat -> [dgx dgy dgz] in
            set gvec = [SO3MathsRadianToDegree dgx SO3MathsRadianToDegree dgy SO3MathsRadianToDegree dgz];
        )
        else if (mode == 3) then
        (
          set vec = SO3ObjectGetScale state.OBJHS_obj;
          set gvec = SO3ObjectGetGlobalScale state.OBJHS_obj;
        )
        else nil;
        
        let vec -> [x y z] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlpx x;
          setEdCtrlFloatValueWithoutCallback ctrlpy y;
          setEdCtrlFloatValueWithoutCallback ctrlpz z;
        );
        
        let gvec -> [x y z] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlpgx x;
          setEdCtrlFloatValueWithoutCallback ctrlpgy y;
          setEdCtrlFloatValueWithoutCallback ctrlpgz z;
        );
      );
    );
    
    if (state.OBJHS_markstr.XMLfather == state.OBJHS_parentstr) then nil else
    let getGraphByValue SO3ObjectGetName state.OBJHS_parent -> [item2 _ _ _ _ _ _ _] in
    (
      moveEdCtrlTreeItem ctrlSceneTree item1 item2;
      XMLmoveMark xmlEditSceneFile state.OBJHS_markstr state.OBJHS_parentstr;
      selEdCtrlTreeItemByValue ctrlSceneTree state.OBJHS_sName;
    );
  )
  else if (state.OBJHS_iType == 4) then
  (
    selEdCtrlTreeItemByValue ctrlSceneTree state.OBJHS_sName;
  )
  else if (state.OBJHS_iType == 5) then
  (
    let XMLgetParam state.OBJHS_markstr "name" -> objname in
    let XMLgetParam state.OBJHS_markstr "id" -> id in
    let if (state.OBJHS_sAlias == nil) || (!strcmp "" (strtrim state.OBJHS_sAlias)) then
          (strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))
        else if type == iTypeCompositor then
          strcatn state.OBJHS_sAlias::" ("::"Compositor \""::objname::"\")"::nil
        else if type == iTypeSkyBox then
          strcatn state.OBJHS_sAlias::" (SkyBox)"::nil
        else if type == iTypeSkyDome then
          strcatn state.OBJHS_sAlias::" (SkyDome)"::nil
        else if type == iTypeSkyPlane then
          strcatn state.OBJHS_sAlias::" (SkyPlane)"::nil
        else
          strcatn state.OBJHS_sAlias::" ("::(strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))::")"::nil
    -> nalias in
    (
      XMLsetParam state.OBJHS_markstr "alias" state.OBJHS_sAlias;
      setGraphItemAlias state.OBJHS_sName state.OBJHS_sAlias;
      setEdCtrlTreeLabel ctrlSceneTree item1 nalias; 
      
      if (type != iTypeGroup) then nil else
      let getGroupByName state.OBJHS_sName -> groupstr in
      let mainInterf.MINT_winPlugins -> [plugswinstr [tbstr tabbarstr minmaxchk1]] in
      let if (state.OBJHS_sAlias == nil) || (!strcmp "" (strtrim state.OBJHS_sAlias)) then
            (strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))
          else
            state.OBJHS_sAlias
      -> groupname in
      (
        setEdCtrlModuleEditorBoxLabel mainInterf.MINT_meGroups (getEdCtrlModuleEditorBoxByName mainInterf.MINT_meGroups state.OBJHS_sName) groupname;
        renameEdTab tabbarstr groupstr.GRP_tabPlugins groupname;
      );
    );
  )
  else nil;
  
  set bEnableHistoryState = 1;
  0;;


fun restoreLastObjHistoryState()=
  let hd lObjUndoHistory -> state in
  if (state == nil) then nil else
  (
    let if state.OBJHS_iType == 4 then 
          let getGraphByValue sSelected -> [_ _ _ markstr _ _ _ _] in
            getObjHistoryState sSelected markstr nil 4
        else
          getObjHistoryState state.OBJHS_sName state.OBJHS_markstr state.OBJHS_obj state.OBJHS_iType
    -> nstate in
    if (nstate == nil) then nil else
      set lObjRedoHistory = nstate::lObjRedoHistory;
    
    applyObjHistoryState state;
    
    // remove last state
    set lObjUndoHistory = tl lObjUndoHistory;
    
    updateToolbarHistoryBtn;
  );
  0;;


fun restorePreviousObjHistoryState()=
  let hd lObjRedoHistory -> state in
  if (state == nil) then nil else
  (
    let if state.OBJHS_iType == 4 then 
          let getGraphByValue sSelected -> [_ _ _ markstr _ _ _ _] in
            getObjHistoryState sSelected markstr nil 4
        else
          getObjHistoryState state.OBJHS_sName state.OBJHS_markstr state.OBJHS_obj state.OBJHS_iType
    -> nstate in
    if (nstate == nil) then nil else
      set lObjUndoHistory = nstate::lObjUndoHistory;
    
    applyObjHistoryState state;
    
    // remove last state
    set lObjRedoHistory = tl lObjRedoHistory;
    
    updateToolbarHistoryBtn;
  );
  0;;


/* ********************************************************************************************* /
  Os scene Loader
/ ********************************************************************************************* */
fun getOsGroupResources(groupstr, groupmark)=
  let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
  let XMLgetMarksByValueFromMarkSons resourcesmark "resource" -> lresourcemarks in
  (
    let sizelist lresourcemarks -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lresourcemarks i -> resourcemark in
      let XMLgetParam resourcemark "type" -> type in
      let XMLgetParam resourcemark "path" -> path in
      let getPathFile path "" -> [dir _] in
      (
        if (dir == nil) || (!strcmp "" (strtrim dir)) then nil else
          addOsResourceDir dir::nil;
        
        set groupstr.GRP_lAvailableResourcesFiles = path::groupstr.GRP_lAvailableResourcesFiles;
      );
      
      set i = i + 1;
    );
    
    set groupstr.GRP_lAvailableResourcesFiles = quicksort groupstr.GRP_lAvailableResourcesFiles @suppDoublon;
  );
  0;;


fun loadCinematics(viewstr, groupstr, srcgroupmark, import)=
  let getGraphByValue (strcatn groupstr.GRP_sName::"."::"Cinematics"::nil) -> [treecinematics _ _ cinematicsstr _ _ _ _] in
  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarkByValueFromMarkSons srcgroupmark "cinematics" -> cinematicsxml in
  let XMLgetMarksByValueFromMarkSons cinematicsxml "animation" -> lanimmarks in
  let nil -> lanims in
  (
    //Load all anims before keys to be sure to find the key anim
    let sizelist lanimmarks -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lanimmarks i -> animmark in
      let XMLgetParam animmark "id" -> id in
      let if import then nil else XMLgetParam animmark "id" -> id in
      let itoa getNewSceneIndex (atoi id) -> id in      
      let XMLgetParam animmark "name" -> animname in
      let XMLgetParam animmark "alias" -> alias in
      let XMLgetBoolParam animmark "enable" -> animstate in
      let XMLgetBoolParam animmark "loop" -> animloop in
      let atof XMLgetParam animmark "speed" -> animspeed in
      let atof XMLgetParam animmark "weight" -> animweight in
      let XMLgetBoolParam animmark "skipFrame" -> skipFrame in
      let if (XMLgetParam animmark "skipFrame") == nil then 1 else skipFrame -> skipFrame in
      
      let if (animspeed == nil) then fDefaultAnimationSpeed else animspeed -> animspeed in
      let strcatn id::"."::animname::nil -> curanimname in
      
      let V3DaddSequenceAnimation sessionstr (atoi id) animname curanimname animspeed animweight 0 animloop -> animstr in
      let XMLaddMark xmlEditSceneFile "animation" cinematicsstr ["id" id]::["name" animname]::["type" "cinematic"]::["alias" alias]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["speed" (XMLgetShortFloatToString animspeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString skipFrame)]::nil nil -> newanimmark in
      let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim alias newanimmark nil groupstr.GRP_xmlMark sTreeBitmapAnim treecinematics animstate 0 -> treeanim in  
      (
        if (!import) then nil else
          set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam animmark "id")::"."::animname::nil) (strcatn id::"."::animname::nil)]::groupstr.GRP_lTmpFunctionsImport;
      
        V3DanimationSetDefaultSkipFrame animstr skipFrame;
        set lanims = [animstr animmark newanimmark]::lanims;
      );
      
      set i = i + 1;
    );
    
    let sizelist lanims -> size in
    let 0 -> i in
    while i < size do    
    (
      let nth_list lanims i -> [animstr animmark newanimmark] in
      let XMLgetMarksByValueFromMarkSons animmark "track" -> ltrackmarks in
      let sizelist ltrackmarks -> jsize in
      let 0 -> j in
      while j < jsize do
      (
        let V3DaddSequenceAnimationTrack animstr -> trackidx in
        let XMLaddMark xmlEditSceneFile "track" newanimmark nil nil -> newtrackstr in
        let nth_list ltrackmarks j -> trackmark in
        let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
        let sizelist lkeymarks -> ksize in
        let 0 -> k in
        while k < ksize do
        (
          let nth_list lkeymarks k -> keymark in
          let XMLgetParam keymark "animId" -> keyanimid in
          let XMLgetParam keymark "animName" -> keyanim in
          let atof XMLgetParam keymark "length" -> length in
          let atof XMLgetParam keymark "transition" -> transition in
          let atof XMLgetParam keymark "decal" -> decal in
          
          let strcatn keyanimid::"."::keyanim::nil -> curkeyanimname in
          let if import then switchstri groupstr.GRP_lTmpFunctionsImport curkeyanimname else curkeyanimname -> curkeyanimname in
          let if import then let cutDotName curkeyanimname -> [nid _] in nid else keyanimid -> keyanimid in
          let V3DgetAnimationByName sessionstr curkeyanimname -> keyanimstr in
          //let if length == nil then SO3AnimationGetLenght keyanimstr.V3D_anim else length -> length in
          (
            if (keyanimstr == nil) then nil else
            {
              XMLaddMark xmlEditSceneFile "keyframe" newtrackstr ["animId" keyanimid]::["animName" keyanim]::["length" (XMLgetShortFloatToString length)]::["transition" (XMLgetShortFloatToString transition)]::["decal" (XMLgetShortFloatToString decal)]::nil nil;
              V3DaddSequenceAnimationKey animstr trackidx keyanimstr length transition decal;
            }
          );
          
          set k = k + 1;
        );
        
        set j = j + 1;
      );
      
      set i = i + 1;
    );
  );
  0;;


fun loadEnvironment(viewstr, groupmark)=
  let getGroupName currentProject nil -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetDefaultViewport viewstr -> defaultviewportstr in
  
  let XMLgetMarkByValueFromMarkSons groupmark "environment" -> envxml in
  if envxml == nil then nil else
  (    
    let XMLgetMarkByValueFromMarkSons envxml "materialScheme" -> matschemestr in
    let XMLgetParam matschemestr "name" -> schemename in
    
    let XMLgetMarkByValueFromMarkSons envxml "skyBox" -> skyboxstr in
    let XMLgetBoolParam skyboxstr "enable" -> skyboxenable in
    let XMLgetParam skyboxstr "material" -> skyboxmat in
    let XMLgetParam skyboxstr "alias" -> skyboxalias in
    let atof XMLgetParam skyboxstr "distance" -> skyboxdistance in
    let XMLgetBoolParam skyboxstr "drawFirst" -> skyboxdrawfirst in
    let XMLgetMarkByValueFromMarkSons skyboxstr "rotation" -> skyboxrotstr in
    let atof XMLgetParam skyboxrotstr "qx" -> skyboxqx in
    let atof XMLgetParam skyboxrotstr "qy" -> skyboxqy in
    let atof XMLgetParam skyboxrotstr "qz" -> skyboxqz in
    let atof XMLgetParam skyboxrotstr "qw" -> skyboxqw in
    
    let XMLgetMarkByValueFromMarkSons envxml "skyDome" -> skydomestr in
    let XMLgetBoolParam skydomestr "enable" -> skydomeenable in
    let XMLgetParam skydomestr "material" -> skydomemat in
    let XMLgetParam skydomestr "alias" -> skydomealias in
    let atof XMLgetParam skydomestr "distance" -> skydomedistance in
    let atof XMLgetParam skydomestr "tiling" -> skydometiling in
    let atof XMLgetParam skydomestr "curvature" -> skydomecurve in
    let atoi XMLgetParam skydomestr "xSegments" -> skydomexseg in
    let atoi XMLgetParam skydomestr "ySegments" -> skydomeyseg in
    let XMLgetBoolParam skydomestr "drawFirst" -> skydomedrawfirst in
    let XMLgetMarkByValueFromMarkSons skydomestr "rotation" -> skydomerotstr in
    let atof XMLgetParam skydomerotstr "qx" -> skydomeqx in
    let atof XMLgetParam skydomerotstr "qy" -> skydomeqy in
    let atof XMLgetParam skydomerotstr "qz" -> skydomeqz in
    let atof XMLgetParam skydomerotstr "qw" -> skydomeqw in
    
    let XMLgetMarkByValueFromMarkSons envxml "skyPlane" -> skyplanstr in
    let XMLgetBoolParam skyplanstr "enable" -> skyplanenable in
    let XMLgetParam skyplanstr "material" -> skyplanmat in
    let XMLgetParam skyplanstr "alias" -> skyplanalias in
    let atof XMLgetParam skyplanstr "planeX" -> skyplanx in
    let atof XMLgetParam skyplanstr "planeY" -> skyplany in
    let atof XMLgetParam skyplanstr "planeZ" -> skyplanz in
    let atof XMLgetParam skyplanstr "planeD" -> skypland in
    let atof XMLgetParam skyplanstr "scale" -> skyplanscale in
    let atof XMLgetParam skyplanstr "bow" -> skyplanbow in
    let atof XMLgetParam skyplanstr "tiling" -> skyplantiling in
    let atoi XMLgetParam skyplanstr "xSegments" -> skyplanxseg in
    let atoi XMLgetParam skyplanstr "ySegments" -> skyplanyseg in  
    let XMLgetBoolParam skyplanstr "drawFirst" -> skyplandrawfirst in    
    
    let XMLgetMarkByValueFromMarkSons envxml "fog" -> fogstr in
    let XMLgetParam fogstr "mode" -> sfogmode in
    let atof XMLgetParam fogstr "linearStart" -> foglinearStart in
    let atof XMLgetParam fogstr "linearEnd" -> foglinearEnd in
    let atof XMLgetParam fogstr "density" -> fogdensity in
    let XMLgetMarkByValueFromMarkSons fogstr "colourDiffuse" -> fogambstr in
    let make_rgba (ftoi ((atof XMLgetParam fogambstr "r") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "g") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "b") *. 255.0)) 0 -> fogcolor in

    let XMLgetMarkByValueFromMarkSons fogstr "colourDiffuse" -> fogambstr in
    let make_rgba (ftoi ((atof XMLgetParam fogambstr "r") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "g") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "b") *. 255.0)) 0 -> fogcolor in

    let XMLgetMarkByValue xmlEditSceneFile "scene" -> scenestr in
    let XMLgetMarkByValueFromMarkSons scenestr "environment" -> targetenvironmentstr in
    (
      if (fogstr == nil) then nil else
      let XMLgetMarkByValueFromMarkSons targetenvironmentstr "fog" -> targetfogstr in
      let if targetfogstr != nil then targetfogstr else XMLaddMark xmlEditSceneFile "fog" targetenvironmentstr nil nil -> targetfogstr in
      let XMLgetMarkByValueFromMarkSons targetfogstr "colourDiffuse" -> targetfogcolorstr in
      let if targetfogcolorstr != nil then targetfogcolorstr else XMLaddMark xmlEditSceneFile "colourDiffuse" targetfogstr nil nil -> targetfogcolorstr in
      (
        XMLsetParam targetfogstr "mode" sfogmode;
        XMLsetParam targetfogstr "linearStart" XMLgetShortFloatToString foglinearStart;
        XMLsetParam targetfogstr "linearEnd" XMLgetShortFloatToString foglinearEnd;
        XMLsetParam targetfogstr "density" XMLgetShortFloatToString fogdensity;
        
        XMLsetParam targetfogcolorstr "r" (XMLgetParam fogambstr "r");
        XMLsetParam targetfogcolorstr "g" (XMLgetParam fogambstr "g");
        XMLsetParam targetfogcolorstr "b" (XMLgetParam fogambstr "b");
        
        V3DsetSceneFog sessionstr (getOgreFogType sfogmode) fogcolor fogdensity foglinearStart foglinearEnd;
      );
      
      if (skyboxstr == nil) then nil else
      let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skyboxmat) -> skymat in
      let XMLgetMarkByValueFromMarkSons targetenvironmentstr "skyBox" -> targetskyboxstr in
      (
        if targetskyboxstr != nil then nil else
          addGraphItem "SkyBox" "SkyBox" iTypeSkyBox skyboxalias (XMLcopyMark xmlEditSceneFile skyboxstr targetenvironmentstr) nil groupmark sTreeBitmapSky (getEdCtrlTreeRootItem ctrlSceneTree) 1 0;
        SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat skyboxdistance [skyboxqx skyboxqy skyboxqz skyboxqw] resgroup skyboxenable skyboxdrawfirst;
      );
      
      if (skydomestr == nil) then nil else
      let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skydomemat) -> skymat in
      let XMLgetMarkByValueFromMarkSons targetenvironmentstr "SkyDome" -> targetskydomestr in
      (
        if targetskydomestr != nil then nil else
          addGraphItem "SkyDome" "SkyDome" iTypeSkyDome skydomealias (XMLcopyMark xmlEditSceneFile skyboxstr targetenvironmentstr) nil groupmark sTreeBitmapSky (getEdCtrlTreeRootItem ctrlSceneTree) 1 0;
        SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat skydomedistance [skydomeqx skydomeqy skydomeqz skydomeqw] (if skydomecurve == nil then 0.0 else skydomecurve) skydometiling skydomexseg skydomeyseg (-1) resgroup skydomeenable skydomedrawfirst;
      );
      
      if (skyplanstr == nil) then nil else
      let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skyplanmat) -> skymat in
      let XMLgetMarkByValueFromMarkSons targetenvironmentstr "SkyPlane" -> targetskyplanstr in
      (
        if targetskyplanstr != nil then nil else
          addGraphItem "SkyPlane" "SkyPlane" iTypeSkyPlane skyplanalias (XMLcopyMark xmlEditSceneFile skyplanstr targetenvironmentstr) nil groupmark sTreeBitmapSky (getEdCtrlTreeRootItem ctrlSceneTree) 1 0;

        SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat skypland [skyplanx skyplany skyplanz] skyplanscale skyplantiling (if skyplanbow == nil then 0.0 else skyplanbow) skyplanxseg skyplanyseg resgroup skyplanenable skyplandrawfirst;
      );
      
      let XMLgetMarksByValueFromMarkSons envxml "compositor" -> lcompmark in
      if lcompmark == nil then nil else
      let sizelist lcompmark -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lcompmark i -> compmark in
        let XMLgetParam compmark "name" -> compname in
        let XMLgetParam compmark "alias" -> alias in
        let XMLgetBoolParam compmark "enable" -> compstate in
        (
          //if !compstate then nil else
          //  SO3ViewportAddCompositor (V3DgetSession sessionstr) compname defaultviewportstr.V3D_viewport;
          addGraphItem strcatn "Compositor \""::compname::"\""::nil compname iTypeCompositor alias (XMLcopyMark xmlEditSceneFile compmark targetenvironmentstr) nil groupmark sTreeBitmapCompositor (getEdCtrlTreeRootItem ctrlSceneTree) compstate 0;
        );
        
        set i = i + 1;
      );      
      
      if schemename == nil then nil else
        SO3ViewportSetMaterialScheme defaultviewportstr.V3D_viewport schemename;
      
      renderingLoadEnv envxml targetenvironmentstr viewstr;
      
      //shadows
      shadowsLoadEnv envxml targetenvironmentstr sessionstr;
      
      //environment
      environmentLoadEnv envxml targetenvironmentstr sessionstr;
      
      //physics
      physicsLoadEnv envxml targetenvironmentstr sessionstr;
     
      //default camera
      let XMLgetMarkByValueFromMarkSons envxml "defaultCamera" -> defcamerastr in
      let XMLgetBoolParam defcamerastr "orthographic" -> cameraortho in
      let atof XMLgetParam defcamerastr "windowScale" -> windowscale in
      let atof XMLgetParam defcamerastr "fov" -> camerafov in
      let if camerafov == nil then 57.29 else camerafov -> camerafov in
      let atof XMLgetParam defcamerastr "focalLenght" -> camerafocallength in
      let if camerafocallength == nil then 1.0 else camerafocallength -> camerafocallength in
      let atof XMLgetParam defcamerastr "dist" -> cameradist in
      let if cameradist == nil then
            let SO3ObjectGetPosition (V3DgetDefaultCamera sessionstr) -> [_ _ d] in
              d
          else
            cameradist
      -> cameradist in
      
      let XMLgetMarkByValueFromMarkSons defcamerastr "clipping" -> camclippingstr in
      let atof XMLgetParam camclippingstr "near" -> camclipnear in
      let if camclipnear == nil then 0.01 else camclipnear -> camclipnear in
      let atof XMLgetParam camclippingstr "far" -> camclipfar in
      let if camclipfar == nil then 10000.0 else camclipfar -> camclipfar in
      
      let XMLgetMarkByValueFromMarkSons defcamerastr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let if xpos == nil then 0.0 else xpos -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let if ypos == nil then 0.0 else ypos -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let if zpos == nil then 0.0 else zpos -> zpos in
      let XMLgetMarkByValueFromMarkSons defcamerastr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "x" -> xang in
      let atof XMLgetParam noderotstr "y" -> yang in
      let atof XMLgetParam noderotstr "z" -> zang in
      let XMLaddMark xmlEditSceneFile "defaultCamera" targetenvironmentstr ["orthographic" (XMLgetBoolString cameraortho)]::["windowScale" XMLgetShortFloatToString windowscale]::["fov" XMLgetShortFloatToString camerafov]::["focalLenght" XMLgetShortFloatToString camerafocallength]::["dist" XMLgetShortFloatToString cameradist]::nil nil -> targetdefcamerastr in
      (
        XMLaddMark xmlEditSceneFile "clipping" targetdefcamerastr ["near" XMLgetShortFloatToString camclipnear]::["far" XMLgetShortFloatToString camclipfar]::nil nil;
        XMLaddMark xmlEditSceneFile "position" targetdefcamerastr ["x" XMLgetShortFloatToString xpos]::["y" XMLgetShortFloatToString ypos]::["z" XMLgetShortFloatToString zpos]::nil nil;
        XMLaddMark xmlEditSceneFile "rotation" targetdefcamerastr ["x" XMLgetShortFloatToString xang]::["y" XMLgetShortFloatToString yang]::["z" XMLgetShortFloatToString zang]::nil nil;
        
        let SO3MathsDegreeToRadian camerafov -> fov in
          V3DsetCamera (V3DgetDefaultCamera sessionstr) camerafocallength fov camclipnear camclipfar;
        
        SO3ObjectSetPosition (V3DgetDefaultCamera sessionstr) [0.0 0.0 cameradist];
        V3DsetShellNavPos sessionstr [xpos ypos zpos];
      
        if (noderotstr == nil) then nil else
          V3DsetShellNavAng sessionstr SO3MathsEulerXYZToQuat [(SO3MathsDegreeToRadian xang) (SO3MathsDegreeToRadian yang) (SO3MathsDegreeToRadian zang)];
        
        V3DsetOrthographicMode (V3DgetDefaultCamera sessionstr) cameraortho;
        V3DsetOrthographicScale (V3DgetDefaultCamera sessionstr) windowscale;
      );
    );
  );
  0;;


fun playSceneGraph(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetDefaultViewport viewstr -> defaultviewportstr in
  (  
    let sizelist lSceneGraph -> lsgsize in
    let 0 -> lsgi in
    while lsgi < lsgsize do
    (
      let nth_list lSceneGraph lsgi -> [ename [etreeitem etype ealias emark _ egroupmark initstate staticgeometry]] in
      
      if (!strcmp "default_light" ename) || (!strcmp "default_camera" ename) then nil else
      (
        // SCENE
        if etype == iTypeScene then
        (
          let XMLgetMarkByValueFromMarkSons emark "environment" -> envxml in
          (
            environmentPlaySceneGraph envxml defaultviewportstr sessionstr;
            renderingPlaySceneGraph envxml defaultviewportstr;
            
            if (!bShowWireMode) then nil else
              SO3ViewportSetShadowEnabled defaultviewportstr.V3D_viewport 0;
          );
          0;
        )
        
        // PARTICLE
        else if etype == iTypeParticle then
        (
          let V3DgetObjectByName sessionstr ename -> partsystem in
            SO3ParticleSystemSetEnable partsystem initstate;
          0;
        )
        // ANIMS
        else if etype == iTypeAnim then
        (
          let V3DgetAnimationByName sessionstr ename -> animstr in
          (
            V3DsetAnimationState animstr initstate;
            V3DinitializeAnimation animstr 1;
          );
          0;
        )
        // NODE
        else if etype == iTypeNode then
        (
          let V3DgetObjectByName sessionstr ename -> node in
          (
            SO3ObjectSetAsStaticGeometry node staticgeometry;
          );
          0;
        )
        // MESH
        else if etype == iTypeEntity then
        (
          let V3DgetObjectByName sessionstr ename -> mesh in
          let SO3SceneNodeGetBody mesh -> body in
          (
            V3DphysEnableBody body initstate;
            SO3ObjectSetAsStaticGeometry mesh staticgeometry;
          );
          0;
        )
        // COMPOSITOR
        else if etype == iTypeCompositor then
        (
          let XMLgetParam emark "name" -> compname in
          let XMLgetParam emark "scheme" -> compschemename in
          (
            V3DregisterCompositor defaultviewportstr compname compschemename;
            if initstate then
              SO3ViewportAddCompositor defaultviewportstr.V3D_viewport compname compschemename
            else
              SO3ViewportRemoveCompositor defaultviewportstr.V3D_viewport compname;
          );
          0;
        )
        // CUBEMAP
        else if etype == iTypeCubeMap then
        (
          let V3DgetObjectByName sessionstr ename -> cubemap in
            SO3DynamicCubeMapSetEnable cubemap initstate;
          0;
        )
        // REFLECTIONMAP
        else if etype == iTypeReflectionMap then
        (
          let V3DgetObjectByName sessionstr ename -> reflectionmap in
            SO3DynamicReflectionMapSetEnable reflectionmap initstate;
          0;
        )
        else nil;
      );
      set lsgi = lsgi + 1;
    );
  );
  0;;


fun refreshSceneGraph(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetDefaultViewport viewstr -> defaultviewportstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) "default_camera" -> defaultcam in
  (
    V3DphysResetPhysic sessionstr;

    // Reset env
    environmentRefreshSceneGraph sessionstr defaultviewportstr;
    
    V3DuseDefaultLight sessionstr bLastDefaultLightState;
    V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultLight sessionstr) iTypeLight bLastDefaultLightState;

    // restore default camera
    V3DsetDefaultCamera sessionstr defaultcam;
    V3DenableNavigate sessionstr 1;
    
    let sizelist lSceneGraph -> lsgsize in
    let 0 -> lsgi in
    while lsgi < lsgsize do
    (
      let nth_list lSceneGraph lsgi -> [ename [etreeitem etype ealias emark _ egroupmark initstate staticgeometry]] in
      
      let XMLgetParam emark.XMLfather "id" -> fid in
      let XMLgetParam emark.XMLfather "name" -> fname in
      let if fid == nil || fname == nil then nil else V3DgetObjectByName sessionstr strcatn fid::"."::fname::nil -> father in
      let getGroupName currentProject egroupmark -> resgroup in
      if (!strcmp "default_light" ename) || (!strcmp "default_camera" ename) then nil else
      (
        // SCENE
        if etype == iTypeScene then
        (
          let XMLgetMarkByValueFromMarkSons emark "environment" -> envxml in
          if envxml == nil then nil else
          (
            let XMLgetMarkByValueFromMarkSons envxml "materialScheme" -> matschemestr in
            let XMLgetParam matschemestr "name" -> schemename in

            let XMLgetMarkByValueFromMarkSons envxml "fog" -> fogstr in
            let XMLgetParam fogstr "mode" -> sfogmode in
            let atof XMLgetParam fogstr "linearStart" -> foglinearStart in
            let atof XMLgetParam fogstr "linearEnd" -> foglinearEnd in
            let atof XMLgetParam fogstr "density" -> fogdensity in
            let XMLgetMarkByValueFromMarkSons fogstr "colourDiffuse" -> fogambstr in
            let make_rgba (ftoi ((atof XMLgetParam fogambstr "r") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "g") *. 255.0)) (ftoi ((atof XMLgetParam fogambstr "b") *. 255.0)) 0 -> fogcolor in
            (
              if (fogstr == nil) then nil else             
                V3DsetSceneFog sessionstr (getOgreFogType sfogmode) fogcolor fogdensity foglinearStart foglinearEnd;
              
              if schemename == nil then nil else
                SO3ViewportSetMaterialScheme defaultviewportstr.V3D_viewport schemename;
              
              //physics
              physicsRefreshSceneGraph envxml sessionstr;
              
              //rendering
              renderingRefreshSceneGraph envxml viewstr;
              
              //shadows
              shadowsRefreshSceneGraph envxml defaultviewportstr sessionstr;
            );
          );
          0;
        )
        // SHELL
        else if etype == iTypeNode || etype == iTypeGroup || etype == iTypeBone then
        (
          let V3DgetObjectByName sessionstr ename -> shell in
          
          let XMLgetBoolParam emark "hidden" -> nodehidden in
          let XMLgetBoolParam emark "staticGeometry" -> nodestaticgeometry in
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil || etype == iTypeBone then nil else
              SO3ObjectLink shell father;
            
            SO3ObjectSetPosition shell [xpos ypos zpos];
            SO3ObjectSetOrientation shell [xang yang zang wang];
            SO3ObjectSetScale shell [xscale yscale zscale];
            SO3ObjectSetAsStaticGeometry shell 0;
            SO3ObjectSetVisible shell !nodehidden 0;
            
            // physics
            physicsRefreshNodeGraph emark shell sessionstr;
          );
          0;
        )
        // ENTITY
        else if etype == iTypeEntity then
        (
          let V3DgetObjectByName sessionstr ename -> mesh in
          
          let XMLgetBoolParam emark "indexMaterials" -> indexmat in
          let XMLgetBoolParam emark "castShadows" -> meshcastshadow in
          let XMLgetBoolParam emark "hidden" -> meshhidden in
          let XMLgetBoolParam emark "staticGeometry" -> meshstaticgeometry in
          let XMLgetBoolParam emark "receiveShadows" -> meshreceiveshadow in
          let atof (XMLgetParam emark "renderingDistance") -> renderdistance in
          let htoi XMLgetParam emark "visibilityFlags" -> meshvisibilityflags in
          let XMLgetMarkByValueFromMarkSons emark "subentities" -> subentitiesstr in
          let XMLgetMarksByValueFromMarkSons subentitiesstr "subentity" -> lentitystr in
          
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil then nil else
              SO3ObjectLink mesh father;
              
            let sizelist lentitystr -> size in
            let 0 -> i in
            while i < size do
            (
              let nth_list lentitystr i -> elem in
              let atoi XMLgetParam elem "index" -> subidx in
              let XMLgetParam elem "materialName" -> submatname in
              let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup submatname -> submat in
                SO3EntitySetMaterial mesh submat subidx;
              
              set i = i + 1;
            );
              
            SO3ObjectSetPosition mesh [xpos ypos zpos];
            SO3ObjectSetOrientation mesh [xang yang zang wang];
            SO3ObjectSetScale mesh [xscale yscale zscale];
            SO3ObjectSetRenderingDistance mesh renderdistance;
            SO3EntitySetVisibilityFlags mesh meshvisibilityflags;
            
            // physics
            physicsRefreshNodeGraph emark mesh sessionstr;
            
            SO3ObjectSetCastShadows mesh meshcastshadow;
            SO3ObjectSetAsStaticGeometry mesh 0;
            SO3ObjectSetVisible mesh !meshhidden 0;
          );
          0;
        )
        // LIGHT
        else if etype == iTypeLight then
        (
          let V3DgetObjectByName sessionstr ename -> light in
          let getOgreMaxLightType (XMLgetParam emark "type") -> lighttype in
          let XMLgetBoolParam emark "castShadows" -> lightcastshadow in
          let atof XMLgetParam emark "power" -> lightpower in
          let XMLgetParam emark "enable" -> slightenable in
          let if slightenable == nil then 1 else (XMLgetBoolParam emark "enable") -> lightenable in
          
          let XMLgetMarkByValueFromMarkSons emark "colourDiffuse" -> lightdiffusestr in
          let make_rgba (ftoi ((atof XMLgetParam lightdiffusestr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "b") *. 255.0)) 0 -> lightdiffusecolor in
          
          let XMLgetMarkByValueFromMarkSons emark "colourSpecular" -> lightspecularstr in
          let make_rgba (ftoi ((atof XMLgetParam lightspecularstr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "b") *. 255.0)) 0 -> lightspecularcolor in
          
          let XMLgetMarkByValueFromMarkSons emark "lightAttenuation" -> lightattenuationstr in
          let atof XMLgetParam lightattenuationstr "range" -> lightrange in
          
          let XMLgetMarkByValueFromMarkSons emark "lightRange" -> lightrangestr in
          let atof XMLgetParam lightrangestr "inner" -> lightinner in
          let atof XMLgetParam lightrangestr "outer" -> lightouter in 
              
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            SO3LightSetVisible light lightenable;
            
            if father == nil then nil else
              SO3ObjectLink light father;
            
            SO3ObjectSetPosition light [xpos ypos zpos];
            SO3ObjectSetOrientation light [xang yang zang wang];
            SO3ObjectSetScale light [xscale yscale zscale];
  
            SO3LightSetType light lighttype;
            SO3LightSetPowerScale light lightpower;
            SO3LightSetDiffuseColor light lightdiffusecolor;
            SO3LightSetSpecularColor light lightspecularcolor;
            SO3LightSetAttenuationAuto light lightrange;
            SO3ObjectSetCastShadows light lightcastshadow;
            
            if lightrangestr == nil then nil else
            (    
              SO3LightSetSpotInnerAngle light lightinner;
              SO3LightSetSpotOuterAngle light lightouter;
            );
            0
          );
          0;
        )
        // CAMERA
        else if etype == iTypeCamera then
        (
          let V3DgetObjectByName sessionstr ename -> camera in
  
          let atof XMLgetParam emark "fov" -> camerafov in
          let atof XMLgetParam emark "focalLenght" -> camerafocallength in
          let if camerafocallength == nil then 1.0 else camerafocallength -> camerafocallength in
          
          let XMLgetMarkByValueFromMarkSons emark "clipping" -> camclippingstr in
          let atof XMLgetParam camclippingstr "near" -> camclipnear in
          let atof XMLgetParam camclippingstr "far" -> camclipfar in
          
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil then nil else
              SO3ObjectLink camera father;
            
            SO3ObjectSetPosition camera [xpos ypos zpos];
            SO3ObjectSetOrientation camera [xang yang zang wang];
            SO3ObjectSetScale camera [xscale yscale zscale];
            
            V3DsetCamera camera camerafocallength camerafov camclipnear camclipfar;
          );
          0;
        )
        // PARTICLE
        else if etype == iTypeParticle then
        (
          let V3DgetObjectByName sessionstr ename -> partsystem in
          
          let XMLgetParam emark "template" -> parttpl in
          let atof XMLgetParam emark "speed" -> partspeed in
          let if partspeed == nil then 1.0 else partspeed -> partspeed in
          let XMLgetBoolParam emark "enable" -> partenable in
          let atof (XMLgetParam emark "renderingDistance") -> renderdistance in
          
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil then nil else
              SO3ObjectLink partsystem father;
            
            SO3ObjectSetPosition partsystem [xpos ypos zpos];
            SO3ObjectSetOrientation partsystem [xang yang zang wang];
            SO3ObjectSetScale partsystem [xscale yscale zscale];
            
            SO3ParticleSystemSetSpeedFactor partsystem partspeed;
            SO3ParticleSystemClear partsystem;
            SO3ParticleSystemSetEnable partsystem 0;
            SO3ObjectSetRenderingDistance partsystem renderdistance;         
          );
          0;
        )
        // CUBEMAP
        else if etype == iTypeCubeMap then
        (
          let V3DgetObjectByName sessionstr ename -> cubemap in
          let XMLgetParam emark "material" -> matname in
          let atoi XMLgetParam emark "technique" -> mattech in
          let if mattech == nil then 0 else mattech -> mattech in
          let atoi XMLgetParam emark "pass" -> matpass in
          let if matpass == nil then 0 else matpass -> matpass in
          let atoi XMLgetParam emark "texunit" -> mattex in
          let if mattex == nil then 0 else mattex -> mattex in
          let atoi XMLgetParam emark "texsize" -> texsize in
          let if texsize == nil then 256 else texsize -> texsize in
          let XMLgetBoolParam emark "enable" -> enable in
          let atof XMLgetParam emark "renderingDistance" -> renderdistance in
          let XMLgetBoolParam emark "autoUpdate" -> autoupdate in
  
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil then nil else
              SO3ObjectLink cubemap father;
            
            SO3DynamicCubeMapSetEnable cubemap 0;
            SO3DynamicCubeMapSetAutoUpdate cubemap autoupdate;
            SO3DynamicCubeMapSetTextureSize cubemap texsize;
            SO3ObjectSetPosition cubemap [xpos ypos zpos];
            SO3ObjectSetOrientation cubemap [xang yang zang wang];
            SO3ObjectSetScale cubemap [xscale yscale zscale];
  
            //SO3ObjectSetRenderingDistance cubemap renderdistance;
          )
        )
        // REFLECTIONMAP
        else if etype == iTypeReflectionMap then
        (
          let V3DgetObjectByName sessionstr ename -> reflectionmap in
          let XMLgetParam emark "material" -> matname in
          let atoi XMLgetParam emark "technique" -> mattech in
          let if mattech == nil then 0 else mattech -> mattech in
          let atoi XMLgetParam emark "pass" -> matpass in
          let if matpass == nil then 0 else matpass -> matpass in
          let atoi XMLgetParam emark "texunit" -> mattex in
          let if mattex == nil then 0 else mattex -> mattex in
          let atoi XMLgetParam emark "texsize" -> texsize in
          let if texsize == nil then 256 else texsize -> texsize in
          let XMLgetBoolParam emark "enable" -> enable in
          let atof XMLgetParam emark "renderingDistance" -> renderdistance in
          let XMLgetBoolParam emark "revertClipPlane" -> revertclip in
  
          let XMLgetMarkByValueFromMarkSons emark "position" -> nodeposstr in
          let atof XMLgetParam nodeposstr "x" -> xpos in
          let atof XMLgetParam nodeposstr "y" -> ypos in
          let atof XMLgetParam nodeposstr "z" -> zpos in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> noderotstr in
          let atof XMLgetParam noderotstr "qx" -> xang in
          let atof XMLgetParam noderotstr "qy" -> yang in
          let atof XMLgetParam noderotstr "qz" -> zang in
          let atof XMLgetParam noderotstr "qw" -> wang in
          let XMLgetMarkByValueFromMarkSons emark "scale" -> nodescalestr in
          let atof XMLgetParam nodescalestr "x" -> xscale in
          let atof XMLgetParam nodescalestr "y" -> yscale in
          let atof XMLgetParam nodescalestr "z" -> zscale in
          (
            if father == nil then nil else
              SO3ObjectLink reflectionmap father;
            
            SO3DynamicReflectionMapSetEnable reflectionmap 0;
            SO3DynamicReflectionMapSetRevertClipPlane reflectionmap revertclip;
            SO3DynamicReflectionMapSetTextureSize reflectionmap texsize;
            SO3ObjectSetPosition reflectionmap [xpos ypos zpos];
            SO3ObjectSetOrientation reflectionmap [xang yang zang wang];
            SO3ObjectSetScale reflectionmap [xscale yscale zscale];
  
            //SO3ObjectSetRenderingDistance reflectionmap renderdistance;
          )
        )
        // ANIMS
        else if etype == iTypeAnim then
        (
          let V3DgetAnimationByName sessionstr ename -> animstr in
          let XMLgetParam emark "name" -> animname in
          let XMLgetParam emark "type" -> animtype in
          let XMLgetBoolParam emark "enable" -> animstate in
          let XMLgetBoolParam emark "loop" -> animloop in
          let getOgreAnimationInterpolationType (XMLgetParam emark "interpolationMode") -> animintmode in
          let getOgreAnimationRotInterpolationType (XMLgetParam emark "rotationInterpolationMode") -> animintrotmode in
          let atof XMLgetParam emark "length" -> animlength in
          let atof XMLgetParam emark "speed" -> animspeed in
          let atof XMLgetParam emark "weight" -> animweight in
          let XMLgetBoolParam emark "skipFrame" -> skipFrame in
          let if (XMLgetParam emark "skipFrame") == nil then 1 else skipFrame -> skipFrame in
          
          let if animweight == nil then 1.0 else animweight -> animweight in
          let if (animspeed == nil) then fDefaultAnimationSpeed else animspeed -> animspeed in
          (
            V3DresetAnimation animstr;
            V3DsetAnimationWeight animstr animweight;
            V3DsetAnimationLoop animstr animloop;
            V3DsetAnimationSpeed animstr animspeed;
            V3DanimationSetDefaultSkipFrame animstr skipFrame;
            
            if (!strcmp animtype "morph") || (!strcmp animtype "skeleton") then nil else
            (
              V3DsetAnimationInterpolationMode animstr animintmode;
              V3DsetAnimationRotInterpolationMode animstr animintrotmode;
            );
          );
          0;
        )
        // SKYBOX
        else if etype == iTypeSkyBox then
        (
          let XMLgetBoolParam emark "enable" -> skyboxenable in
          let XMLgetParam emark "material" -> skyboxmat in
          let atof XMLgetParam emark "distance" -> skyboxdistance in
          let XMLgetBoolParam emark "drawFirst" -> skyboxdrawfirst in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> skyboxrotstr in
          let atof XMLgetParam skyboxrotstr "qx" -> skyboxqx in
          let atof XMLgetParam skyboxrotstr "qy" -> skyboxqy in
          let atof XMLgetParam skyboxrotstr "qz" -> skyboxqz in
          let atof XMLgetParam skyboxrotstr "qw" -> skyboxqw in
          (
            let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skyboxmat) -> skymat in
              SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat skyboxdistance [skyboxqx skyboxqy skyboxqz skyboxqw] resgroup skyboxenable skyboxdrawfirst;
          );
          0;
        )
        // SKYDOME
        else if etype == iTypeSkyDome then
        (
          let XMLgetBoolParam emark "enable" -> skydomeenable in
          let XMLgetParam emark "material" -> skydomemat in
          let atof XMLgetParam emark "distance" -> skydomedistance in
          let atof XMLgetParam emark "tiling" -> skydometiling in
          let atof XMLgetParam emark "curvature" -> skydomecurve in
          let atoi XMLgetParam emark "xSegments" -> skydomexseg in
          let atoi XMLgetParam emark "ySegments" -> skydomeyseg in
          let XMLgetBoolParam emark "drawFirst" -> skydomedrawfirst in
          let XMLgetMarkByValueFromMarkSons emark "rotation" -> skydomerotstr in
          let atof XMLgetParam skydomerotstr "qx" -> skydomeqx in
          let atof XMLgetParam skydomerotstr "qy" -> skydomeqy in
          let atof XMLgetParam skydomerotstr "qz" -> skydomeqz in
          let atof XMLgetParam skydomerotstr "qw" -> skydomeqw in
          (
            let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skydomemat) -> skymat in
              SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat skydomedistance [skydomeqx skydomeqy skydomeqz skydomeqw] (if skydomecurve == nil then 0.0 else skydomecurve) skydometiling skydomexseg skydomeyseg (-1) resgroup skydomeenable skydomedrawfirst;
          );
          0;
        )
        // SKYPLANE
        else if etype == iTypeSkyPlane then
        (
          let XMLgetBoolParam emark "enable" -> skyplanenable in
          let XMLgetParam emark "material" -> skyplanmat in
          let atof XMLgetParam emark "planeX" -> skyplanx in
          let atof XMLgetParam emark "planeY" -> skyplany in
          let atof XMLgetParam emark "planeZ" -> skyplanz in
          let atof XMLgetParam emark "planeD" -> skypland in
          let atof XMLgetParam emark "scale" -> skyplanscale in
          let atof XMLgetParam emark "bow" -> skyplanbow in
          let atof XMLgetParam emark "tiling" -> skyplantiling in
          let atoi XMLgetParam emark "xSegments" -> skyplanxseg in
          let atoi XMLgetParam emark "ySegments" -> skyplanyseg in  
          let XMLgetBoolParam emark "drawFirst" -> skyplandrawfirst in
          (
            let (SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup skyplanmat) -> skymat in      
              SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat skypland [skyplanx skyplany skyplanz] skyplanscale skyplantiling (if skyplanbow == nil then 0.0 else skyplanbow) skyplanxseg skyplanyseg resgroup skyplanenable skyplandrawfirst;
          );
          0;
        )
        // COMPOSITOR
        else if etype == iTypeCompositor then
        (
          let XMLgetParam emark "name" -> compname in
          (
            V3DunRegisterCompositor defaultviewportstr compname;
            SO3ViewportRemoveCompositor defaultviewportstr.V3D_viewport compname;
          );
          0;
        )
        else nil;
      );
      set lsgi = lsgi + 1;
    );
  );
  0;;


fun loadBonesChilds(sessionstr, bone, xmlfather, treenode, groupmark)=
  let SO3ObjectGetName bone -> bonename in
  let cutDotName bonename -> [id name] in
  let SO3ObjectGetPosition bone -> [rbxp rbyp rbzp] in
  let SO3ObjectGetOrientation bone -> [rbxq rbyq rbzq rbwq] in
  let SO3ObjectGetScale bone -> [rbxs rbys rbzs] in
  let XMLaddMark xmlEditSceneFile "bone" xmlfather ["id" id]::["name" name]::nil nil -> bonexmlstr in
  let addGraphItem strcatn name::" #"::id::nil bonename iTypeBone nil bonexmlstr nil groupmark sTreeBitmapBone treenode 0 0 -> treebone in
  let SO3ObjectGetChildren bone -> lchild in
  (
    XMLaddMark xmlEditSceneFile "scale" bonexmlstr ["x" (XMLgetShortFloatToString rbxs)]::["y" (XMLgetShortFloatToString rbys)]::["z" (XMLgetShortFloatToString rbzs)]::nil nil;
    XMLaddMark xmlEditSceneFile "position" bonexmlstr ["x" (XMLgetShortFloatToString rbxp)]::["y" (XMLgetShortFloatToString rbyp)]::["z" (XMLgetShortFloatToString rbzp)]::nil nil;
    XMLaddMark xmlEditSceneFile "rotation" bonexmlstr ["qx" (XMLgetShortFloatToString rbxq)]::["qy" (XMLgetShortFloatToString rbyq)]::["qz" (XMLgetShortFloatToString rbzq)]::["qw" (XMLgetShortFloatToString rbwq)]::nil nil;
    
    while lchild != nil do
    (
      loadBonesChilds sessionstr (hd lchild) bonexmlstr treebone groupmark;    
      set lchild = tl lchild;
    );
  );
  0;;


fun loadBonesChildsFromXos(sessionstr, bone, xmlfather, treenode, groupstr, meshstr, import)=
  let SO3ObjectGetName bone -> bonename in
  let cutDotName bonename -> [id name] in
  let SO3ObjectGetPosition bone -> [rbxp rbyp rbzp] in
  let SO3ObjectGetOrientation bone -> [rbxq rbyq rbzq rbwq] in
  let SO3ObjectGetScale bone -> [rbxs rbys rbzs] in
  let XMLgetMarkByValueAndParamValueFromMarkSons meshstr "bone" "name" name -> srcbonexml in
  let XMLgetParam srcbonexml "alias" -> alias in
  let XMLaddMark xmlEditSceneFile "bone" xmlfather ["id" id]::["name" name]::["alias" alias]::nil nil -> bonexmlstr in
  let addGraphItem strcatn name::" #"::id::nil bonename iTypeBone alias bonexmlstr nil groupstr.GRP_xmlMark sTreeBitmapBone treenode 0 0 -> treebone in
  let SO3ObjectGetChildren bone -> lchild in
  
  let XMLgetMarkByValueFromMarkSons srcbonexml "position" -> nodeposstr in
  let if nodeposstr == nil then rbxp else atof XMLgetParam nodeposstr "x" -> rbxp in
  let if nodeposstr == nil then rbyp else atof XMLgetParam nodeposstr "y" -> rbyp in
  let if nodeposstr == nil then rbzp else atof XMLgetParam nodeposstr "z" -> rbzp in
  let XMLgetMarkByValueFromMarkSons srcbonexml "rotation" -> noderotstr in
  let if noderotstr == nil then rbxq else atof XMLgetParam noderotstr "qx" -> rbxq in
  let if noderotstr == nil then rbyq else atof XMLgetParam noderotstr "qy" -> rbyq in
  let if noderotstr == nil then rbzq else atof XMLgetParam noderotstr "qz" -> rbzq in
  let if noderotstr == nil then rbwq else atof XMLgetParam noderotstr "qw" -> rbwq in
  let XMLgetMarkByValueFromMarkSons srcbonexml "scale" -> nodescalestr in
  let if nodescalestr == nil then rbxs else atof XMLgetParam nodescalestr "x" -> rbxs in
  let if nodescalestr == nil then rbys else atof XMLgetParam nodescalestr "y" -> rbys in
  let if nodescalestr == nil then rbzs else atof XMLgetParam nodescalestr "z" -> rbzs in
  (
    SO3ObjectSetPosition bone [rbxp rbyp rbzp];
    SO3ObjectSetOrientation bone [rbxq rbyq rbzq rbwq];
    SO3ObjectSetScale bone [rbxs rbys rbzs];
    
    XMLaddMark xmlEditSceneFile "scale" bonexmlstr ["x" (XMLgetShortFloatToString rbxs)]::["y" (XMLgetShortFloatToString rbys)]::["z" (XMLgetShortFloatToString rbzs)]::nil nil;
    XMLaddMark xmlEditSceneFile "position" bonexmlstr ["x" (XMLgetShortFloatToString rbxp)]::["y" (XMLgetShortFloatToString rbyp)]::["z" (XMLgetShortFloatToString rbzp)]::nil nil;
    XMLaddMark xmlEditSceneFile "rotation" bonexmlstr ["qx" (XMLgetShortFloatToString rbxq)]::["qy" (XMLgetShortFloatToString rbyq)]::["qz" (XMLgetShortFloatToString rbzq)]::["qw" (XMLgetShortFloatToString rbwq)]::nil nil;
    
    //physics
    physicsLoadOsNode srcbonexml bonexmlstr bone sessionstr;
    
    if !import then nil else
      set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam srcbonexml "id")::"."::name::nil) (strcatn id::"."::name::nil)]::groupstr.GRP_lTmpFunctionsImport;

    while lchild != nil do
    (
      loadBonesChildsFromXos sessionstr (hd lchild) bonexmlstr treebone groupstr srcbonexml import;    
      set lchild = tl lchild;
    );
  );
  0;;


fun loadOsGraph(groupstr, viewstr, srcnodemark, destfathermark, destgroup, father, treefather, import)=
  let getGroupName currentProject destgroup -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let if import == 2 then set import = 1 else 0 -> fselect in
  (
    // SHELL
    let XMLgetMarksByValueFromMarkSons srcnodemark "shell" -> lnodexml in
    let sizelist lnodexml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lnodexml i -> nodexml in
      let if import then nil else XMLgetParam nodexml "id" -> id in
      let XMLgetParam nodexml "name" -> nodename in
      let XMLgetParam nodexml "alias" -> alias in
      let XMLgetBoolParam nodexml "hidden" -> nodehidden in
      let if nodehidden == nil then 0 else nodehidden -> nodehidden in
      let XMLgetBoolParam nodexml "staticGeometry" -> nodestaticgeometry in
      let if nodestaticgeometry == nil then 0 else nodestaticgeometry -> nodestaticgeometry in
      let XMLgetMarkByValueFromMarkSons nodexml "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons nodexml "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons nodexml "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      
      //keep for compatibility
      let XMLgetMarkByValueFromMarkSons nodexml "body" -> bodystr in
      let XMLgetBoolParam bodystr "enable" -> bodyenable in 
      
      let itoa getNewSceneIndex (atoi id) -> id in
      let SO3SceneNodeCreate (V3DgetSession sessionstr) (strcatn id::"."::nodename::nil) -> shell in 
      (
        if shell == nil then
        (
          addLogMessage strcatn "Error while adding the node named \""::nodename::"\", verify if the node name already exist in scene."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "shell" destfathermark ["id" id]::["name" nodename]::["alias" alias]::["hidden" (XMLgetBoolString nodehidden)]::["staticGeometry" (XMLgetBoolString nodestaticgeometry)]::nil nil -> shellxmlstr in
        let addGraphItem strcatn nodename::" #"::id::nil (strcatn id::"."::nodename::nil) iTypeNode alias (if shellxmlstr == nil then nodexml else shellxmlstr) nil destgroup sTreeBitmapNode treefather bodyenable nodestaticgeometry -> treenode in
        (
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam nodexml "id")::"."::nodename::nil) (strcatn id::"."::nodename::nil)]::groupstr.GRP_lTmpFunctionsImport;
            
          if father == nil then nil else
            SO3ObjectLink shell father;
          
          SO3ObjectSetPosition shell [xpos ypos zpos];
          SO3ObjectSetOrientation shell [xang yang zang wang];
          SO3ObjectSetScale shell [xscale yscale zscale];
          
          if shellxmlstr == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" shellxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" shellxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" shellxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;          
          );
          
          V3DshowObjectHelper viewstr sessionstr shell iTypeNode 1;
          
          //physics
          physicsLoadOsNode nodexml shellxmlstr shell sessionstr;
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
            
          loadOsGraph groupstr viewstr nodexml shellxmlstr destgroup shell treenode import;
          
          //do it after load
          SO3ObjectSetVisible shell !nodehidden 0;
        );
      );
      
      set i = i + 1;
    );
  
    // ENTITY
    let XMLgetMarksByValueFromMarkSons srcnodemark "mesh" -> lnodexml in
    let sizelist lnodexml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lnodexml i -> meshstr in
      let if import then nil else XMLgetParam meshstr "id" -> id in
      let XMLgetParam meshstr "name" -> meshname in
      let XMLgetParam meshstr "alias" -> alias in
      let strlowercase XMLgetParam meshstr "path" -> meshres in
      let strlowercase XMLgetParam meshstr "skeletonlink" -> sklpath in
      let XMLgetBoolParam meshstr "indexMaterials" -> indexmat in
      let XMLgetBoolParam meshstr "castShadows" -> meshcastshadow in
      let XMLgetBoolParam meshstr "hidden" -> meshhidden in
      let XMLgetBoolParam meshstr "staticGeometry" -> meshstaticgeometry in
      let XMLgetBoolParam meshstr "receiveShadows" -> meshreceiveshadow in
      let atof XMLgetParam meshstr "renderingDistance" -> meshrenderdistance in
      let htoi XMLgetParam meshstr "visibilityFlags" -> meshvisibilityflags in
      let if meshvisibilityflags == nil then 0xFFFFFFFF else meshvisibilityflags -> meshvisibilityflags in
      
      let XMLgetMarkByValueFromMarkSons meshstr "subentities" -> subentitiesstr in
      
      let XMLgetMarkByValueFromMarkSons meshstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons meshstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons meshstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      
      //keep for compatibility
      let XMLgetMarkByValueFromMarkSons meshstr "body" -> bodystr in
      let XMLgetBoolParam bodystr "enable" -> bodyenable in 
      
      let XMLgetMarkByValueFromMarkSons meshstr "body" -> bodystr in
      let XMLgetParam bodystr "type" -> bodytype in
      let XMLgetParam bodystr "material" -> bodymatname in
      let atof XMLgetParam bodystr "mass" -> bodymass in
      let XMLgetBoolParam bodystr "enable" -> bodyenable in
      let if ((XMLgetParam bodystr "autoSleep") == nil) then 1 else XMLgetBoolParam bodystr "autoSleep" -> bodyautosleep in
      let XMLgetBoolParam bodystr "continuousColl" -> bodycontinuous in
      let XMLgetMarkByValueFromMarkSons bodystr "damping" -> dampingstr in
      let atof XMLgetParam dampingstr "linear" -> bodydampingl in
      let atof XMLgetParam dampingstr "x" -> bodydampingx in
      let atof XMLgetParam dampingstr "y" -> bodydampingy in
      let atof XMLgetParam dampingstr "z" -> bodydampingz in
      
      let strlowercase OGMATfindResourcePath meshres lResourcesPath -> meshpath in
      let itoa getNewSceneIndex (atoi id) -> id in
      let if meshpath != nil then 
            SO3SceneLoadEntity (V3DgetSession sessionstr) resgroup (strcatn id::"."::meshname::nil) _checkpack meshpath
          else nil
      -> mesh in
      (
        if mesh == nil then
        (
          addLogMessage strcatn "Error while adding the mesh named \""::meshname::"\" from "::meshres::", verify that the file exist."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "mesh" destfathermark ["id" id]::["name" meshname]::["alias" alias]::["path" meshpath]::["castShadows" (XMLgetBoolString meshcastshadow)]::["receiveShadows" (XMLgetBoolString meshreceiveshadow)]::["renderingDistance" (XMLgetShortFloatToString meshrenderdistance)]::["indexMaterials" (XMLgetBoolString indexmat)]::["hidden" (XMLgetBoolString meshhidden)]::["staticGeometry" (XMLgetBoolString meshstaticgeometry)]::["visibilityFlags" itoh meshvisibilityflags]::(if sklpath == nil then nil else ["skeletonlink" sklpath])::nil nil -> meshxmlstr in
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "subentities" meshxmlstr nil nil -> meshxmlsubstr in
        let addGraphItem (strcatn meshname::" #"::id::nil) (strcatn id::"."::meshname::nil) iTypeEntity alias (if meshxmlstr == nil then meshstr else meshxmlstr) meshpath destgroup sTreeBitmapEntity treefather bodyenable meshstaticgeometry -> treenode in
        (
          SO3ObjectSetPosition mesh [xpos ypos zpos];
          SO3ObjectSetOrientation mesh [xang yang zang wang];
          SO3ObjectSetScale mesh [xscale yscale zscale];
          SO3ObjectSetRenderingDistance mesh meshrenderdistance;
          SO3EntitySetVisibilityFlags mesh meshvisibilityflags;
          
          if father == nil then nil else
            SO3ObjectLink mesh father;
            
          if (_checkpack sklpath) == nil then nil else
          (
            V3DaddResource sessionstr sklpath resgroup SO3_RESOURCE_SKELETON;
            SO3EntityAttachSkeleton mesh _checkpack sklpath;
            addOsSceneResource xmlEditSceneFile destgroup sklpath SO3_RESOURCE_SKELETON;
            
            let SO3GetRootBonesFromMesh mesh -> rootbones in
            let sizelist rootbones -> nbrootbones in
            let 0 -> j in
            while j < nbrootbones do
            (
              loadBonesChildsFromXos sessionstr (nth_list rootbones j) meshxmlstr treenode groupstr meshstr import;

              set j = j + 1;
            );
          );

          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam meshstr "id")::"."::meshname::nil) (strcatn id::"."::meshname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          let SO3EntityNumOfSubEntities mesh -> nbsub in
          let SO3EntityMaterialList mesh -> ldefmat in
          let 0 -> j in
          while j < nbsub do
          (
            let XMLgetMarkByValueAndParamValueFromMark subentitiesstr "subentity" "index" (itoa j) -> elem in
            let SO3MaterialGetName (nth_list ldefmat j) -> defmat in
            let if (elem != nil) then XMLgetParam elem "materialName" else defmat -> submatname in
            let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup submatname -> submat in
            (
              XMLaddMark xmlEditSceneFile "subentity" meshxmlsubstr ["index" (itoa j)]::["materialName" submatname]::["defaultMaterial" defmat]::nil nil;
              SO3EntitySetMaterial mesh submat j;
            );
            set j = j + 1;
          );
          
          if meshxmlstr == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" meshxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" meshxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" meshxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;          
          );
          
          //physics
          physicsLoadOsNode meshstr meshxmlstr mesh sessionstr;
          
          V3DaddResource sessionstr meshpath resgroup SO3_RESOURCE_MESH;
          addOsSceneResource xmlEditSceneFile destgroup meshpath SO3_RESOURCE_MESH;
          
          SO3ObjectSetCastShadows mesh meshcastshadow;
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr meshstr meshxmlstr destgroup mesh treenode import;
          
          //do it after load
          SO3ObjectSetVisible mesh !meshhidden 0;
        );
      );
      
      set i = i + 1;
    );
    
    // LIGHT
    let XMLgetMarksByValueFromMarkSons srcnodemark "light" -> lnodexml in
    let sizelist lnodexml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lnodexml i -> lightstr in
      let getOgreMaxLightType (XMLgetParam lightstr "type") -> lighttype in
      let if import then nil else XMLgetParam lightstr "id" -> id in
      let XMLgetParam lightstr "name" -> lightname in
      let XMLgetParam lightstr "alias" -> alias in
      let XMLgetBoolParam lightstr "castShadows" -> lightcastshadow in
      let atof XMLgetParam lightstr "power" -> lightpower in
      let if (lightpower == nil) then 1.0 else lightpower -> lightpower in
      let XMLgetParam lightstr "enable" -> slightenable in
      let if slightenable == nil then 1 else (XMLgetBoolParam lightstr "enable") -> lightenable in
      
      let XMLgetMarkByValueFromMarkSons lightstr "colourDiffuse" -> lightdiffusestr in
      let make_rgba (ftoi ((atof XMLgetParam lightdiffusestr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "b") *. 255.0)) 0 -> lightdiffusecolor in
      
      let XMLgetMarkByValueFromMarkSons lightstr "colourSpecular" -> lightspecularstr in
      let make_rgba (ftoi ((atof XMLgetParam lightspecularstr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "b") *. 255.0)) 0 -> lightspecularcolor in
      
      let XMLgetMarkByValueFromMarkSons lightstr "lightAttenuation" -> lightattenuationstr in
      let atof XMLgetParam lightattenuationstr "range" -> lightrange in
      
      let XMLgetMarkByValueFromMarkSons lightstr "lightRange" -> lightrangestr in
      let atof XMLgetParam lightrangestr "inner" -> lightinner in
      let atof XMLgetParam lightrangestr "outer" -> lightouter in 
          
      let XMLgetMarkByValueFromMarkSons lightstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons lightstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons lightstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
  
      let itoa getNewSceneIndex (atoi id) -> id in
      let SO3LightCreate (V3DgetSession sessionstr) (strcatn id::"."::lightname::nil) -> light in
      (
        if light == nil then
        (
          addLogMessage strcatn "Error while adding the light named \""::lightname::"\", verify if the light name already exist in scene."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "light" destfathermark ["id" id]::["name" lightname]::["type" (getOgreMaxLightByType lighttype)]::["alias" alias]::["castShadows" (XMLgetBoolString lightcastshadow)]::["power" (XMLgetShortFloatToString lightpower)]::["enable" XMLgetBoolString lightenable]::nil nil -> lightxmlstr in
        let addGraphItem strcatn lightname::" #"::id::nil (strcatn id::"."::lightname::nil) iTypeLight alias (if lightxmlstr == nil then lightstr else lightxmlstr) nil destgroup sTreeBitmapLight treefather lightenable 0 -> treenode in
        (
          // remove default light
          V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultLight sessionstr) nil 0;
          V3DuseDefaultLight sessionstr 0;
          set bLastDefaultLightState = 0;
          
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam lightstr "id")::"."::lightname::nil) (strcatn id::"."::lightname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          if father == nil then nil else
            SO3ObjectLink light father;
          
          SO3ObjectSetPosition light [xpos ypos zpos];
          SO3ObjectSetOrientation light [xang yang zang wang];
          SO3ObjectSetScale light [xscale yscale zscale];
          
          if lightxmlstr == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" lightxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" lightxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" lightxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
            
            XMLaddMark xmlEditSceneFile "colourDiffuse" lightxmlstr ["r" (XMLgetParam lightdiffusestr "r")]::["g" (XMLgetParam lightdiffusestr "g")]::["b" (XMLgetParam lightdiffusestr "b")]::nil nil;
            XMLaddMark xmlEditSceneFile "colourSpecular" lightxmlstr  ["r" (XMLgetParam lightspecularstr "r")]::["g" (XMLgetParam lightspecularstr "g")]::["b" (XMLgetParam lightspecularstr "b")]::nil nil;
            XMLaddMark xmlEditSceneFile "lightAttenuation" lightxmlstr ["range" (XMLgetShortFloatToString lightrange)]::nil nil;
          );
                    
          SO3LightSetType light lighttype;
          SO3LightSetPowerScale light lightpower;
          SO3LightSetDiffuseColor light lightdiffusecolor;
          SO3LightSetSpecularColor light lightspecularcolor;
          SO3LightSetAttenuationAuto light lightrange;
          SO3ObjectSetCastShadows light lightcastshadow;
          SO3LightSetVisible light lightenable;
          V3DshowObjectHelper viewstr sessionstr light iTypeLight 1;
          
          if lightrangestr == nil then nil else
          (
            if lightxmlstr == nil then nil else
              XMLaddMark xmlEditSceneFile "lightRange" lightxmlstr ["inner" (XMLgetShortFloatToString lightinner)]::["outer" (XMLgetShortFloatToString lightouter)]::nil nil;
  
            SO3LightSetSpotInnerAngle light lightinner;
            SO3LightSetSpotOuterAngle light lightouter;
          );
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr lightstr lightxmlstr destgroup light treenode import;
        );
      );
      
      set i = i + 1;
    );
  
    // CAMERA
    let XMLgetMarksByValueFromMarkSons srcnodemark "camera" -> lnodexml in
    let sizelist lnodexml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lnodexml i -> camerastr in
      let if import then nil else XMLgetParam camerastr "id" -> id in
      let XMLgetParam camerastr "name" -> cameraname in
      let XMLgetParam camerastr "alias" -> alias in
      let atof XMLgetParam camerastr "fov" -> camerafov in
      let atof XMLgetParam camerastr "focalLenght" -> camerafocallength in
      let if camerafocallength == nil then 1.0 else camerafocallength -> camerafocallength in

      let XMLgetMarkByValueFromMarkSons camerastr "clipping" -> camclippingstr in
      let atof XMLgetParam camclippingstr "near" -> camclipnear in
      let atof XMLgetParam camclippingstr "far" -> camclipfar in
      
      let XMLgetMarkByValueFromMarkSons camerastr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons camerastr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons camerastr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      let itoa getNewSceneIndex (atoi id) -> id in
      let V3DaddCamera sessionstr (strcatn id::"."::cameraname::nil) -> camera in 
      (
        if camera == nil then
        (
          addLogMessage strcatn "Error while adding the camera named \""::cameraname::"\", verify if the camera name already exist in scene."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "camera" destfathermark ["id" id]::["name" cameraname]::["alias" alias]::["fov" (XMLgetShortFloatToString camerafov)]::["focalLenght" (XMLgetShortFloatToString camerafocallength)]::nil nil -> camxmlstr in
        let addGraphItem strcatn cameraname::" #"::id::nil (strcatn id::"."::cameraname::nil) iTypeCamera alias (if camxmlstr == nil then camerastr else camxmlstr) nil destgroup sTreeBitmapCamera treefather 0 0 -> treenode in
        (
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam camerastr "id")::"."::cameraname::nil) (strcatn id::"."::cameraname::nil)]::groupstr.GRP_lTmpFunctionsImport;

          if father == nil then nil else
            SO3ObjectLink camera father;
          
          SO3ObjectSetPosition camera [xpos ypos zpos];
          SO3ObjectSetOrientation camera [xang yang zang wang];
          SO3ObjectSetScale camera [xscale yscale zscale];
          
          if destfathermark == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" camxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" camxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" camxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
            XMLaddMark xmlEditSceneFile "clipping" camxmlstr ["near" (XMLgetShortFloatToString camclipnear)]::["far" (XMLgetShortFloatToString camclipfar)]::nil nil;
          );
          
          V3DsetCamera camera camerafocallength camerafov camclipnear camclipfar;
          V3DshowObjectHelper viewstr sessionstr camera iTypeCamera 1;
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr camerastr camxmlstr destgroup camera treenode import;
        );
      );
      
      set i = i + 1;
    );
    
    // PARTICLE
    let XMLgetMarksByValueFromMarkSons srcnodemark "particle" -> lpartxml in
    let sizelist lpartxml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lpartxml i -> partstr in
      let if import then nil else XMLgetParam partstr "id" -> id in
      let XMLgetParam partstr "name" -> partname in
      let XMLgetParam partstr "alias" -> alias in
      let XMLgetParam partstr "template" -> parttpl in
      let atof XMLgetParam partstr "speed" -> partspeed in
      let if partspeed == nil then 1.0 else partspeed -> partspeed in
      let atof (XMLgetParam partstr "renderingDistance") -> partrenderdistance in
      let if partrenderdistance == nil then 0.0 else partrenderdistance -> partrenderdistance in
      let XMLgetBoolParam partstr "enable" -> partenable in
      
      let XMLgetMarkByValueFromMarkSons partstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons partstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      
      // manage the case the xos has bad scale parameter on particle
      let XMLgetMarkByValueFromMarkSons partstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let if xscale == nil || xscale == 0.0 then 1.0 else xscale -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let if yscale == nil || yscale == 0.0 then 1.0 else yscale -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      let if zscale == nil || zscale == 0.0 then 1.0 else zscale -> zscale in
      
      let itoa getNewSceneIndex (atoi id) -> id in
      let V3DaddParticleSystem sessionstr (strcatn id::"."::partname::nil) parttpl -> partsystem in 
      (
        if partsystem == nil then
        (
          addLogMessage strcatn "Error while adding the particle system named \""::partname::"\", verify if the particle template exist in scene."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "particle" destfathermark ["id" id]::["name" partname]::["alias" alias]::["template" parttpl]::["speed" (XMLgetShortFloatToString partspeed)]::["renderingDistance" (XMLgetShortFloatToString partrenderdistance)]::["enable" (XMLgetBoolString partenable)]::nil nil -> partxmlstr in
        let addGraphItem strcatn partname::" #"::id::nil (strcatn id::"."::partname::nil) iTypeParticle alias (if partxmlstr == nil then partstr else partxmlstr) nil destgroup sTreeBitmapParticle treefather partenable 0 -> treenode in
        (
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam partstr "id")::"."::partname::nil) (strcatn id::"."::partname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          if father == nil then nil else
            SO3ObjectLink partsystem father;
          
          SO3ObjectSetPosition partsystem [xpos ypos zpos];
          SO3ObjectSetOrientation partsystem [xang yang zang wang];
          SO3ObjectSetScale partsystem [xscale yscale zscale];
          
          if destfathermark == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" partxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" partxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" partxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
          );
          
          SO3ParticleSystemSetEnable partsystem 0;
          SO3ParticleSystemSetSpeedFactor partsystem partspeed;
          SO3ParticleSystemClear partsystem;
          SO3ObjectSetRenderingDistance partsystem partrenderdistance;
          V3DshowObjectHelper viewstr sessionstr partsystem iTypeParticle 1;
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr partstr partxmlstr destgroup partsystem treenode import;
        );
      );
      
      set i = i + 1;
    );
    
    // CUBEMAP
    let XMLgetMarksByValueFromMarkSons srcnodemark "cubemap" -> lcubemapxml in
    let sizelist lcubemapxml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lcubemapxml i -> cubemapstr in
      let if import then nil else XMLgetParam cubemapstr "id" -> id in
      let XMLgetParam cubemapstr "name" -> cubemapname in
      let XMLgetParam cubemapstr "alias" -> alias in
      let XMLgetParam cubemapstr "material" -> matname in
      let atoi XMLgetParam cubemapstr "technique" -> mattech in
      let if mattech == nil then 0 else mattech -> mattech in
      let atoi XMLgetParam cubemapstr "pass" -> matpass in
      let if matpass == nil then 0 else matpass -> matpass in
      let atoi XMLgetParam cubemapstr "texunit" -> mattex in
      let if mattex == nil then 0 else mattex -> mattex in
      let atoi XMLgetParam cubemapstr "texsize" -> texsize in
      let if texsize == nil then 256 else texsize -> texsize in
      let XMLgetBoolParam cubemapstr "enable" -> cubemapenable in
      let atof XMLgetParam cubemapstr "renderingDistance" -> renderdistance in
      let XMLgetBoolParam cubemapstr "autoUpdate" -> autoupdate in
      
      let XMLgetMarkByValueFromMarkSons cubemapstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons cubemapstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons cubemapstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      
      let itoa getNewSceneIndex (atoi id) -> id in
      let SO3DynamicCubeMapCreate (V3DgetSession sessionstr) (strcatn id::"."::cubemapname::nil) -> cubemap in 
      (
        if cubemap == nil then
        (
          addLogMessage strcatn "Error while adding the Dynamique cube map named \""::cubemapname::"\", verify if your system support it and the material setting."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "cubemap" destfathermark ["id" id]::["name" cubemapname]::["alias" alias]::["material" matname]::["technique" (itoa mattech)]::["pass" (itoa matpass)]::["texunit" (itoa mattex)]::["texsize" (itoa texsize)]::["renderingDistance" (XMLgetShortFloatToString renderdistance)]::["enable" (XMLgetBoolString cubemapenable)]::["autoUpdate" (XMLgetBoolString autoupdate)]::nil nil -> cubemapxmlstr in
        let addGraphItem strcatn cubemapname::" #"::id::nil (strcatn id::"."::cubemapname::nil) iTypeCubeMap alias (if cubemapxmlstr == nil then cubemapstr else cubemapxmlstr) nil destgroup sTreeBitmapCubeMap treefather cubemapenable 0 -> treenode in
        (
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam cubemapstr "id")::"."::cubemapname::nil) (strcatn id::"."::cubemapname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          if father == nil then nil else
            SO3ObjectLink cubemap father;
          
          SO3ObjectSetPosition cubemap [xpos ypos zpos];
          SO3ObjectSetOrientation cubemap [xang yang zang wang];
          SO3ObjectSetScale cubemap [xscale yscale zscale];
          
          SO3DynamicCubeMapSetEnable cubemap 0;
          SO3DynamicCubeMapSetAutoUpdate cubemap autoupdate;
          SO3DynamicCubeMapSetTextureSize cubemap texsize;
          let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> material in
            SO3DynamicCubeMapSetTargetMaterial cubemap material mattech matpass mattex;
          
          if destfathermark == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" cubemapxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" cubemapxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" cubemapxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
          );
          
          //SO3ObjectSetRenderingDistance cubemap renderdistance;
          V3DshowObjectHelper viewstr sessionstr cubemap iTypeCubeMap 1;
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr cubemapstr cubemapxmlstr destgroup cubemap treenode import;
        );
      );
      
      set i = i + 1;
    );
    
    // REFLECTIONMAP
    let XMLgetMarksByValueFromMarkSons srcnodemark "reflectionmap" -> lreflectionmapxml in
    let sizelist lreflectionmapxml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lreflectionmapxml i -> reflectionmapstr in
      let if import then nil else XMLgetParam reflectionmapstr "id" -> id in
      let XMLgetParam reflectionmapstr "name" -> reflectionmapname in
      let XMLgetParam reflectionmapstr "alias" -> alias in
      let XMLgetParam reflectionmapstr "material" -> matname in
      let atoi XMLgetParam reflectionmapstr "technique" -> mattech in
      let if mattech == nil then 0 else mattech -> mattech in
      let atoi XMLgetParam reflectionmapstr "pass" -> matpass in
      let if matpass == nil then 0 else matpass -> matpass in
      let atoi XMLgetParam reflectionmapstr "texunit" -> mattex in
      let if mattex == nil then 0 else mattex -> mattex in
      let atoi XMLgetParam reflectionmapstr "texsize" -> texsize in
      let if texsize == nil then 256 else texsize -> texsize in
      let XMLgetBoolParam reflectionmapstr "enable" -> reflectionmapenable in
      let atof XMLgetParam reflectionmapstr "renderingDistance" -> renderdistance in
      let XMLgetBoolParam reflectionmapstr "revertClipPlane" -> revertclip in
      
      let XMLgetMarkByValueFromMarkSons reflectionmapstr "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let XMLgetMarkByValueFromMarkSons reflectionmapstr "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let XMLgetMarkByValueFromMarkSons reflectionmapstr "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      
      let itoa getNewSceneIndex (atoi id) -> id in
      
      let V3DgetDefaultViewport viewstr -> viewport in
      let SO3DynamicReflectionMapCreate (V3DgetSession sessionstr) viewport.V3D_viewport (strcatn id::"."::reflectionmapname::nil) -> reflectionmap in 
      (
        if reflectionmap == nil then
        (
          addLogMessage strcatn "Error while adding the Dynamique reflection map named \""::reflectionmapname::"\", verify if your system support it and the material setting."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "reflectionmap" destfathermark ["id" id]::["name" reflectionmapname]::["alias" alias]::["material" matname]::["technique" (itoa mattech)]::["pass" (itoa matpass)]::["texunit" (itoa mattex)]::["texsize" (itoa texsize)]::["renderingDistance" (XMLgetShortFloatToString renderdistance)]::["enable" (XMLgetBoolString reflectionmapenable)]::["revertClipPlane" (XMLgetBoolString revertclip)]::nil nil -> reflectionmapxmlstr in
        let addGraphItem strcatn reflectionmapname::" #"::id::nil (strcatn id::"."::reflectionmapname::nil) iTypeReflectionMap alias (if reflectionmapxmlstr == nil then reflectionmapstr else reflectionmapxmlstr) nil destgroup sTreeBitmapReflectionMap treefather reflectionmapenable 0 -> treenode in
        (
          if !import then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam reflectionmapstr "id")::"."::reflectionmapname::nil) (strcatn id::"."::reflectionmapname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          if father == nil then nil else
            SO3ObjectLink reflectionmap father;
          
          SO3ObjectSetPosition reflectionmap [xpos ypos zpos];
          SO3ObjectSetOrientation reflectionmap [xang yang zang wang];
          SO3ObjectSetScale reflectionmap [xscale yscale zscale];
          
          SO3DynamicReflectionMapSetEnable reflectionmap 0;
          SO3DynamicReflectionMapSetRevertClipPlane reflectionmap revertclip;
          SO3DynamicReflectionMapSetTextureSize reflectionmap texsize;
          let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> material in
            SO3DynamicReflectionMapSetTargetMaterial reflectionmap material mattech matpass mattex;
          
          if destfathermark == nil then nil else
          (
            XMLaddMark xmlEditSceneFile "scale" reflectionmapxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" reflectionmapxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" reflectionmapxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
          );
          
          //SO3ObjectSetRenderingDistance reflectionmap renderdistance;
          V3DshowObjectHelper viewstr sessionstr reflectionmap iTypeReflectionMap 1;
          
          if !fselect then nil else
            selEdCtrlTreeItem ctrlSceneTree treenode;
          
          loadOsGraph groupstr viewstr reflectionmapstr reflectionmapxmlstr destgroup reflectionmap treenode import;
        );
      );
      
      set i = i + 1;
    );
    
    // ANIMS
    let XMLgetMarkByValueFromMarkSons srcnodemark "animations" -> animsmark in
    let XMLgetMarksByValueFromMarkSons animsmark "animation" -> lanimmarks in
    let if animsmark == nil || destfathermark == nil then nil else XMLaddMark xmlEditSceneFile "animations" destfathermark nil nil -> targetanimsmark in
    let sizelist lanimmarks -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lanimmarks i -> animmark in
      let if import then nil else XMLgetParam animmark "id" -> id in
      let XMLgetParam animmark "name" -> animname in
      let XMLgetParam animmark "alias" -> alias in
      let XMLgetParam animmark "type" -> animtype in
      let XMLgetBoolParam animmark "enable" -> animstate in
      let XMLgetBoolParam animmark "loop" -> animloop in
      let getOgreAnimationInterpolationType (XMLgetParam animmark "interpolationMode") -> animintmode in
      let getOgreAnimationRotInterpolationType (XMLgetParam animmark "rotationInterpolationMode") -> animintrotmode in
      let atof XMLgetParam animmark "length" -> animlength in
      let atof XMLgetParam animmark "speed" -> animspeed in
      let atof XMLgetParam animmark "weight" -> animweight in
      let XMLgetBoolParam animmark "skipFrame" -> skipFrame in
      let if (XMLgetParam animmark "skipFrame") == nil then 1 else skipFrame -> skipFrame in
      let if animweight == nil then 1.0 else animweight -> animweight in
      let if (animspeed == nil) then fDefaultAnimationSpeed else animspeed -> animspeed in
      let if import then animname else (strcatn id::"."::animname::nil) -> curanimname in
      let itoa getNewSceneIndex (atoi id) -> id in
      let if (!strcmp animtype "morph") || (!strcmp animtype "skeleton") then
          let SO3ObjectGetAnimation father animname -> morphanim in
            V3DaddMorphAnimation sessionstr morphanim father (atoi id) animname (strcatn id::"."::animname::nil) animspeed animweight animstate animloop
          else
            V3DaddAnimation sessionstr father (atoi id) animname (strcatn id::"."::animname::nil) animlength animspeed animweight animstate animloop animintmode animintrotmode
      -> animstr in
      (
        if animstr == nil then
        (
          addLogMessage strcatn "Error while adding the animation named \""::animname::"\", verify if the animation name already exist in scene."::nil;
          0;
        )
        else
        let if destfathermark == nil then nil else 
          if (!strcmp animtype "morph") || (!strcmp animtype "skeleton") then
            XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" animtype]::["alias" alias]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["speed" (XMLgetShortFloatToString animspeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString skipFrame)]::nil nil
          else
            XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" animtype]::["alias" alias]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["interpolationMode" (getOgreAnimationInterpolationByType animintmode)]::["rotationInterpolationMode" (getOgreAnimationRotInterpolationByType animintrotmode)]::["length" (XMLgetShortFloatToString animlength)]::["speed" (XMLgetShortFloatToString animspeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString skipFrame)]::nil nil          
        -> newanimmark in
        let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim alias (if newanimmark == nil then animmark else newanimmark) nil destgroup sTreeBitmapAnim treefather animstate 0 -> treenode in
        (
          V3DanimationSetDefaultSkipFrame animstr skipFrame;
          
          if (!import) then nil else
            set groupstr.GRP_lTmpFunctionsImport = [(strcatn (XMLgetParam animmark "id")::"."::animname::nil) (strcatn id::"."::animname::nil)]::groupstr.GRP_lTmpFunctionsImport;
          
          if (!strcmp animtype "morph") || (!strcmp animtype "skeleton") then nil else
          let XMLgetMarksByValueFromMarkSons animmark "keyframe" -> lkeymarks in
          let sizelist lkeymarks -> ksize in
          let 0 -> k in
          while k < ksize do
          (
            let nth_list lkeymarks k -> keymark in
            let atof (XMLgetParam keymark "time") -> keytime in
            let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
            let atof XMLgetParam keytransmark "x" -> xpos in
            let atof XMLgetParam keytransmark "y" -> ypos in
            let atof XMLgetParam keytransmark "z" -> zpos in
            let XMLgetMarkByValueFromMarkSons keymark "rotation" -> keyrotmark in
            let atof XMLgetParam keyrotmark "qx" -> xang in
            let atof XMLgetParam keyrotmark "qy" -> yang in
            let atof XMLgetParam keyrotmark "qz" -> zang in
            let atof XMLgetParam keyrotmark "qw" -> wang in
            let XMLgetMarkByValueFromMarkSons keymark "scale" -> keyscalemark in
            let atof XMLgetParam keyscalemark "x" -> xscale in
            let atof XMLgetParam keyscalemark "y" -> yscale in
            let atof XMLgetParam keyscalemark "z" -> zscale in
            let if newanimmark == nil then nil else XMLaddMark xmlEditSceneFile "keyframe" newanimmark ["time" (XMLgetShortFloatToString keytime)]::nil nil -> newkeymark in
            (
              V3DaddAnimationKey animstr [xpos ypos zpos] [xang yang zang wang] [xscale yscale zscale] keytime;
              if newkeymark == nil then nil else
              (
                XMLaddMark xmlEditSceneFile "translation" newkeymark ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
                XMLaddMark xmlEditSceneFile "rotation" newkeymark ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
                XMLaddMark xmlEditSceneFile "scale" newkeymark ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
              );
            );
            
            set k = k + 1;
          );
          
          0;
        );
      );
      
      set i = i + 1;
    );    
  );
  0;;


/* ********************************************************************************************* /
  Ogre scene Loader
/ ********************************************************************************************* */
fun loadOgreMaxNodes(viewstr, srcnodemark, destfathermark, destgroup, father, treefather, units, root)=
  let getGroupName currentProject destgroup -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarksByValueFromMarkSons srcnodemark "node" -> lnodexml in
  let sizelist lnodexml -> size in
  let 0 -> i in
  while i < size do
  (
    let itoa getNewSceneIndex nil -> id in
    // NODE
    let nth_list lnodexml i -> nodexml in
    let XMLgetParam nodexml "name" -> nodename in
    let XMLgetMarkByValueFromMarkSons nodexml "position" -> nodeposstr in
    let if root then (atof XMLgetParam nodeposstr "x") /. units else (atof XMLgetParam nodeposstr "x") -> xpos in
    let if root then (atof XMLgetParam nodeposstr "y") /. units else (atof XMLgetParam nodeposstr "y") -> ypos in
    let if root then (atof XMLgetParam nodeposstr "z") /. units else (atof XMLgetParam nodeposstr "z") -> zpos in
    let XMLgetMarkByValueFromMarkSons nodexml "rotation" -> noderotstr in
    let if noderotstr == nil then XMLgetMarkByValueFromMarkSons nodexml "quaternion" else noderotstr -> noderotstr in
    let atof XMLgetParam noderotstr "qx" -> xang in
    let if xang == nil then (atof XMLgetParam noderotstr "x") else xang -> xang in
    let atof XMLgetParam noderotstr "qy" -> yang in
    let if yang == nil then (atof XMLgetParam noderotstr "y") else yang -> yang in
    let atof XMLgetParam noderotstr "qz" -> zang in
    let if zang == nil then (atof XMLgetParam noderotstr "z") else zang -> zang in
    let atof XMLgetParam noderotstr "qw" -> wang in
    let if wang == nil then (atof XMLgetParam noderotstr "w") else wang -> wang in
    
    let XMLgetMarkByValueFromMarkSons nodexml "scale" -> nodescalestr in
    let if root then (atof XMLgetParam nodescalestr "x") /. units else (atof XMLgetParam nodescalestr "x") -> xscale in
    let if root then (atof XMLgetParam nodescalestr "y") /. units else (atof XMLgetParam nodescalestr "y") -> yscale in
    let if root then (atof XMLgetParam nodescalestr "z") /. units else (atof XMLgetParam nodescalestr "z") -> zscale in    
    
    // ENTITY
    let XMLgetMarkByValueFromMarkSons nodexml "entity" -> entitystr in
    let strlowercase XMLgetParam entitystr "meshFile" -> mesh in
    let XMLgetBoolParam entitystr "castShadows" -> meshcastshadow in
    let XMLgetBoolParam entitystr "receiveShadows" -> meshreceiveshadow in
    let XMLgetParam entitystr "name" -> meshname in
    let atof (XMLgetParam entitystr "renderingDistance") -> meshrenderdistance in
    let XMLgetMarkByValueFromMarkSons entitystr "subentities" -> subentitiesstr in
    let XMLgetMarksByValueFromMarkSons subentitiesstr "subentity" -> lentitystr in
    
    // LIGHT
    let XMLgetMarkByValueFromMarkSons nodexml "light" -> lightstr in
    let getOgreMaxLightType (XMLgetParam lightstr "type") -> lighttype in
    let XMLgetParam lightstr "name" -> lightname in
    let XMLgetBoolParam lightstr "castShadows" -> lightcastshadow in
    let atof XMLgetParam lightstr "power" -> lightpower in
    let if (lightpower == nil) then 1.0 else lightpower -> lightpower in
    
    let XMLgetMarkByValueFromMarkSons lightstr "colourDiffuse" -> lightdiffusestr in
    let make_rgba (ftoi ((atof XMLgetParam lightdiffusestr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightdiffusestr "b") *. 255.0)) 0 -> lightdiffusecolor in
    
    let XMLgetMarkByValueFromMarkSons lightstr "colourSpecular" -> lightspecularstr in
    let make_rgba (ftoi ((atof XMLgetParam lightspecularstr "r") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "g") *. 255.0)) (ftoi ((atof XMLgetParam lightspecularstr "b") *. 255.0)) 0 -> lightspecularcolor in
    
    let XMLgetMarkByValueFromMarkSons lightstr "lightAttenuation" -> lightattenuationstr in
    let if ((XMLgetParam lightattenuationstr "range") == nil) then 100.0 /. units else (atof XMLgetParam lightattenuationstr "range") /. units -> lightrange in
    let atof XMLgetParam lightattenuationstr "constant" -> lightconst in
    let atof XMLgetParam lightattenuationstr "linear" -> lightlinear in
    let atof if (XMLgetParam lightattenuationstr "quadric") == nil then (XMLgetParam lightattenuationstr "quadratic") else (XMLgetParam lightattenuationstr "quadric") -> lightquadratic in
    
    let XMLgetMarkByValueFromMarkSons lightstr "lightRange" -> lightrangestr in
    let (atof XMLgetParam lightrangestr "inner") -> lightinner in
    let (atof XMLgetParam lightrangestr "outer") -> lightouter in
    
    // CAMERA
    let XMLgetMarkByValueFromMarkSons nodexml "camera" -> camerastr in
    let XMLgetParam camerastr "name" -> cameraname in
    let atof XMLgetParam camerastr "fov" -> camerafov in
    
    let XMLgetMarkByValueFromMarkSons camerastr "clipping" -> camclippingstr in
    let (atof if (XMLgetParam camclippingstr "near") == nil then (XMLgetParam camclippingstr "nearPlaneDist") else (XMLgetParam camclippingstr "near")) /. units -> camclipnear in
    let (atof if (XMLgetParam camclippingstr "far") == nil then (XMLgetParam camclippingstr "farPlaneDist") else (XMLgetParam camclippingstr "far")) /. units -> camclipfar in
    
    let XMLgetMarkByValue xmlEditSceneFile "scene" -> scenestr in
    let XMLgetMarkByValueFromMarkSons scenestr "graph" -> targetgraphstr in
    (
      let OGMATfindResourcePath mesh lResourcesPath -> meshpath in
      (
        if((mesh == nil) || (meshpath != nil)) then nil else
          addLogMessage strcatn "Error while loading the mesh file \""::mesh::"\", verify if the file exist or add the resource directory."::nil;
        
        let if meshpath != nil then SO3SceneLoadEntity (V3DgetSession sessionstr) resgroup (strcatn id::"."::meshname::nil) _checkpack meshpath else nil -> mesh in
        let if lightstr != nil then SO3LightCreate (V3DgetSession sessionstr) (strcatn id::"."::lightname::nil) else nil -> light in
        let if camerastr != nil then V3DaddCamera sessionstr (strcatn id::"."::cameraname::nil) else nil -> camera in
        let if mesh == nil && light == nil && camera == nil then SO3SceneNodeCreate (V3DgetSession sessionstr) (strcatn id::"."::nodename::nil) else nil -> shell in
        let if shell != nil then shell else if light != nil then light else if mesh != nil then mesh else if camera != nil then camera else nil -> nnode in
        (
          if father == nil then nil else
            SO3ObjectLink nnode father;
          
          SO3ObjectSetPosition nnode [xpos ypos zpos];
          SO3ObjectSetOrientation nnode [xang yang zang wang];
          SO3ObjectSetScale nnode [xscale yscale zscale];          
          
          if shell != nil then
          let XMLaddMark xmlEditSceneFile "shell" destfathermark ["id" id]::["name" nodename]::nil nil -> shellxmlstr in
          let addGraphItem strcatn nodename::" #"::id::nil (strcatn id::"."::nodename::nil) iTypeNode nil shellxmlstr nil destgroup sTreeBitmapNode treefather 0 0 -> treenode in
          (
            XMLaddMark xmlEditSceneFile "scale" shellxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" shellxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" shellxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;          
          
            V3DshowObjectHelper viewstr sessionstr shell iTypeNode 1;
            
            // ANIMS
            let XMLgetMarkByValueFromMarkSons nodexml "animations" -> animsmark in
            let XMLgetMarksByValueFromMarkSons animsmark "animation" -> lanimmarks in
            let if animsmark == nil then nil else XMLaddMark xmlEditSceneFile "animations" shellxmlstr nil nil -> targetanimsmark in
            let sizelist lanimmarks -> asize in
            let 0 -> a in
            while a < asize do
            (
              let nth_list lanimmarks a -> animmark in
              let XMLgetParam animmark "name" -> animname in
              let XMLgetBoolParam animmark "enable" -> animstate in
              let XMLgetBoolParam animmark "loop" -> animloop in
              let getOgreAnimationInterpolationType (XMLgetParam animmark "interpolationMode") -> animintmode in
              let getOgreAnimationRotInterpolationType (XMLgetParam animmark "rotationInterpolationMode") -> animintrotmode in
              let atof XMLgetParam animmark "length" -> animlength in
              let atof XMLgetParam animmark "weight" -> animweight in
              let if animweight == nil then 1.0 else animweight -> animweight in
              
              let (itoa getNewSceneIndex nil) -> id in
              let V3DaddAnimation sessionstr nnode (atoi id) animname (strcatn id::"."::animname::nil) animlength fDefaultAnimationSpeed animweight animstate animloop animintmode animintrotmode -> animstr in
              (
                if animstr == nil then
                (
                  addLogMessage strcatn "Error while adding the animation named \""::animname::"\", verify if the animation name already exist in scene."::nil;
                  0;
                )
                else
                let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" "node"]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["interpolationMode" (getOgreAnimationInterpolationByType animintmode)]::["rotationInterpolationMode" (getOgreAnimationRotInterpolationByType animintrotmode)]::["length" (XMLgetShortFloatToString animlength)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
                let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim nil newanimmark nil destgroup sTreeBitmapAnim treenode animstate 0 -> treenode in
                (
                  let XMLgetMarksByValueFromMarkSons animmark "keyframe" -> lkeymarks in
                  let sizelist lkeymarks -> ksize in
                  let 0 -> k in
                  while k < ksize do
                  (
                    let nth_list lkeymarks k -> keymark in
                    let atof (XMLgetParam keymark "time") -> keytime in
                    let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
                    let (if root then (atof XMLgetParam keytransmark "x") /. units else (atof XMLgetParam keytransmark "x")) -> xapos in
                    let (if root then (atof XMLgetParam keytransmark "y") /. units else (atof XMLgetParam keytransmark "y")) -> yapos in
                    let (if root then (atof XMLgetParam keytransmark "z") /. units else (atof XMLgetParam keytransmark "z")) -> zapos in
                    let XMLgetMarkByValueFromMarkSons keymark "rotation" -> keyrotmark in
                    let atof XMLgetParam keyrotmark "qx" -> xaang in
                    let atof XMLgetParam keyrotmark "qy" -> yaang in
                    let atof XMLgetParam keyrotmark "qz" -> zaang in
                    let atof XMLgetParam keyrotmark "qw" -> waang in
                    let XMLgetMarkByValueFromMarkSons keymark "scale" -> keyscalemark in
                    let (atof XMLgetParam keyscalemark "x") -> xascale in
                    let (atof XMLgetParam keyscalemark "y") -> yascale in
                    let (atof XMLgetParam keyscalemark "z") -> zascale in
                    let XMLaddMark xmlEditSceneFile "keyframe" newanimmark ["time" (XMLgetShortFloatToString keytime)]::nil nil -> newkeymark in
                    (
                      V3DaddAnimationKey animstr [xapos yapos zapos] [xaang yaang zaang waang] [xascale yascale zascale] keytime;
                      XMLaddMark xmlEditSceneFile "translation" newkeymark ["x" (XMLgetShortFloatToString xapos)]::["y" (XMLgetShortFloatToString yapos)]::["z" (XMLgetShortFloatToString zapos)]::nil nil;
                      XMLaddMark xmlEditSceneFile "rotation" newkeymark ["qx" (XMLgetShortFloatToString xaang)]::["qy" (XMLgetShortFloatToString yaang)]::["qz" (XMLgetShortFloatToString zaang)]::["qw" (XMLgetShortFloatToString waang)]::nil nil;
                      XMLaddMark xmlEditSceneFile "scale" newkeymark ["x" (XMLgetShortFloatToString xascale)]::["y" (XMLgetShortFloatToString yascale)]::["z" (XMLgetShortFloatToString zascale)]::nil nil;
                    );
                    
                    set k = k + 1;
                  );
                  
                  0;
                );
              );
              
              set a = a + 1;
            ); 
            
            loadOgreMaxNodes viewstr nodexml shellxmlstr destgroup nnode treenode units 0;
          )
          else if mesh != nil then
          let strcat (getFilePathWithoutExt meshpath) ".skeleton" -> sklpath in
          let OGMATfindResourcePath sklpath lResourcesPath -> sklpath in
          let XMLaddMark xmlEditSceneFile "mesh" destfathermark ["id" id]::["name" meshname]::["path" meshpath]::["castShadows" (XMLgetBoolString meshcastshadow)]::["receiveShadows" (XMLgetBoolString meshreceiveshadow)]::["indexMaterials" (XMLgetBoolString 0)]::["renderingDistance" (XMLgetShortFloatToString meshrenderdistance)]::["visibilityFlags" "0xFFFFFFFF"]::(if sklpath == nil then nil else ["skeletonlink" sklpath])::nil nil -> meshxmlstr in
          let XMLaddMark xmlEditSceneFile "subentities" meshxmlstr nil nil -> meshxmlsubstr in
          let addGraphItem (strcatn meshname::" #"::id::nil) (strcatn id::"."::meshname::nil) iTypeEntity nil meshxmlstr meshpath destgroup sTreeBitmapEntity treefather 0 0 -> treenode in
          (
            if (_checkpack sklpath) == nil then nil else
            (
              V3DaddResource sessionstr sklpath resgroup SO3_RESOURCE_SKELETON;
              SO3EntityAttachSkeleton mesh _checkpack sklpath;
              addOsSceneResource xmlEditSceneFile destgroup sklpath SO3_RESOURCE_SKELETON;
              let SO3GetRootBonesFromMesh mesh -> rootbones in
              let sizelist rootbones -> nbrootbones in
              let 0 -> j in
              while j < nbrootbones do
              (
                loadBonesChilds sessionstr (nth_list rootbones j) meshxmlstr treenode destgroup;
                set j = j + 1;
              );
            );
            
            let sizelist lentitystr -> size in
            let 0 -> j in
            while j < size do
            (
              let nth_list lentitystr j -> elem in
              let atoi XMLgetParam elem "index" -> subidx in
              let XMLgetParam elem "materialName" -> submatname in
              let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup submatname -> submat in
              (
                XMLaddMark xmlEditSceneFile "subentity" meshxmlsubstr ["index" (itoa subidx)]::["materialName" submatname]::["defaultMaterial" submatname]::nil nil;
                SO3EntitySetMaterial mesh submat subidx;
              );
              set j = j + 1;
            );
            
            // morph anims
            let SO3ObjectGetVertexAnimations mesh -> lmorph in
            if lmorph == nil then nil else
            (
              let sizelist lmorph -> sizemorph in
              let 0 -> imorph in
              while imorph < sizemorph do
              (
                let nth_list lmorph imorph -> anim in
                let if imorph == 0 then 1 else 0 -> defstate in
                let itoa getNewSceneIndex nil -> animid in
                let SO3AnimationGetName anim -> animname in
                let XMLgetMarkByValueFromMarkSons meshxmlstr "animations" -> animsmark in
                let if animsmark != nil then animsmark else XMLaddMark xmlEditSceneFile "animations" meshxmlstr nil nil -> targetanimsmark in
                let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" animid]::["name" animname]::["type" "morph"]::["enable" (XMLgetBoolString defstate)]::["loop" (XMLgetBoolString 0)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString 1.0)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
                let addGraphItem strcatn animname::" #"::animid::nil (strcatn animid::"."::animname::nil) iTypeAnim nil newanimmark nil destgroup sTreeBitmapAnim treenode defstate 0 -> treenode in
                (
                  V3DaddMorphAnimation sessionstr anim mesh (atoi animid) animname (strcatn animid::"."::animname::nil) fDefaultAnimationSpeed 1.0 defstate 0;
                );
                
                set imorph = imorph + 1;
              );
            );
            
            XMLaddMark xmlEditSceneFile "scale" meshxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" meshxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" meshxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;          
            
            V3DaddResource sessionstr meshpath resgroup SO3_RESOURCE_MESH;
            addOsSceneResource xmlEditSceneFile destgroup meshpath SO3_RESOURCE_MESH;
            
            SO3ObjectSetCastShadows mesh meshcastshadow;
            SO3ObjectSetRenderingDistance mesh meshrenderdistance;
            SO3EntitySetVisibilityFlags mesh 0xFFFFFFFF;
            
            // ANIMS
            let XMLgetMarkByValueFromMarkSons nodexml "animations" -> animsmark in
            let XMLgetMarksByValueFromMarkSons animsmark "animation" -> lanimmarks in
            let if animsmark == nil then nil else XMLaddMark xmlEditSceneFile "animations" meshxmlstr nil nil -> targetanimsmark in
            let sizelist lanimmarks -> asize in
            let 0 -> a in
            while a < asize do
            (
              let nth_list lanimmarks a -> animmark in
              let XMLgetParam animmark "name" -> animname in
              let XMLgetBoolParam animmark "enable" -> animstate in
              let XMLgetBoolParam animmark "loop" -> animloop in
              let getOgreAnimationInterpolationType (XMLgetParam animmark "interpolationMode") -> animintmode in
              let getOgreAnimationRotInterpolationType (XMLgetParam animmark "rotationInterpolationMode") -> animintrotmode in
              let atof XMLgetParam animmark "length" -> animlength in
              let atof XMLgetParam animmark "weight" -> animweight in
              let if animweight == nil then 1.0 else animweight -> animweight in
              
              let (itoa getNewSceneIndex nil) -> id in
              let V3DaddAnimation sessionstr nnode (atoi id) animname (strcatn id::"."::animname::nil) animlength fDefaultAnimationSpeed animweight animstate animloop animintmode animintrotmode -> animstr in
              (
                if animstr == nil then
                (
                  addLogMessage strcatn "Error while adding the animation named \""::animname::"\", verify if the animation name already exist in scene."::nil;
                  0;
                )
                else
                let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" "node"]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["interpolationMode" (getOgreAnimationInterpolationByType animintmode)]::["rotationInterpolationMode" (getOgreAnimationRotInterpolationByType animintrotmode)]::["length" (XMLgetShortFloatToString animlength)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
                let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim nil newanimmark nil destgroup sTreeBitmapAnim treenode animstate 0 -> treenode in
                (                  
                  let XMLgetMarksByValueFromMarkSons animmark "keyframe" -> lkeymarks in
                  let sizelist lkeymarks -> ksize in
                  let 0 -> k in
                  while k < ksize do
                  (
                    let nth_list lkeymarks k -> keymark in
                    let atof (XMLgetParam keymark "time") -> keytime in
                    let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
                    let (if root then (atof XMLgetParam keytransmark "x") /. units else (atof XMLgetParam keytransmark "x")) -> xapos in
                    let (if root then (atof XMLgetParam keytransmark "y") /. units else (atof XMLgetParam keytransmark "y")) -> yapos in
                    let (if root then (atof XMLgetParam keytransmark "z") /. units else (atof XMLgetParam keytransmark "z")) -> zapos in
                    let XMLgetMarkByValueFromMarkSons keymark "rotation" -> keyrotmark in
                    let atof XMLgetParam keyrotmark "qx" -> xaang in
                    let atof XMLgetParam keyrotmark "qy" -> yaang in
                    let atof XMLgetParam keyrotmark "qz" -> zaang in
                    let atof XMLgetParam keyrotmark "qw" -> waang in
                    let XMLgetMarkByValueFromMarkSons keymark "scale" -> keyscalemark in
                    let (atof XMLgetParam keyscalemark "x") -> xascale in
                    let (atof XMLgetParam keyscalemark "y") -> yascale in
                    let (atof XMLgetParam keyscalemark "z") -> zascale in
                    let XMLaddMark xmlEditSceneFile "keyframe" newanimmark ["time" (XMLgetShortFloatToString keytime)]::nil nil -> newkeymark in
                    (
                      V3DaddAnimationKey animstr [xapos yapos zapos] [xaang yaang zaang waang] [xascale yascale zascale] keytime;
                      XMLaddMark xmlEditSceneFile "translation" newkeymark ["x" (XMLgetShortFloatToString xapos)]::["y" (XMLgetShortFloatToString yapos)]::["z" (XMLgetShortFloatToString zapos)]::nil nil;
                      XMLaddMark xmlEditSceneFile "rotation" newkeymark ["qx" (XMLgetShortFloatToString xaang)]::["qy" (XMLgetShortFloatToString yaang)]::["qz" (XMLgetShortFloatToString zaang)]::["qw" (XMLgetShortFloatToString waang)]::nil nil;
                      XMLaddMark xmlEditSceneFile "scale" newkeymark ["x" (XMLgetShortFloatToString xascale)]::["y" (XMLgetShortFloatToString yascale)]::["z" (XMLgetShortFloatToString zascale)]::nil nil;
                    );
                    
                    set k = k + 1;
                  );
                  
                  0;
                );
              );
              
              set a = a + 1;
            );
            
            loadOgreMaxNodes viewstr nodexml meshxmlstr destgroup nnode treenode units 0;
          )
          else if camera != nil then
          let XMLaddMark xmlEditSceneFile "camera" destfathermark ["id" id]::["name" cameraname]::["fov" (XMLgetShortFloatToString camerafov)]::nil nil -> camxmlstr in
          let addGraphItem strcatn cameraname::" #"::id::nil (strcatn id::"."::cameraname::nil) iTypeCamera nil camxmlstr nil destgroup sTreeBitmapCamera treefather 0 0 -> treenode in
          (
            XMLaddMark xmlEditSceneFile "scale" camxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" camxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" camxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
            XMLaddMark xmlEditSceneFile "clipping" camxmlstr ["near" (XMLgetShortFloatToString camclipnear)]::["far" (XMLgetShortFloatToString camclipfar)]::nil nil;
            
            V3DsetCamera camera nil camerafov camclipnear camclipfar;
            V3DshowObjectHelper viewstr sessionstr camera iTypeCamera 1;
            
            // ANIMS
            let XMLgetMarkByValueFromMarkSons nodexml "animations" -> animsmark in
            let XMLgetMarksByValueFromMarkSons animsmark "animation" -> lanimmarks in
            let if animsmark == nil then nil else XMLaddMark xmlEditSceneFile "animations" camxmlstr nil nil -> targetanimsmark in
            let sizelist lanimmarks -> asize in
            let 0 -> a in
            while a < asize do
            (
              let nth_list lanimmarks a -> animmark in
              let XMLgetParam animmark "name" -> animname in
              let XMLgetBoolParam animmark "enable" -> animstate in
              let XMLgetBoolParam animmark "loop" -> animloop in
              let getOgreAnimationInterpolationType (XMLgetParam animmark "interpolationMode") -> animintmode in
              let getOgreAnimationRotInterpolationType (XMLgetParam animmark "rotationInterpolationMode") -> animintrotmode in
              let atof XMLgetParam animmark "length" -> animlength in
              let atof XMLgetParam animmark "weight" -> animweight in
              let if animweight == nil then 1.0 else animweight -> animweight in
              
              let (itoa getNewSceneIndex nil) -> id in
              let V3DaddAnimation sessionstr nnode (atoi id) animname (strcatn id::"."::animname::nil) animlength fDefaultAnimationSpeed animweight animstate animloop animintmode animintrotmode -> animstr in
              (
                if animstr == nil then
                (
                  addLogMessage strcatn "Error while adding the animation named \""::animname::"\", verify if the animation name already exist in scene."::nil;
                  0;
                )
                else
                let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" "node"]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["interpolationMode" (getOgreAnimationInterpolationByType animintmode)]::["rotationInterpolationMode" (getOgreAnimationRotInterpolationByType animintrotmode)]::["length" (XMLgetShortFloatToString animlength)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
                let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim nil newanimmark nil destgroup sTreeBitmapAnim treenode animstate 0 -> treenode in
                (
                  let XMLgetMarksByValueFromMarkSons animmark "keyframe" -> lkeymarks in
                  let sizelist lkeymarks -> ksize in
                  let 0 -> k in
                  while k < ksize do
                  (
                    let nth_list lkeymarks k -> keymark in
                    let atof (XMLgetParam keymark "time") -> keytime in
                    let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
                    let (if root then (atof XMLgetParam keytransmark "x") /. units else (atof XMLgetParam keytransmark "x")) -> xapos in
                    let (if root then (atof XMLgetParam keytransmark "y") /. units else (atof XMLgetParam keytransmark "y")) -> yapos in
                    let (if root then (atof XMLgetParam keytransmark "z") /. units else (atof XMLgetParam keytransmark "z")) -> zapos in
                    let XMLgetMarkByValueFromMarkSons keymark "rotation" -> keyrotmark in
                    let atof XMLgetParam keyrotmark "qx" -> xaang in
                    let atof XMLgetParam keyrotmark "qy" -> yaang in
                    let atof XMLgetParam keyrotmark "qz" -> zaang in
                    let atof XMLgetParam keyrotmark "qw" -> waang in
                    let XMLgetMarkByValueFromMarkSons keymark "scale" -> keyscalemark in
                    let (atof XMLgetParam keyscalemark "x") -> xascale in
                    let (atof XMLgetParam keyscalemark "y") -> yascale in
                    let (atof XMLgetParam keyscalemark "z") -> zascale in
                    let XMLaddMark xmlEditSceneFile "keyframe" newanimmark ["time" (XMLgetShortFloatToString keytime)]::nil nil -> newkeymark in
                    (
                      V3DaddAnimationKey animstr [xapos yapos zapos] [xaang yaang zaang waang] [xascale yascale zascale] keytime;
                      XMLaddMark xmlEditSceneFile "translation" newkeymark ["x" (XMLgetShortFloatToString xapos)]::["y" (XMLgetShortFloatToString yapos)]::["z" (XMLgetShortFloatToString zapos)]::nil nil;
                      XMLaddMark xmlEditSceneFile "rotation" newkeymark ["qx" (XMLgetShortFloatToString xaang)]::["qy" (XMLgetShortFloatToString yaang)]::["qz" (XMLgetShortFloatToString zaang)]::["qw" (XMLgetShortFloatToString waang)]::nil nil;
                      XMLaddMark xmlEditSceneFile "scale" newkeymark ["x" (XMLgetShortFloatToString xascale)]::["y" (XMLgetShortFloatToString yascale)]::["z" (XMLgetShortFloatToString zascale)]::nil nil;
                    );
                    
                    set k = k + 1;
                  );
                  
                  0;
                );
              );
              
              set a = a + 1;
            );
            
            loadOgreMaxNodes viewstr nodexml camxmlstr destgroup nnode treenode units 0;
          )
          else if light != nil then
          let XMLaddMark xmlEditSceneFile "light" destfathermark ["id" id]::["name" lightname]::["type" (getOgreMaxLightByType lighttype)]::["castShadows" (XMLgetBoolString lightcastshadow)]::["power" (XMLgetShortFloatToString lightpower)]::["enable" (XMLgetBoolString 1)]::nil nil -> lightxmlstr in
          let addGraphItem strcatn lightname::" #"::id::nil (strcatn id::"."::lightname::nil) iTypeLight nil lightxmlstr nil destgroup sTreeBitmapLight treefather 1 0 -> treenode in
          (
            // remove default light
            V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultLight sessionstr) nil 0;
            V3DuseDefaultLight sessionstr 0;
            set bLastDefaultLightState = 0;
            
            XMLaddMark xmlEditSceneFile "scale" lightxmlstr ["x" (XMLgetShortFloatToString xscale)]::["y" (XMLgetShortFloatToString yscale)]::["z" (XMLgetShortFloatToString zscale)]::nil nil;
            XMLaddMark xmlEditSceneFile "position" lightxmlstr ["x" (XMLgetShortFloatToString xpos)]::["y" (XMLgetShortFloatToString ypos)]::["z" (XMLgetShortFloatToString zpos)]::nil nil;
            XMLaddMark xmlEditSceneFile "rotation" lightxmlstr ["qx" (XMLgetShortFloatToString xang)]::["qy" (XMLgetShortFloatToString yang)]::["qz" (XMLgetShortFloatToString zang)]::["qw" (XMLgetShortFloatToString wang)]::nil nil;
            
            XMLaddMark xmlEditSceneFile "colourDiffuse" lightxmlstr ["r" (XMLgetParam lightdiffusestr "r")]::["g" (XMLgetParam lightdiffusestr "g")]::["b" (XMLgetParam lightdiffusestr "b")]::nil nil;
            XMLaddMark xmlEditSceneFile "colourSpecular" lightxmlstr  ["r" (XMLgetParam lightspecularstr "r")]::["g" (XMLgetParam lightspecularstr "g")]::["b" (XMLgetParam lightspecularstr "b")]::nil nil;
            
            XMLaddMark xmlEditSceneFile "lightAttenuation" lightxmlstr ["range" (XMLgetShortFloatToString lightrange)]::nil nil;
                                    
            SO3LightSetType light lighttype;
            SO3LightSetPowerScale light lightpower;
            SO3LightSetDiffuseColor light lightdiffusecolor;
            SO3LightSetSpecularColor light lightspecularcolor;
            SO3LightSetAttenuationAuto light lightrange;
            SO3ObjectSetCastShadows light lightcastshadow;
            
            V3DshowObjectHelper viewstr sessionstr light iTypeLight 1;
            
            if lightrangestr == nil then nil else
            (
              XMLaddMark xmlEditSceneFile "lightRange" lightxmlstr ["inner" (XMLgetShortFloatToString lightinner)]::["outer" (XMLgetShortFloatToString lightouter)]::nil nil;

              SO3LightSetSpotInnerAngle light lightinner;
              SO3LightSetSpotOuterAngle light lightouter;
            );
            
            // ANIMS
            let XMLgetMarkByValueFromMarkSons nodexml "animations" -> animsmark in
            let XMLgetMarksByValueFromMarkSons animsmark "animation" -> lanimmarks in
            let if animsmark == nil then nil else XMLaddMark xmlEditSceneFile "animations" lightxmlstr nil nil -> targetanimsmark in
            let sizelist lanimmarks -> asize in
            let 0 -> a in
            while a < asize do
            (
              let nth_list lanimmarks a -> animmark in
              let XMLgetParam animmark "name" -> animname in
              let XMLgetBoolParam animmark "enable" -> animstate in
              let XMLgetBoolParam animmark "loop" -> animloop in
              let getOgreAnimationInterpolationType (XMLgetParam animmark "interpolationMode") -> animintmode in
              let getOgreAnimationRotInterpolationType (XMLgetParam animmark "rotationInterpolationMode") -> animintrotmode in
              let atof XMLgetParam animmark "length" -> animlength in
              let atof XMLgetParam animmark "weight" -> animweight in
              let if animweight == nil then 1.0 else animweight -> animweight in
              
              let (itoa getNewSceneIndex nil) -> id in
              let V3DaddAnimation sessionstr nnode (atoi id) animname (strcatn id::"."::animname::nil) animlength fDefaultAnimationSpeed animweight animstate animloop animintmode animintrotmode -> animstr in
              (
                if animstr == nil then
                (
                  addLogMessage strcatn "Error while adding the animation named \""::animname::"\", verify if the animation name already exist in scene."::nil;
                  0;
                )
                else
                let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" id]::["name" animname]::["type" "node"]::["enable" (XMLgetBoolString animstate)]::["loop" (XMLgetBoolString animloop)]::["interpolationMode" (getOgreAnimationInterpolationByType animintmode)]::["rotationInterpolationMode" (getOgreAnimationRotInterpolationByType animintrotmode)]::["length" (XMLgetShortFloatToString animlength)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString animweight)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
                let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim nil newanimmark nil destgroup sTreeBitmapAnim treenode animstate 0 -> treenode in
                (
                  let XMLgetMarksByValueFromMarkSons animmark "keyframe" -> lkeymarks in
                  let sizelist lkeymarks -> ksize in
                  let 0 -> k in
                  while k < ksize do
                  (
                    let nth_list lkeymarks k -> keymark in
                    let atof (XMLgetParam keymark "time") -> keytime in
                    let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
                    let XMLgetMarkByValueFromMarkSons keymark "translation" -> keytransmark in
                    let (if root then (atof XMLgetParam keytransmark "x") /. units else (atof XMLgetParam keytransmark "x")) -> xapos in
                    let (if root then (atof XMLgetParam keytransmark "y") /. units else (atof XMLgetParam keytransmark "y")) -> yapos in
                    let (if root then (atof XMLgetParam keytransmark "z") /. units else (atof XMLgetParam keytransmark "z")) -> zapos in
                    let XMLgetMarkByValueFromMarkSons keymark "rotation" -> keyrotmark in
                    let atof XMLgetParam keyrotmark "qx" -> xaang in
                    let atof XMLgetParam keyrotmark "qy" -> yaang in
                    let atof XMLgetParam keyrotmark "qz" -> zaang in
                    let atof XMLgetParam keyrotmark "qw" -> waang in
                    let XMLgetMarkByValueFromMarkSons keymark "scale" -> keyscalemark in
                    let (atof XMLgetParam keyscalemark "x") -> xascale in
                    let (atof XMLgetParam keyscalemark "y") -> yascale in
                    let (atof XMLgetParam keyscalemark "z") -> zascale in
                    let XMLaddMark xmlEditSceneFile "keyframe" newanimmark ["time" (XMLgetShortFloatToString keytime)]::nil nil -> newkeymark in
                    (
                      V3DaddAnimationKey animstr [xapos yapos zapos] [xaang yaang zaang waang] [xascale yascale zascale] keytime;
                      XMLaddMark xmlEditSceneFile "translation" newkeymark ["x" (XMLgetShortFloatToString xapos)]::["y" (XMLgetShortFloatToString yapos)]::["z" (XMLgetShortFloatToString zapos)]::nil nil;
                      XMLaddMark xmlEditSceneFile "rotation" newkeymark ["qx" (XMLgetShortFloatToString xaang)]::["qy" (XMLgetShortFloatToString yaang)]::["qz" (XMLgetShortFloatToString zaang)]::["qw" (XMLgetShortFloatToString waang)]::nil nil;
                      XMLaddMark xmlEditSceneFile "scale" newkeymark ["x" (XMLgetShortFloatToString xascale)]::["y" (XMLgetShortFloatToString yascale)]::["z" (XMLgetShortFloatToString zascale)]::nil nil;
                    );
                    
                    set k = k + 1;
                  );
                  
                  0;
                );
              );
              
              set a = a + 1;
            );
            
            loadOgreMaxNodes viewstr nodexml lightxmlstr destgroup nnode treenode units 0;
          )
          else nil;
        );
      );
    );
    
    set i = i + 1;
  );
  0;;


fun addResourceFile(viewstr, groupmark, file)=
  let (V3DgetDefaultSession viewstr) -> sessionstr in
  let getGroupName currentProject groupmark -> resgroup in  
  let getFileExt file -> ext in
  let getFileResourceType file -> type in
  let getPathFile file "" -> [dir _] in
  (
    addOsResourceDir dir::nil;
    
    if type == SO3_RESOURCE_MATERIAL then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            addResourceFile viewstr groupmark elem;
          
          set ti = ti + 1;
        );

        V3DaddResource sessionstr file resgroup SO3_RESOURCE_MATERIAL;
        addOsSceneResource xmlEditSceneFile groupmark file SO3_RESOURCE_MATERIAL;
        0;
      )
      else
      (
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 mkfun4 @cbRewriteMaterialFileAndLoad viewstr [file groupmark];
        0;
      );
      0;
    )
    else if type == SO3_RESOURCE_GPUPROGRAM then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            addResourceFile viewstr groupmark elem;

          set ti = ti + 1;
        );
          
        V3DaddResource sessionstr file resgroup SO3_RESOURCE_GPUPROGRAM;          
        addOsSceneResource xmlEditSceneFile groupmark file SO3_RESOURCE_GPUPROGRAM;        
        0;
      )
      else
      (
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 mkfun4 @cbRewriteProgramFileAndLoad viewstr [file groupmark];
        0;
      );
    )
    else if (type != -1) then
    (
      V3DaddResource sessionstr file resgroup type;
      addOsSceneResource xmlEditSceneFile groupmark file type;
      0;
    )
    else
    (
      addOsSceneResource xmlEditSceneFile groupmark file type;
      0;
    );
  );
  0;;


fun cbRewriteMaterialFile(msg, p, ret)=
  let p -> [file groupstr] in
  (
    if !ret then nil else
    (
      OGMATsetResourcesPath file lResourcesPath;
      addLogMessage strcat file " has been rewrited with found resources path.";
      let OGMATgetResources file -> [isok lres lbad] in
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
          (
            storeResourceFile groupstr elem;
            addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark elem (getFileResourceType elem);
          );
          
          set ti = ti + 1;
        );
        
        if lbad == nil then nil else
        (
          _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" strcatn "Some files in "::file::" still not found\n verify your Ogre resources path"::nil 0;
          addLogMessageMultiOnline strcatn "Resource not found in "::file::" script :"::nil lbad;
        );
        0;
      );
    );
    
    storeResourceFile groupstr file;
    set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad - 1;
  );
  0;;


fun cbRewriteMaterialFileAndLoad(msg, p, ret, viewstr)=
  let p -> [file groupmark] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    if !ret then nil else
    (
      OGMATsetResourcesPath file lResourcesPath;
      addLogMessage strcat file " has been rewrited with found resources path.";
      let OGMATgetResources file -> [isok lres lbad] in
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            addResourceFile viewstr groupmark elem;
          
          set ti = ti + 1;
        );
        
        if lbad == nil then 
        (
          addResourceFile viewstr groupmark file;
          0;
        )
        else
        (
          _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" strcatn "Some files in "::file::" still not found\n verify your Ogre resources path"::nil 0;
          addLogMessageMultiOnline strcatn "Resource not found in "::file::" script :"::nil lbad;
        );
        0;
      );
    );
  );
  0;;


fun cbRewriteProgramFile(msg, p, ret)=
  let p -> [file groupstr] in
  (
    if !ret then nil else
    (
      OGMATsetResourcesPath file lResourcesPath;
      addLogMessage strcat file " has been rewrited with found resources path.";
      let OGMATgetResources file -> [isok lres lbad] in
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
          (
            storeResourceFile groupstr elem;
            addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark elem SO3_RESOURCE_HIGHLEVELGPUPROGRAM;
          );
          
          set ti = ti + 1;
        );
        0;
        
        if lbad == nil then nil else
        (
          _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" strcatn "Some files in "::file::" still not found\n verify your Ogre resources path"::nil 0;
          addLogMessageMultiOnline strcatn "Resource not found in "::file::" script :"::nil lbad;
        );
      );
    );
    
    storeResourceFile groupstr file;
    set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad - 1;
  );
  0;;


fun cbRewriteProgramFileAndLoad(msg, p, ret, viewstr)=
  let p -> [file groupmark] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in  
  (
    if !ret then nil else
    (
      OGMATsetResourcesPath file lResourcesPath;
      addLogMessage strcat file " has been rewrited with found resources path.";
      let OGMATgetResources file -> [isok lres lbad] in
      (
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            addResourceFile viewstr groupmark elem;
          
          set ti = ti + 1;
        );
        
        if lbad == nil then 
        (
          addResourceFile viewstr groupmark file;
          0;
        )
        else
        (
          _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" strcatn "Some files in "::file::" still not found\n verify your Ogre resources path"::nil 0;
          addLogMessageMultiOnline strcatn "Resource not found in "::file::" script :"::nil lbad;
          0;
        );
        0;
      );
    );
  );
  0;;


fun getResourcesPath(groupstr, groupmark)=
  let XMLgetMarkByValueFromMarkSons groupmark "resourceLocations" -> resourcesxml in
  let XMLgetMarksByValueFromMarkSons resourcesxml "resourceLocation" -> lresourcexml in
  let nil -> lpaths in
  let nil -> lfiles in
  (
    let sizelist lresourcexml -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lresourcexml i -> resourcexml in
      let XMLgetParam resourcexml "type" -> type in
      let XMLgetParam resourcexml "name" -> path in
      let XMLgetBoolParam resourcexml "recursive" -> recursive in
      if (strcmpi type "FileSystem") || (path == nil) || (!strcmp "" (strtrim path)) then nil else
      (
        let if recursive then path::(getDirListFromPath path) else path::nil -> fpath in        
          set lpaths = lcat lpaths fpath;
      );
      
      set i = i + 1;
    );
    
    let sizelist lpaths -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lpaths i -> path in
      let _listoffiles path -> files in
      let sizelist files -> size2 in
      let 0 -> i2 in
      (
        while i2 < size2 do
        (
          let nth_list files i2 -> file in      
            set lfiles = lcat lfiles file::nil;
          
          set i2 = i2 + 1;
        );
      );
      set i = i + 1;
    );
    
    addOsResourceDir lpaths;
    set groupstr.GRP_lAvailableResourcesFiles = quicksort (lcat groupstr.GRP_lAvailableResourcesFiles lfiles) @suppDoublon;
  );
  0;;


fun getResourcesScriptFilesFromGroup(groupstr)=
  let sizelist groupstr.GRP_lAvailableResourcesFiles -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list groupstr.GRP_lAvailableResourcesFiles i -> file in
    let getFileExt file -> ext in
    if (!strcmpi ext "material") || (!strcmpi ext "particle") then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
        storeResourceFile groupstr file;
        
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            storeResourceFile groupstr elem;
          
          set ti = ti + 1;
        );
        0;
      )
      else
      (
        set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad + 1;
        
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 @cbRewriteMaterialFile [file groupstr];
        addLogMessage strcatn "Some files are missing in "::file::nil;
        0;
      );
      0;
    )
    else if (!strcmpi ext "program") then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
        storeResourceFile groupstr file;          
        
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
            storeResourceFile groupstr elem;
          
          set ti = ti + 1;
        );
        0;
      )
      else
      (
        set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad + 1;
        
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 @cbRewriteProgramFile [file groupstr];
        addLogMessage strcatn "Some files are missing in "::file::nil;
        0;
      );
    )
    else
    (
      storeResourceFile groupstr file;
      0;
    );
    
    set i = i + 1;
  );
  0;;


fun getResourcesScriptFiles(groupstr, lscript)=
  set groupstr.GRP_lAvailableResourcesFiles = lcat groupstr.GRP_lAvailableResourcesFiles lscript;

  let sizelist lscript -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list lscript i -> file in
    let getFileExt file -> ext in
    if (!strcmpi ext "material") || (!strcmpi ext "particle") then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
        storeResourceFile groupstr file;
        
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
          (
            storeResourceFile groupstr elem;
            addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark elem (getFileResourceType elem);
          );
          
          set ti = ti + 1;
        );
        0;
      )
      else
      (
        set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad + 1;
        
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 @cbRewriteMaterialFile [file groupstr];
        addLogMessage strcatn "Some files are missing in "::file::nil;
        0;
      );
      0;
    )
    else if (!strcmpi ext "program") then
    (
      let OGMATgetResources file -> [isok lres lbad] in
      if isok then
      (
         storeResourceFile groupstr file;
        
        let sizelist lres -> tsize in
        let 0 -> ti in
        while ti < tsize do
        (
          let nth_list lres ti -> [mode elem] in
          (
            storeResourceFile groupstr elem;
            addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark elem (getFileResourceType elem);
          );
          
          set ti = ti + 1;
        );
        0;
      )
      else
      (
        set groupstr.GRP_iWaitForLoad = groupstr.GRP_iWaitForLoad + 1;
        
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Resources path" strcatn "The file "::file::"\ndo not contain all the correct resources path\n Do you want to rewrite the file with correct scol path ?"::nil 1 @cbRewriteProgramFile [file groupstr];
        addLogMessage strcatn "Some files are missing in "::file::nil;
        0;
      );
    )
    else
    (
      storeResourceFile groupstr file;
      0;
    );
    
    set i = i + 1;
  );
  0;;


fun loadGroupResources(groupstr, viewstr, destgroupmark)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGroupName currentProject destgroupmark -> resgroup in
  (
    let sizelist groupstr.GRP_lTextureResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lTextureResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_TEXTURE;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_TEXTURE;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lShaderResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lShaderResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_HIGHLEVELGPUPROGRAM;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_HIGHLEVELGPUPROGRAM;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lProgramResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lProgramResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_GPUPROGRAM;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_GPUPROGRAM;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lMaterialResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lMaterialResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_MATERIAL;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_MATERIAL;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lCompositorResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lCompositorResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_COMPOSITOR;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_COMPOSITOR;
      );
      
      set i = i + 1;
    );    
    
    let sizelist groupstr.GRP_lParticleResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lParticleResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_PARTICLE_SYSTEM;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_PARTICLE_SYSTEM;
      );
      
      set i = i + 1;
    ); 
    
    let sizelist groupstr.GRP_lSkeletonResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lSkeletonResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_SKELETON;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_SKELETON;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lMeshResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lMeshResources i -> elem in
      (
        V3DaddResource sessionstr elem resgroup SO3_RESOURCE_MESH;
        addOsSceneResource xmlEditSceneFile destgroupmark elem SO3_RESOURCE_MESH;
      );
      
      set i = i + 1;
    );
    
    let sizelist groupstr.GRP_lOtherResources -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list groupstr.GRP_lOtherResources i -> elem in
      (
        addOsSceneResource xmlEditSceneFile destgroupmark elem (-1);
      );
      
      set i = i + 1;
    );
    
    // Meshs are added dynamicaly
  );
  0;;


fun cbDlgLoadEnvironment(dlg, p, rep)=
  let p -> [viewstr groupmark] in
  if !rep then nil else
    loadEnvironment viewstr groupmark;
  0;;


fun cbIsOgreMaxSceneReadyToImport(trm, p)=
  let p -> [viewstr groupstr srcgroupmark destgroupmark newgroupshell treenode] in
  if groupstr.GRP_iWaitForLoad > 0 then nil else
  (
    _deltimer trm;

    loadGroupResources groupstr viewstr destgroupmark;

    let XMLgetMarkByValueFromMarkSons srcgroupmark "environment" -> envxml in
    if envxml == nil then nil else
      _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Import environment" "An environment setting has been found in imported scene\n Do you want to import this environment setting ?" 2 @cbDlgLoadEnvironment [viewstr srcgroupmark];
    
    let XMLgetMarkByValueFromMarkSons srcgroupmark "nodes" -> srcnodesmark in
    let XMLgetMarkByValueFromMarkSons destgroupmark "graph" -> destgraphmark in    
    let atof XMLgetParam srcgroupmark "unitsPerMeter" -> units in
    let if units == nil then (1.0 *. (itof iGlobalUnit)) else (units /. (itof iGlobalUnit)) -> units in
      loadOgreMaxNodes viewstr srcnodesmark destgraphmark destgroupmark newgroupshell treenode units 1;

    addLogMessage "Scene loaded.";
  );
  0;;


fun importOgreMaxScene(viewstr, file, lresdir, lscripts, destgroupmark, father, treefather, groupname, mode)=
  addLogMessage strcatn "Importing Ogre scene file : "::file::nil;
  
  addOsResourceDir lresdir;
  
  let XMLload file -> xmlscenestr in
  let XMLgetMarkByValue xmlscenestr "scene" -> srcgroupmark in
  let if !mode then
        newOsSceneGroup viewstr xmlEditSceneFile destgroupmark groupname nil nil father nil nil nil treefather 0 0
      else
        [(switch lGroups destgroupmark) father treefather]
  -> [groupstr newgroupshell treenode] in
  (
    getResourcesScriptFiles groupstr lscripts;
    
    if groupstr.GRP_iWaitForLoad > 0 then
    (
      _rfltimer _starttimer _channel 1000 @cbIsOgreMaxSceneReadyToImport [viewstr groupstr srcgroupmark groupstr.GRP_xmlMark newgroupshell treenode];
      0;
    )
    else
    (
      loadGroupResources groupstr viewstr groupstr.GRP_xmlMark;

      let XMLgetMarkByValueFromMarkSons srcgroupmark "environment" -> envxml in
      if envxml == nil then nil else
        _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Import environment" "An environment setting has been found in imported scene\n Do you want to import this environment setting ?" 2 @cbDlgLoadEnvironment [viewstr srcgroupmark];
      
      let XMLgetMarkByValueFromMarkSons srcgroupmark "nodes" -> srcnodesmark in
      let XMLgetMarkByValueFromMarkSons groupstr.GRP_xmlMark "graph" -> destgraphmark in
      let atof XMLgetParam srcgroupmark "unitsPerMeter" -> units in
      let if units == nil then (1.0 *. (itof iGlobalUnit)) else (units /. (itof iGlobalUnit)) -> units in
        loadOgreMaxNodes viewstr srcnodesmark destgraphmark groupstr.GRP_xmlMark newgroupshell treenode units 1;
      
      addLogMessage "Scene loaded.";
      0;
    );
    
    //refresh groups tab
    paintEdCtrlModuleEditor mainInterf.MINT_meGroups;
    
    selEdCtrlTreeItem ctrlSceneTree treenode;
  );
  0;;

fun cbIsOsGroupReady(trm, p)=
  let p -> [viewstr groupstr srcgroupmark destgroupmark father treefather import first] in
  if groupstr.GRP_iWaitForLoad > 0 then nil else
  (
    _deltimer trm;    
    loadGroupResources groupstr viewstr destgroupmark;
    let XMLgetMarkByValueFromMarkSons srcgroupmark "environment" -> envxml in
    if envxml != nil && import then
    (
      _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Import environment" "An environment setting has been found in imported scene\n Do you want to import this environment setting ?" 2 @cbDlgLoadEnvironment [viewstr srcgroupmark];
      0;
    )
    else
    (
      loadEnvironment viewstr srcgroupmark;
      0;
    );

    let XMLgetMarkByValueFromMarkSons srcgroupmark "graph" -> srcnodesmark in
    let XMLgetMarkByValueFromMarkSons destgroupmark "graph" -> destgraphmark in
      loadOsGraph groupstr viewstr srcnodesmark destgraphmark destgroupmark father treefather import;     
    
    let XMLgetMarksByValueFromMarkSons srcgroupmark "group" -> lsrcgroups in
    let sizelist lsrcgroups -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lsrcgroups i -> nextgroupmark in    
      let if import then nil else XMLgetParam nextgroupmark "id" -> id in
      let atoi XMLgetParam nextgroupmark "px" -> plx in
      let atoi XMLgetParam nextgroupmark "py" -> ply in
      let XMLgetParam nextgroupmark "name" -> nodename in
      let XMLgetParam nextgroupmark "alias" -> alias in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let if nodeposstr == nil then [0.0 0.0 0.0] else [xpos ypos zpos] -> pos in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let if noderotstr == nil then [0.0 0.0 0.0 1.0] else [xang yang zang wang] -> ang in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      let if nodescalestr == nil then [1.0 1.0 1.0] else [xscale yscale zscale] -> scale in
      let newOsSceneGroup viewstr xmlEditSceneFile destgroupmark nodename (atoi id) alias father scale pos ang treefather plx ply -> [groupstr newgroupshell treenode] in
      (
        if !import then nil else
          set lTmpLinksImport = [strcatn (XMLgetParam nextgroupmark "id")::"."::nodename::nil groupstr.GRP_sName]::lTmpLinksImport;

        loadOsGroup viewstr groupstr nextgroupmark groupstr.GRP_xmlMark newgroupshell treenode import 0;
      );
      
      set i = i + 1;
    );
    
    // done after sons groups loaded to get all links (for rewrite on import)
    let XMLgetMarkByValueFromMarkSons srcgroupmark "PLUGINS" -> pluginsmark in
    let XMLgetMarksByValueFromMarkSons pluginsmark "PLUGIN" -> lpluginmarks in
    let XMLgetMarkByValueFromMarkSons destgroupmark "PLUGINS" -> destpluginsmark in
    if pluginsmark == nil then nil else
    (
      XMLsetParam destpluginsmark "filterLinks" XMLgetBoolString (XMLgetBoolParam pluginsmark "filterLinks");
      
      let sizelist lpluginmarks -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lpluginmarks i -> plugmark in
          XMLcopyMark xmlEditSceneFile plugmark destpluginsmark;
          
        set i = i + 1;
      );
    );
    
    // update obj/groups idx in plugins params and links
    if !import then
    (
      loadOsPlugins groupstr;
      0;
    )
    else if import && first then
    (
      let sizelist lTmpLinksImport -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lTmpLinksImport i -> [olgrpname newgrpname] in
        let getGraphByValue newgrpname -> tgraph in
        let tgraph -> [treeitem type alias markstr path groupmark initstate staticgeometry] in
        let switch lGroups markstr -> ngroupstr in
        (
          updatePluginInstancesOnImport ngroupstr;
          loadOsPlugins ngroupstr;
        );
        set i = i + 1;
      );
    )
    else nil;
    
    set iWaitUntilLoad = iWaitUntilLoad - 1;
    //addLogMessage "Group loaded.";
  );
  0;;


fun loadOsGroup(viewstr, groupstr, srcgroupmark, destgroupmark, father, treefather, import, first)=
  set iWaitUntilLoad = iWaitUntilLoad + 1;
  getOsGroupResources groupstr srcgroupmark;
  // load ressources script
  getResourcesScriptFilesFromGroup groupstr;  
  
  if (groupstr.GRP_iWaitForLoad > 0) then
  (
    _rfltimer _starttimer _channel 1000 @cbIsOsGroupReady [viewstr groupstr srcgroupmark destgroupmark father treefather import first];
    0;
  )
  else
  (
    loadGroupResources groupstr viewstr destgroupmark;
    
    let XMLgetMarkByValueFromMarkSons srcgroupmark "environment" -> envxml in
    if envxml != nil && import then
    (
      _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Import environment" "An environment setting has been found in imported scene\n Do you want to import this environment setting ?" 2 @cbDlgLoadEnvironment [viewstr srcgroupmark];
      0;
    )
    else
    (
      loadEnvironment viewstr srcgroupmark;
      0;
    );
    
    let XMLgetMarkByValueFromMarkSons srcgroupmark "graph" -> srcnodesmark in
    let XMLgetMarkByValueFromMarkSons destgroupmark "graph" -> destgraphmark in
      loadOsGraph groupstr viewstr srcnodesmark destgraphmark destgroupmark father treefather import;      
    
    let XMLgetMarksByValueFromMarkSons srcgroupmark "group" -> lsrcgroups in
    let sizelist lsrcgroups -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lsrcgroups i -> nextgroupmark in
      let if import then nil else atoi (XMLgetParam nextgroupmark "id") -> id in
      let XMLgetParam nextgroupmark "name" -> nodename in
      let XMLgetParam nextgroupmark "alias" -> alias in
      let atoi XMLgetParam nextgroupmark "px" -> plx in
      let atoi XMLgetParam nextgroupmark "py" -> ply in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "position" -> nodeposstr in
      let atof XMLgetParam nodeposstr "x" -> xpos in
      let atof XMLgetParam nodeposstr "y" -> ypos in
      let atof XMLgetParam nodeposstr "z" -> zpos in
      let if nodeposstr == nil then [0.0 0.0 0.0] else [xpos ypos zpos] -> pos in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "rotation" -> noderotstr in
      let atof XMLgetParam noderotstr "qx" -> xang in
      let atof XMLgetParam noderotstr "qy" -> yang in
      let atof XMLgetParam noderotstr "qz" -> zang in
      let atof XMLgetParam noderotstr "qw" -> wang in
      let if noderotstr == nil then [0.0 0.0 0.0 1.0] else [xang yang zang wang] -> ang in
      let XMLgetMarkByValueFromMarkSons nextgroupmark "scale" -> nodescalestr in
      let atof XMLgetParam nodescalestr "x" -> xscale in
      let atof XMLgetParam nodescalestr "y" -> yscale in
      let atof XMLgetParam nodescalestr "z" -> zscale in
      let if nodescalestr == nil then [1.0 1.0 1.0] else [xscale yscale zscale] -> scale in
      let newOsSceneGroup viewstr xmlEditSceneFile destgroupmark nodename id alias father scale pos ang treefather plx ply -> [groupstr newgroupshell treenode] in
      (
        if !import then nil else
          set lTmpLinksImport = [strcatn (XMLgetParam nextgroupmark "id")::"."::nodename::nil groupstr.GRP_sName]::lTmpLinksImport;
        
        loadOsGroup viewstr groupstr nextgroupmark groupstr.GRP_xmlMark newgroupshell treenode import 0;
      );
      
      set i = i + 1;
    );
    
    loadCinematics viewstr groupstr srcgroupmark import;
    
    // done after sons groups loaded to get all links (for rewrite on import)
    let XMLgetMarkByValueFromMarkSons srcgroupmark "PLUGINS" -> pluginsmark in
    let XMLgetMarksByValueFromMarkSons pluginsmark "PLUGIN" -> lpluginmarks in
    let XMLgetMarkByValueFromMarkSons destgroupmark "PLUGINS" -> destpluginsmark in
    if pluginsmark == nil then nil else
    (
      XMLsetParam destpluginsmark "filterLinks" XMLgetBoolString (XMLgetBoolParam pluginsmark "filterLinks");
      
      let sizelist lpluginmarks -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lpluginmarks i -> plugmark in
        let XMLgetParam plugmark "source" -> plugsource in
        let XMLgetParam plugmark "name" -> plugname in
        let strcatn sPLUGINSPATH::"/"::plugsource::nil -> pluginfile in
        let getPluginByFile pluginfile -> plugstr in
        let substr pluginfile ((strlen sPLUGINSPATH) + 1) 1024 -> plugfile in
        let XMLcopyMark xmlEditSceneFile plugmark destpluginsmark -> xmlcp in
        (
          XMLsetParam xmlcp "source" plugfile;
          XMLsetParam xmlcp "name" if (plugstr.PLUG_sName == nil) then plugname else plugstr.PLUG_sName;
        );
        
        set i = i + 1;
      );
    );
    
    // update obj/groups idx in plugins params and links
    if !import then
    (
      loadOsPlugins groupstr;
      0;
    )
    else if import && first then
    (
      let sizelist lTmpLinksImport -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lTmpLinksImport i -> [olgrpname newgrpname] in
        let getGraphByValue newgrpname -> tgraph in
        let tgraph -> [treeitem type alias markstr path groupmark initstate staticgeometry] in
        let switch lGroups markstr -> ngroupstr in
        (
          updatePluginInstancesOnImport ngroupstr;
          loadOsPlugins ngroupstr;
        );
        set i = i + 1;
      );
    )
    else nil;
    
    set iWaitUntilLoad = iWaitUntilLoad - 1;
    //addLogMessage strcat "Group loaded : " groupstr.GRP_sName;
    0;
  );
  0;;


fun sceneLoaded(file)=  
  // repaint groups tab
  paintEdCtrlModuleEditor mainInterf.MINT_meGroups;
  
  addLogMessage strcatn file::" loaded."::nil;
  0;;


fun cbIsSceneLoaded(trm, file)=
  if (iWaitUntilLoad > 0) then nil else
  (
    _deltimer trm;
    sceneLoaded file;
  );
  0;;


fun setProjectSetting(key, value)=
  let XMLgetMarkByValue xmlEditSceneFile "project" -> srcprjmark in
  let XMLgetMarkByValueFromMarkSons srcprjmark "setting" -> srcsettingmark in
  let if (srcsettingmark == nil) then XMLaddMark xmlEditSceneFile "setting" srcprjmark nil nil else srcsettingmark -> srcsettingmark in
  let XMLgetMarkByValueFromMarkSons srcsettingmark key -> keymark in
  if (keymark == nil) then 
  (
    XMLaddMark xmlEditSceneFile key srcsettingmark nil value;
    0;
  )
  else
  (
    XMLsetData keymark value;
    0;
  );
  0;;


fun getProjectSetting(key)=
  let XMLgetMarkByValue xmlEditSceneFile "project" -> srcprjmark in
  let XMLgetMarkByValueFromMarkSons srcprjmark "setting" -> srcsettingmark in
    XMLgetData (XMLgetMarkByValueFromMarkSons srcsettingmark key);;


fun getProjectName()=
  let XMLgetMarkByValue xmlEditSceneFile "project" -> srcprjmark in
  let XMLgetMarkByValueFromMarkSons srcprjmark "setting" -> srcsettingmark in
  let XMLgetData (XMLgetMarkByValueFromMarkSons srcsettingmark "projectName") -> projname in
  if projname != nil then
    projname
  else
    getFileNameWithoutExt sCurrentScenePath;;


fun loadProjectSetting(xmlfilestr)=
  let XMLgetMarkByValue xmlfilestr "project" -> srcprjmark in
  let XMLgetMarkByValueFromMarkSons srcprjmark "setting" -> srcsettingmark in
  let XMLgetData (XMLgetMarkByValueFromMarkSons srcsettingmark "Author") -> author in

  let XMLgetMarkByValue xmlEditSceneFile "project" -> destprjmark in
  (
    // copy current setting to new xml
    XMLcopyMark xmlEditSceneFile srcsettingmark destprjmark;
    
    setProjectSetting "projectName" getProjectName;
  );
  0;;


fun cbResourcesTabFocused(tabstr, list)=
  resetEdCtrlList list;
  let getGraphByValue sSelected -> tgraph in
  let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in
  let if ttype == iTypeGroup || ttype == iTypeScene then markstr else groupmark -> groupmark in  
  let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
  let XMLgetMarksByValueFromMarkSons resourcesmark "resource" -> lresourcemarks in
  (
    let sizelist lresourcemarks -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lresourcemarks i -> resourcemark in
      let XMLgetParam resourcemark "type" -> type in
      let XMLgetParam resourcemark "path" -> path in
        addEdCtrlList list (strlowercase path) nil nil; 
      
      set i = i + 1;
    );
  );
  0;;


fun cbMeshesTabFocused(tabstr, list)=
  resetEdCtrlList list;
  let getGraphByValue sSelected -> tgraph in
  let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in
  let if ttype == iTypeGroup || ttype == iTypeScene then markstr else groupmark -> groupmark in
  let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
  let XMLgetMarksByValueFromMarkSons resourcesmark "resource" -> lresourcemarks in
  (
    let sizelist lresourcemarks -> size in
    let 0 -> i in
    while i < size do
    (
      let nth_list lresourcemarks i -> resourcemark in
      let XMLgetParam resourcemark "type" -> type in
      let XMLgetParam resourcemark "path" -> path in
      if (getResourceTypeByName type) != SO3_RESOURCE_MESH then nil else
        addEdCtrlList list (strlowercase path) nil nil; 
      
      set i = i + 1;
    );
  ); 
  0;;


fun loadOs3DScene(viewstr, file)=
  if (!strcmp (strtrim file) "") || (file == nil) then nil else
  (
    set iWaitUntilLoad = 0;
    
    set sCurrentScenePath = file;
    addLogMessage strcatn "Loading OpenSpace 3D scene file : "::file::nil;
    let getPathFile file "" -> [dir _] in
    if (dir == nil) || (!strcmp "" (strtrim dir)) then nil else
      addOsResourceDir dir::nil;
    
    let XMLload file -> xmlscenestr in
    let XMLgetMarkByValue xmlscenestr "scene" -> srcgroupmark in
    // scene not found but we look for an exported group
    let if srcgroupmark == nil then
      let XMLgetMarkByValue xmlscenestr "group" -> grpstr in
      let strcatn (XMLgetParam grpstr "id")::"."::(XMLgetParam grpstr "name")::nil -> grpname in
      (
        // replace self links group by scene
        let XMLgetMarksByValue xmlscenestr "link" -> llinks in
        let sizelist llinks -> size in
        let 0 -> i in
        while (i < size) do
        (
          let nth_list llinks i -> linkstr in
          let XMLgetParam linkstr "group" -> glink in
          (
            if (strcmpi glink grpname) then nil else
              XMLsetParam linkstr "group" "Scene";
          );
          set i = i + 1;
        );
        grpstr;
      )
      else
        srcgroupmark
    -> srcgroupmark in
    
    let XMLgetMarkByValue xmlEditSceneFile "scene" -> destgroupmark in
    
    
    let switch lGroups destgroupmark -> groupstr in
    let atoi XMLgetParam srcgroupmark "px" -> plx in
    let atoi XMLgetParam srcgroupmark "py" -> ply in
    (
      XMLsetParam destgroupmark "px" (itoa plx);
      XMLsetParam destgroupmark "py" (itoa ply);
      
      // load project setting
      loadProjectSetting xmlscenestr;
      
      setEdCtrlModuleEditorBoxPos mainInterf.MINT_meGroups (getEdCtrlModuleEditorBoxByName mainInterf.MINT_meGroups "Scene") plx ply;
      loadOsGroup viewstr groupstr srcgroupmark destgroupmark nil (getEdCtrlTreeRootItem ctrlSceneTree) 0 1;
      
      //TODO update resources (meshes and skeleton animations)
    );
    
    setEdWindowName mainInterf.MINT_winMain strcatn "OpenSpace3D Editor : "::getVersionName::" > "::sCurrentScenePath::nil;

    if (iWaitUntilLoad > 0) then
    (
      _rfltimer _starttimer _channel 1000 @cbIsSceneLoaded file;
      0;
    )
    else
    (
      sceneLoaded file;
      0;
    );
    
    cbResourcesTabFocused nil ctrlResourcesList;
    cbMeshesTabFocused nil ctrlMeshList;
  );
  0;;


fun importOs3DScene(viewstr, file, destgroupmark, father, treefather)=
  if (!strcmp (strtrim file) "") || (file == nil) then nil else
  (
    set iWaitUntilLoad = 0;
    addLogMessage strcatn "Importing OpenSpace 3D scene file : "::file::nil;
    
    let getPathFile file "" -> [dir _] in
    if (dir == nil) || (!strcmp "" (strtrim dir)) then nil else
      addOsResourceDir dir::nil;
    
    let XMLload file -> xmlscenestr in
    let XMLgetMarkByValue xmlscenestr "scene" -> srcgroupmark in
    let if srcgroupmark == nil then XMLgetMarkByValue xmlscenestr "group" else srcgroupmark -> srcgroupmark in
    if srcgroupmark == nil then
    (
      addLogMessage strcatn "Error while importing scene or group : "::file::nil;
      _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" strcatn "Error while importing scene or group : "::file::nil 0;
      0;
    )
    else
    (
      let (XMLgetParam srcgroupmark "name") -> sname in
      let if sname == nil then (getFileNameWithoutExt file) else sname -> sname in
      let newOsSceneGroup viewstr xmlEditSceneFile destgroupmark sname nil nil father nil nil nil treefather 0 0 -> [groupstr newgroupshell treenode] in
      (
        let (XMLgetParam srcgroupmark "id") -> sid in
        let if sid == nil then "Scene" else strcatn sid::"."::sname::nil -> oldmarkname in
          set lTmpLinksImport = [oldmarkname groupstr.GRP_sName]::nil;
        
        loadOsGroup viewstr groupstr srcgroupmark groupstr.GRP_xmlMark newgroupshell treenode 1 1;
        
        if (iWaitUntilLoad > 0) then
        (
          _rfltimer _starttimer _channel 1000 @cbIsSceneLoaded file;
          0;
        )
        else
        (
          sceneLoaded file;
          0;
        );
        
        selEdCtrlTreeItem ctrlSceneTree treenode;
        cbResourcesTabFocused nil ctrlResourcesList;
        cbMeshesTabFocused nil ctrlMeshList;
      );
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  Clone
/ ********************************************************************************************* */
fun cloneNode(viewstr, val, type, markstr, groupmark, item)=
  let switch lGroups groupmark -> groupstr in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getEdCtrlTreeFatherItem ctrlSceneTree item -> treefather in
  let SO3ObjectGetParent (SO3SceneGetObject (V3DgetSession sessionstr) val) -> father in
  let XMLcreate nil nil -> nxmlstr in
  if type == iTypeGroup then
  (
    set lTmpLinksImport = nil;
    let XMLaddMark nxmlstr "group" nil nil nil -> nodestr in
    let XMLcopyMark nxmlstr markstr nodestr -> nmark in
      loadOsGroup viewstr groupstr nodestr groupstr.GRP_xmlMark father treefather 2 1;
  )
  else
  (
    let XMLaddMark nxmlstr "node" nil nil nil -> nodestr in
    let XMLcopyMark nxmlstr markstr nodestr -> nmark in
      loadOsGraph groupstr viewstr nodestr markstr.XMLfather groupmark father treefather 2;
  );
  
  // reset undo / redo
  resetObjHistory;
  0;;


/* ********************************************************************************************* /
  Axis
/ ********************************************************************************************* */
fun cbAxisMove(sessionstr, obj, axis, x, y, btn, coef, p)=
  let p -> [tgraph viewstr] in
  let tgraph -> [treeitem type alias markstr path groupmark initstate staticgeometry] in
  let /*if type != iTypeBone then SO3_LOCAL_TS else SO3_PARENT_TS*/ SO3_LOCAL_TS -> rep in
  (
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    /*
    // reinit particle to use the same way than particles
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    */
    
    if (btn & 1) && (iViewerEditMode == 1) then
    (
      let if axis == V3DAXIS_X then
          [coef 0.0 0.0]
        else if axis == V3DAXIS_Y then
          [0.0 coef 0.0]
        else if axis == V3DAXIS_Z then
          [0.0 0.0 coef]
        else nil
      -> trans in
      SO3ObjectTranslate obj trans rep;
      
      let XMLgetMarkByValueFromMarkSons markstr "position" -> objpositionstr in
      let SO3ObjectGetPosition obj -> [opx opy opz] in
      (
        XMLsetParam objpositionstr "x" XMLgetShortFloatToString opx;
        XMLsetParam objpositionstr "y" XMLgetShortFloatToString opy;
        XMLsetParam objpositionstr "z" XMLgetShortFloatToString opz;
        
        let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
        if obj != wobj || mode != 1 then nil else
        let SO3ObjectGetGlobalPosition obj -> [ogpx ogpy ogpz] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx opx;
          setEdCtrlFloatValueWithoutCallback ctrly opy;
          setEdCtrlFloatValueWithoutCallback ctrlz opz;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx ogpx;
          setEdCtrlFloatValueWithoutCallback ctrlgy ogpy;
          setEdCtrlFloatValueWithoutCallback ctrlgz ogpz;
        );
      );
      0;
    )
    else if (btn & 1) && (iViewerEditMode == 2) then
    (
      if axis == V3DAXIS_X then
        SO3ObjectRotatePitch obj (SO3MathsDegreeToRadian (itof y + x)) rep
      else if axis == V3DAXIS_Y then
        SO3ObjectRotateYaw obj (SO3MathsDegreeToRadian (itof y + x)) rep
      else if axis == V3DAXIS_Z then
        SO3ObjectRotateRoll obj (SO3MathsDegreeToRadian (itof y + x)) rep
      else nil;
      
      let XMLgetMarkByValueFromMarkSons markstr "rotation" -> objorientationstr in
      let SO3ObjectGetOrientation obj -> [qx qy qz qw] in
      (
        XMLsetParam objorientationstr "qx" XMLgetShortFloatToString qx;
        XMLsetParam objorientationstr "qy" XMLgetShortFloatToString qy;
        XMLsetParam objorientationstr "qz" XMLgetShortFloatToString qz;
        XMLsetParam objorientationstr "qw" XMLgetShortFloatToString qw;
        
        let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
        if obj != wobj || mode != 2 then nil else

        let SO3MathsQuatToEulerYXZ [qx qy qz qw] -> [ex ey ez] in
        let SO3ObjectGetGlobalOrientation obj -> gquat in
        let SO3MathsQuatToEulerYXZ gquat -> [egx egy egz] in
        let SO3MathsRadianToDegree egx -> egx in
        let SO3MathsRadianToDegree egy -> egy in
        let SO3MathsRadianToDegree egz -> egz in
    
        let SO3MathsRadianToDegree ex -> ex in
        let SO3MathsRadianToDegree ey -> ey in
        let SO3MathsRadianToDegree ez -> ez in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx ex;
          setEdCtrlFloatValueWithoutCallback ctrly ey;
          setEdCtrlFloatValueWithoutCallback ctrlz ez;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx egx;
          setEdCtrlFloatValueWithoutCallback ctrlgy egy;
          setEdCtrlFloatValueWithoutCallback ctrlgz egz;
        );
      );
      0;
    )
    else if (btn & 1) && (iViewerEditMode == 3) then
    (
      let SO3ObjectGetGlobalScale obj -> [gcsx gcsy gcsz] in
      let SO3ObjectGetScale obj -> [csx csy csz] in
      let [(coef *. (gcsx *. (itof iGlobalUnit))) (coef *. (gcsy *. (itof iGlobalUnit))) (coef *. (gcsz *. (itof iGlobalUnit)))] -> [coefx coefy coefz] in
      let if _keybdstate &4 then //alt
          [(if ((csx +. coefx) <=. 0.00001) then 0.00001 else (csx +. coefx)) (if ((csy +. coefy) <=. 0.00001) then 0.00001 else (csy +. coefy)) (if ((csz +. coefz) <=. 0.00001) then 0.00001 else (csz +. coefz))]
        else if axis == V3DAXIS_X then
          [(if ((csx +. coefx) <=. 0.00001) then 0.00001 else (csx +. coefx)) csy csz]
        else if axis == V3DAXIS_Y then
          [csx (if ((csy +. coefy) <=. 0.00001) then 0.00001 else (csy +. coefy)) csz]
        else if axis == V3DAXIS_Z then
          [csx csy (if ((csz +. coefz) <=. 0.00001) then 0.00001 else (csz +. coefz))]
        else nil
      -> scale in
        SO3ObjectSetScale obj scale;
      
      let XMLgetMarkByValueFromMarkSons markstr "scale" -> objscalestr in
      let SO3ObjectGetScale obj -> [sx sy sz] in
      (
        XMLsetParam objscalestr "x" XMLgetShortFloatToString sx;
        XMLsetParam objscalestr "y" XMLgetShortFloatToString sy;
        XMLsetParam objscalestr "z" XMLgetShortFloatToString sz;
  
        let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
        if obj != wobj || mode != 3 then nil else
        let SO3ObjectGetGlobalScale obj -> [sgx sgy sgz] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx sx;
          setEdCtrlFloatValueWithoutCallback ctrly sy;
          setEdCtrlFloatValueWithoutCallback ctrlz sz;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx sgx;
          setEdCtrlFloatValueWithoutCallback ctrlgy sgy;
          setEdCtrlFloatValueWithoutCallback ctrlgz sgz;
        );
      );
      0;
    )
    else nil;
  );
  0;;


fun cbAxisUnClick(sessionstr, obj, axis, x, y, btn, p)=
  // update body on scale
  let p -> [tgraph viewstr initparams] in
  let tgraph -> [treeitem type alias markstr path groupmark initstate staticgeometry] in
  (
    if (btn & 1) && (iViewerEditMode == 3) then
    (
      updateSonsPhysicsBody sessionstr markstr obj;
      0;
    )
    else if (btn & 2) then
    (
      //restore previous position orientation scale
      let initparams -> [[px py pz] [qx qy qz qw] [sx sy sz]] in
      let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
      (
        let XMLgetMarkByValueFromMarkSons markstr "position" -> objpositionstr in
        let XMLgetMarkByValueFromMarkSons markstr "rotation" -> objorientationstr in
        let XMLgetMarkByValueFromMarkSons markstr "scale" -> objscalestr in
        (
          XMLsetParam objpositionstr "x" XMLgetShortFloatToString px;
          XMLsetParam objpositionstr "y" XMLgetShortFloatToString py;
          XMLsetParam objpositionstr "z" XMLgetShortFloatToString pz;
          
          XMLsetParam objorientationstr "qx" XMLgetShortFloatToString qx;
          XMLsetParam objorientationstr "qy" XMLgetShortFloatToString qy;
          XMLsetParam objorientationstr "qz" XMLgetShortFloatToString qz;
          XMLsetParam objorientationstr "qw" XMLgetShortFloatToString qw;
          
          XMLsetParam objscalestr "x" XMLgetShortFloatToString sx;
          XMLsetParam objscalestr "y" XMLgetShortFloatToString sy;
          XMLsetParam objscalestr "z" XMLgetShortFloatToString sz;
        );
          
        SO3ObjectSetPosition obj [px py pz];
        SO3ObjectSetOrientation obj [qx qy qz qw];
        SO3ObjectSetScale obj [sx sy sz];
        
        if obj != wobj || mode != 1 then nil else
        let SO3ObjectGetGlobalPosition obj -> [ogpx ogpy ogpz] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx px;
          setEdCtrlFloatValueWithoutCallback ctrly py;
          setEdCtrlFloatValueWithoutCallback ctrlz pz;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx ogpx;
          setEdCtrlFloatValueWithoutCallback ctrlgy ogpy;
          setEdCtrlFloatValueWithoutCallback ctrlgz ogpz;
        );
        
        if obj != wobj || mode != 2 then nil else
        let SO3MathsQuatToEulerYXZ [qx qy qz qw] -> [ex ey ez] in
        let SO3ObjectGetGlobalOrientation obj -> gquat in
        let SO3MathsQuatToEulerYXZ gquat -> [egx egy egz] in
        let SO3MathsRadianToDegree egx -> egx in
        let SO3MathsRadianToDegree egy -> egy in
        let SO3MathsRadianToDegree egz -> egz in
    
        let SO3MathsRadianToDegree ex -> ex in
        let SO3MathsRadianToDegree ey -> ey in
        let SO3MathsRadianToDegree ez -> ez in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx ex;
          setEdCtrlFloatValueWithoutCallback ctrly ey;
          setEdCtrlFloatValueWithoutCallback ctrlz ez;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx egx;
          setEdCtrlFloatValueWithoutCallback ctrlgy egy;
          setEdCtrlFloatValueWithoutCallback ctrlgz egz;
        );
        
        if obj != wobj || mode != 3 then nil else
        let SO3ObjectGetGlobalScale obj -> [sgx sgy sgz] in
        (
          setEdCtrlFloatValueWithoutCallback ctrlx sx;
          setEdCtrlFloatValueWithoutCallback ctrly sy;
          setEdCtrlFloatValueWithoutCallback ctrlz sz;
          
          setEdCtrlFloatValueWithoutCallback ctrlgx sgx;
          setEdCtrlFloatValueWithoutCallback ctrlgy sgy;
          setEdCtrlFloatValueWithoutCallback ctrlgz sgz;
        );
        
        0;
      );
    )
    else nil;
    
    V3DsetCbClick viewstr @cbView3dClick;
    V3DsetCbUnClick viewstr @cbView3dUnClick;
  );
  0;;


fun cbAxisClick(sessionstr, obj, axis, x, y, btn, viewstr)=
  let SO3ObjectGetName obj -> sname in
  let getGraphByValue sname -> tgraph in
  let [SO3ObjectGetPosition obj SO3ObjectGetOrientation obj SO3ObjectGetScale obj] -> initparams in
  if tgraph == nil then nil else
  let tgraph -> [treeitem type alias markstr path groupmark initstate staticgeometry] in
  (
    //TODO manage clone ?
    addObjHistoryState sname markstr obj iViewerEditMode;
    
    if ((btn == 1) && (_keybdstate &1) && iViewerEditMode) then //shift
    (
      if type == iTypeScene then nil else
      (
        cloneNode viewstr sname type markstr groupmark treeitem;
        let getEdCtrlTreeSelectedItem ctrlSceneTree -> item in
        let getEdCtrlTreeValueByItem ctrlSceneTree item -> [nval _] in
        let getGraphByValue nval -> ntgraph in
        (
          V3DsetCbAxisMove sessionstr mkfun8 @cbAxisMove [ntgraph viewstr];
          V3DsetCbAxisUnClick sessionstr mkfun7 @cbAxisUnClick [ntgraph viewstr initparams];
          V3DchangeSelectedAxis sessionstr nval axis;
          0;
        );
      );
    )
    else
    (
      V3DsetCbAxisMove sessionstr mkfun8 @cbAxisMove [tgraph viewstr];
      V3DsetCbAxisUnClick sessionstr mkfun7 @cbAxisUnClick [tgraph viewstr initparams];
      0;
    );
    
    V3DsetCbClick viewstr nil;
    V3DsetCbUnClick viewstr nil;
  );
  0;;


/**  initScene [V3Dview V3Dsession] I
  *  init default scene parameters
  *  
  *  parameters are :
  *  - view 3d structure
  *  - session 3d structure
  *
  *  return 0
  **/
fun initScene(viewstr, sessionstr)=
  renderingDestroySetting viewstr;
  
  dsEdWindow settingWindow;
  set settingWindow = nil;
  
  resetObjHistory;
  physicsResetScene;
  shadowsResetScene sessionstr;
  
  set bPhysicOnPlay = 0;
  set sCurrentScenePath = nil;
  //let mainInterf.MINT_winLogs -> [_ _ ctrltext] in
  //  setEdCtrlTextValue ctrltext "";
  addLogMessage "Init default scene.";
  
  set iCurSceneIdx = 0;
  
  clearModLinks this;
  destroyAllPluginInstances;
  
  // destroy links param windows
  let sizelist mainInterf.MINT_lLinksConfig -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list mainInterf.MINT_lLinksConfig i -> [_ [winstr _ _]] in
      dsEdWindow winstr;
    
    set i = i + 1;
  );
  
  set mainInterf.MINT_lLinksConfig = nil;
  
  // destroy instance param windows
  let sizelist mainInterf.MINT_lInstanceConfig -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list mainInterf.MINT_lInstanceConfig i -> [_ winstr] in
      dsEdWindow winstr;
    
    set i = i + 1;
  );
  
  set mainInterf.MINT_lInstanceConfig = nil;
  
  // reset groups list and tabs
  let mainInterf.MINT_winPlugins -> [plugswinstr [tbstr tabbarstr minmaxchk1]] in
  let sizelist lGroups -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list lGroups i -> [_ groupstr] in
      dsEdTab tabbarstr groupstr.GRP_tabPlugins;
    set i = i + 1;
  );
  
  set lGroups = nil;
  
  set mainInterf.MINT_lLinks = nil;
  resetEdCtrlModuleEditor mainInterf.MINT_meGroups;
  
  let mainInterf.MINT_winView -> [_ [tbstr _ chkplay chkselect chkmove chkrotate chkscale btnundo btnredo chknav chkgrid chkhelpers chkinfos chkwiremode btntop btnfront btnleft btnpers]] in
  (
    if !iNavigationMode then nil else
    (
      set tLastNavPos = avNavStr.AV_pos;
      stopAvNavMode viewstr;
    );
    
    setEdToolBarCheckEnable tbstr chkselect 1;
    setEdToolBarCheckEnable tbstr chkmove 1;
    setEdToolBarCheckEnable tbstr chkrotate 1;
    setEdToolBarCheckEnable tbstr chkscale 1;
    setEdToolBarCheckEnable tbstr chknav 1;
    setEdToolBarCheckEnable tbstr chkgrid 1;
    setEdToolBarCheckEnable tbstr chkhelpers 1;
    
    setEdToolBarCheckEnable tbstr chkwiremode 1;
    setEdToolBarCheckState tbstr chkplay 0;
    //setEdToolBarCheckState tbstr chknav 0;
    //setEdToolBarCheckState tbstr chkgrid 1;
    //setEdToolBarCheckState tbstr chkhelpers 1;
    //setEdToolBarCheckState tbstr chkinfos 0;
    
    updateToolbarHistoryBtn;
    
    setEdToolBarButtonEnable tbstr btntop 1;
    setEdToolBarButtonEnable tbstr btnfront 1;
    setEdToolBarButtonEnable tbstr btnleft 1;
    setEdToolBarButtonEnable tbstr btnpers 1;
    
    set bAppPlay = 0;
    //set bShowWireMode = 0;
    //set iNavigationMode = 0;
    //set bShowGrid = 1;
    //set bShowHelpers = 1;
    //set bShowInfos = 0;
    //V3DenableScreenInfos viewstr bShowInfos;
  );
  
  shadowsDestroySetting;
  
  physicsDestroySetting;
  
  environmentDestroySetting;
  
  let winLightSetup -> [_ winstr] in
    dsEdWindow winstr;
  set winLightSetup = nil;
  
  dsEdWindow winFogSetup;
  set winFogSetup = nil;
  
  dsEdWindow winMatSchemeSetup;
  set winMatSchemeSetup = nil;
  
  let winCameraSetup -> [_ winstr] in
    dsEdWindow winstr;
  set winCameraSetup = nil;
  
  let winCoordsSetup -> [_ _ winstr _ _ _ _ _ _ _ _ _] in
    dsEdWindow winstr;
  set winCoordsSetup = nil;
  
  let winAnimSetup -> [_ winstr _ _ _] in
    dsEdWindow winstr;
  set winAnimSetup = nil;
  
  let winParticleSetup -> [_ winstr _ _] in
    dsEdWindow winstr;
  set winParticleSetup = nil;

  let winCubeMapSetup -> [_ winstr _ _] in
    dsEdWindow winstr;
  set winCubeMapSetup = nil;

  let winReflectionMapSetup -> [_ winstr _ _] in
    dsEdWindow winstr;
  set winReflectionMapSetup = nil;

  let winCompositorSetup -> [_ winstr] in
    dsEdWindow winstr;
  set winCompositorSetup = nil;
  
  let winNodeSetup -> [_ winstr] in
    dsEdWindow winstr;
  set winNodeSetup = nil;
  
  let winEntitySetup -> [_ winstr] in
    dsEdWindow winstr;
  set winEntitySetup = nil;
  
  let winEntityInfo -> [_ winstr] in
    dsEdWindow winstr;
  set winEntityInfo = nil;
  
  dsEdWindow winExportSetup;
  set winExportSetup = nil;
  
  let winSkySetup -> [sname winstr] in
    dsEdWindow winstr;
  set winSkySetup = nil;
  
  dsEdWindow winImportScene;
  set winImportScene = nil;

  let winMeshMaterialSetup -> [_ swinstr] in
    dsEdWindow swinstr;
  set winMeshMaterialSetup = nil;

  resetEdCtrlTree ctrlSceneTree;
  resetEdCtrlList ctrlResourcesDirList; 
  resetEdCtrlList ctrlResourcesList;
  resetEdCtrlList ctrlMeshList;
  
  set lSceneGraph = nil;
  set lResourcesPath = nil;
  
  V3DresetSession sessionstr;
  V3DenableScreenInfos viewstr bShowInfos;
  V3DshowSceneGrid sessionstr bShowGrid;
  V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr bShowHelpers;
  
  // reset resources groups
  let SO3GroupList (V3DgetSession sessionstr) -> l in
  let sizelist l -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list l i -> resgroup in
    if (!strcmp resgroup "V3DdefaultResources") then nil else
      SO3GroupDelete (V3DgetSession sessionstr) resgroup;
    
    set i = i + 1;
  );
  
  SO3CbLogs _channel @cbOgreLogs nil SO3_LL_LOW;
  
  XMLclose xmlEditSceneFile;
  set xmlEditSceneFile = newOsSceneFile viewstr;
  
  let V3DgetDefaultViewport viewstr -> viewportstr in
  let XMLgetMarkByValue xmlEditSceneFile "scene" -> scenestr in
  (
    renderingResetScene sessionstr viewportstr;
    SO3ViewportSetMaterialScheme viewportstr.V3D_viewport "";
    
    SO3GroupCreate (V3DgetSession sessionstr) "Scene";
    
    let addGraphItem "Scene" "Scene" iTypeScene nil scenestr nil scenestr sTreeBitmapScene nil 0 0 -> treeroot in
    (
      let XMLaddMark xmlEditSceneFile "cinematics" scenestr nil nil -> cinematicsstr in
        addGraphItem "Cinematics" (strcatn "Scene"::"."::"Cinematics"::nil) iTypeCinematics nil cinematicsstr nil scenestr sTreeBitmapAnim treeroot 1 0;     
      addGraphItem "default_camera" "default_camera" iTypeCamera nil nil nil scenestr sTreeBitmapCamera treeroot 1 0;
    );

    V3DuseDefaultLight sessionstr 1;
    set bLastDefaultLightState = 1;
    V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultLight sessionstr) iTypeLight 1;
    setEdCtrlTreeExpandAll ctrlSceneTree 1;
    
    V3DenableView viewstr 1;
    V3DenableKeyboard viewstr 1;
    V3DenableMouse viewstr 1;
    V3DenableNavigate sessionstr 1;
    
    //V3DsetFont viewstr "Arial" 16 FF_WEIGHT 0x00ffff;
    V3DviewSetFocus viewstr;  
    
    V3DsetCamera (V3DgetDefaultCamera sessionstr) nil 1.0 0.01 10000.0;
    
    V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultCamera sessionstr) iTypeCamera 1;
    
    V3DsetCbAxisClick sessionstr mkfun7 @cbAxisClick viewstr;
    
    let if tLastNavPos == nil then [(SO3ObjectGetPosition sessionstr.V3D_shellNavigate) [0.0 0.0 0.0 1.0] [0.0 0.0 0.0 1.0]] else tLastNavPos -> [spos squat cquat] in
    if !iNavigationMode then nil else
      startAvNavMode viewstr spos squat cquat 0.5 1.60;
      
    set xmlBaseScene = XMLcopy xmlEditSceneFile;
    
    setEdWindowName mainInterf.MINT_winMain strcatn "OpenSpace3D Editor : "::getVersionName::nil;
    
    setViewWireMode viewstr bShowWireMode;
    
    paintEdCtrlModuleEditor mainInterf.MINT_meGroups;
  );
  0;;


/**  cbDlgAddResources [MessageBox u0 [S r1]] I
  *  callback on dlg add resources
  *  
  *  private
  *
  *  return 0
  **/
fun cbDlgAddResources(dlg, p, lp)=
  let p -> [viewstr markstr val item] in
  let sizelist lp -> size in
  let 0 -> i in
  while i < size do
  (
    let _PtoScol (nth_list lp i) -> file in
    if file == nil then nil else
    (
      addResourceFile viewstr markstr file;
      set sLastDirectory = getFileDirectory file;
    );
    
    set i = i + 1;
  );
  0;;


/**  cbDlgAddResourceDir [MessageBox V3Dview S] I
  *  callback on dlg add resources dir
  *  
  *  private
  *
  *  return 0
  **/
fun cbDlgAddResourceDir(dlg, viewstr, path)=
  if (path == nil) || (!strcmp "" (strtrim path)) then nil else
    addOsResourceDir path::nil;
  
  set sLastDirectory = path;
  0;;


/**  cbEnablePlugitLog [EdToolBar CompCheck I I I EdWindow] I
  *  callback on Enable / Disable button
  *  
  *  private
  *
  *  return 0
  **/
fun cbEnablePlugitLog(tbstr, check, btn, mask, state, winstr)=
  set bPlugItLog = !bPlugItLog;
  
  if state then
    set DMSdebug = @cbDmsLogs
  else 
    set DMSdebug = nil;
  0;;
  

/**  cbClearLog [EdToolBar CompRollOver I I EdWindow] I
  *  callback clear logs button
  *  
  *  private
  *
  *  return 0
  **/
fun cbClearLog(tbstr, cbtn, btn, mask, winstr)=
  clearLogsMessages;  
  0;;


/**  cbMinMaxWin [EdToolBar CompCheck I I I EdWindow] I
  *  callback on min / max button
  *  
  *  private
  *
  *  return 0
  **/
fun cbMinMaxWin(tbstr, check, btn, mask, state, winstr)=
  maximizeOrMinimizeEdWindow winstr 0 1;
  
  if state then nil else
  let mainInterf.MINT_winInfos -> [winfostr _] in
  let mainInterf.MINT_winView -> [wviewstr _] in
  let mainInterf.MINT_winPlugins -> [pviewstr _] in
  let mainInterf.MINT_winLogs -> [winlogs _ _] in
  let mainInterf.MINT_winHBorder -> hborder in
  let mainInterf.MINT_winHBorder2 -> h2border in
  let mainInterf.MINT_winVBorder -> vborder in
  let _GETwindowPositionSize mainInterf.MINT_winMain.EDW_win -> [_ _ mw mh] in
  (
    let _GETwindowPositionSize winfostr.EDW_win -> [ix iy iw ih] in
    let _GETwindowPositionSize wviewstr.EDW_win -> [vx vy vw vh] in
    let _GETwindowPositionSize pviewstr.EDW_win -> [px py pw ph] in
    let _GETwindowPositionSize winlogs.EDW_win -> [lx ly lw lh] in
    let _GETwindowPositionSize hborder.EDW_win -> [hx ypos hw hh] in
    let _GETwindowPositionSize vborder.EDW_win -> [xpos wy ww wh] in
    let _GETwindowPositionSize h2border.EDW_win -> [h2x y2pos h2w h2h] in
    let if xpos <= 120 then 120 else if (mw-xpos-ww) <= 350 then mw-350 else xpos -> xpos in
    let if ypos <= (36+28) then (36+28) else if ypos >= (y2pos - hh - 28) then (y2pos - hh - 28) else ypos -> ypos in
    let if y2pos <= (py + 28) then (py + 28) else if y2pos >= (mh - 28 - h2h) then (mh - 28 - h2h) else y2pos -> y2pos in
    (
      setEdWindowPosSize hborder hx ypos hw hh;
      setEdWindowPosSize vborder xpos wy ww ypos-wy;
      setEdWindowPosSize winfostr ix iy ix+xpos ypos-iy;
      setEdWindowPosSize wviewstr xpos+ww vy mw-xpos-ww ypos-vy;
      setEdWindowPosSize pviewstr px ypos+hh pw y2pos-(ypos+hh);
      
      setEdWindowPosSize h2border h2x y2pos h2w h2h;
      setEdWindowPosSize winlogs lx y2pos+h2h lw mh-y2pos-h2h;
    );
  );
  0;;


/**  cbMinMaxWinLogs [EdToolBar CompCheck I I I EdWindow] I
  *  callback on min / max button
  *  
  *  private
  *
  *  return 0
  **/
fun cbMinMaxWinLogs(tbstr, check, btn, mask, state, winstr)=
  maximizeOrMinimizeEdWindow winstr 0 1;
  0;;


/**  cbMinMaxViewWin [EdToolBar CompCheck I I I EdWindow] I
  *  callback on min / max button
  *  
  *  private
  *
  *  return 0
  **/
fun cbMinMaxViewWin(tbstr, check, btn, mask, state, winstr)=
  maximizeOrMinimizeEdWindow winstr 0 1;
  0;;


/**  cbMinMaxWinPlugs [EdToolBar CompCheck I I I EdWindow] I
  *  callback on min / max button
  *  
  *  private
  *
  *  return 0
  **/
fun cbMinMaxWinPlugs(tbstr, check, btn, mask, state, winstr)=
  maximizeOrMinimizeEdWindow winstr 0 1;
  0;;


fun cbNewOnSave(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    initScene viewstr sessionstr;
  0;;


fun cbSaveBeforeNew(dlg, viewstr, state)=
  if (state == 2) then nil else // Cancel
  if (state == 1) then // OK
  (
    saveSceneFile mkfun1 @cbNewOnSave viewstr;
    0;
  )
  else
  (
    let V3DgetDefaultSession viewstr -> sessionstr in
      initScene viewstr sessionstr;
      
    let mainInterf.MINT_tbMain -> [ _ _ _ cmprsave _ cmpsetting cmpexport cmpplayer _ _ ] in
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
    );
    0;
  );
  0;;


/**  cbTbBtnReset [EdToolBar CompRollOver I I V3Dview] I
  *  callback on reset button
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnReset(tbstr, croll, btn, mask, viewstr)=
  if (isSceneModified) then
  (
    _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Do you want to save the current scene before starting a new one ?" 3 @cbSaveBeforeNew viewstr;
    0;
  )
  else
  (
    let V3DgetDefaultSession viewstr -> sessionstr in
      initScene viewstr sessionstr;
    
    let mainInterf.MINT_tbMain -> [ _ _ _ cmprsave _ cmpsetting cmpexport cmpplayer _ _ ] in
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
    );
    0;
  );
  0;;


/**  cbDlgOpenOs3dScene [MessageBox V3Dview P] I
  *  callback on dlg open
  *  
  *  private
  *
  *  return 0
  **/
fun cbDlgOpenOs3dScene(dlg, viewstr, pfile)=
  if pfile == nil then nil else
  let _PtoScol pfile -> file in
  if file == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Your file have to be in a scol partition." 0;
    addLogMessage "File can't be loaded !";
    0;
  )
  else
  let getFileExt file -> ext in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    initScene viewstr sessionstr;
    
    if !strcmpi "scene" ext then nil
      //loadOgreMaxScene viewstr file
    else if !strcmpi "xos" ext then
      loadOs3DScene viewstr file
    else nil;
    
    set sLastDirectory = getFileDirectory file;
    0;
  );
  
  let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
  (
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_ENABLE|OBJ_VISIBLE 1;
    
    if (sCurrentScenePath == nil) then nil else
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_ENABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_ENABLE|OBJ_VISIBLE 1;
    );
  );
  0;;


/* ********************************************************************************************* /
  Import scene
/ ********************************************************************************************* */
fun cbImportEnd(ctrlstr, p)=
  let p -> [[file lresdir lscripts ctrlscenegrp ctrlcurgrp ctrlnewgrp ctrlgrpname] [viewstr destgroupmark val treefather]] in
  let if (getEdCtrlRadioState ctrlscenegrp) then 1 else if (getEdCtrlRadioState ctrlnewgrp) then 0 else 2 -> mode in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let if mode == 1 then nil else SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
  let if (treefather == nil) || (mode == 1) then (getEdCtrlTreeRootItem ctrlSceneTree) else treefather -> treefather in
  let if (destgroupmark == nil) || (mode == 1) then (XMLgetMarkByValue xmlEditSceneFile "scene") else destgroupmark -> destgroupmark in
  let getEdCtrlTextLineValue ctrlgrpname -> groupname in
  (
    dsEdWindow winImportScene;
    set winImportScene = nil;
    importOgreMaxScene viewstr file lresdir lscripts destgroupmark father treefather groupname mode;
    
    resetObjHistory;
  );
  0;;


fun cbCtrlImportNewGroup(ctrlstr, state, ctrlgrpname)=
  setEdCtrlTextLineEnable ctrlgrpname state;
  0;;


fun cbCtrlImportCurGroup(ctrlstr, state, ctrlcurgrp)=
  setEdCtrlTextLineEnable ctrlcurgrp !state;
  0;;


fun cbCtrlImportSceneGroup(ctrlstr, state, ctrlscenegrp)=
  setEdCtrlTextLineEnable ctrlscenegrp !state;
  0;;


fun cbImportStep6(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext file ctrllist lresdir] [viewstr destgroupmark val treefather]] in
  let getEdCtrlListElems ctrllist -> lscripts in
  (
    dsEdWindow stpwinstr;
    dsEdCtrlButton ctrlnext;
    
    let [400 300] -> [iw ih] in
    let getGroupName currentProject destgroupmark -> curgrpname in
    let crEdWindow _channel winImportScene 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
    let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 "Import in scene root, in current group or as a new group" ET_BORDER nil -> labeltype in
    let crEdCtrlRadio stpwinstr 20 80 (iw - 50) 20 "In scene group" EDWIN_RESIZE_MW -> ctrlscenegrp in
    let if (!strcmp curgrpname "Scene") then nil else crEdCtrlRadio stpwinstr 20 105 (iw - 50) 20 strcatn "In current \""::curgrpname::"\" group"::nil EDWIN_RESIZE_MW -> ctrlcurgrp in
    let crEdCtrlRadio stpwinstr 20 (if (!strcmp curgrpname "Scene") then 105 else 130) (iw - 50) 20 "As a new group" EDWIN_RESIZE_MW -> ctrlnewgrp in
    let crEdCtrlLabel stpwinstr 35 (if (!strcmp curgrpname "Scene") then 130 else 155) 80 20 "Group name" nil -> labelgroup in
    let crEdCtrlTextLine stpwinstr 120 (if (!strcmp curgrpname "Scene") then 130 else 155) 120 20 (getFileNameWithoutExt file) ET_BORDER|ET_AVSCROLL|ET_VSCROLL|ET_TABFOCUS EDWIN_RESIZE_MW|EDWIN_RESIZE_LH -> ctrlgrpname in
    let crEdCtrlButton winImportScene (iw - 100) (ih - 30) 90 20 "Import" EDWIN_RESIZE_MW -> ctrlend in
    (
      setEdCtrlRadioCbState ctrlnewgrp mkfun3 @cbCtrlImportNewGroup ctrlgrpname;
      setEdCtrlRadioCbState ctrlcurgrp mkfun3 @cbCtrlImportCurGroup ctrlgrpname;
      setEdCtrlRadioCbState ctrlscenegrp mkfun3 @cbCtrlImportSceneGroup ctrlgrpname;
      
      setEdCtrlTextLineEnable ctrlgrpname 0;
      if (destgroupmark != nil) && (strcmp curgrpname "Scene") then
        setEdCtrlRadioState ctrlcurgrp 1
      else
        setEdCtrlRadioState ctrlscenegrp 1;
        
      setEdCtrlButtonCb ctrlend mkfun2 @cbImportEnd [[file lresdir lscripts ctrlscenegrp ctrlcurgrp ctrlnewgrp ctrlgrpname] [viewstr destgroupmark val treefather]];
    );
  );
  0;;


fun cbImportListKeyDown(ctrlstr, pos, name, lval, type, key, code)=
  0;;


fun cbImportListKeyUp(ctrlstr, pos, name, lval, type, key)=
  if key != 339 then nil else //Suppr
    delEdCtrlList ctrlstr name;
  0;;


fun cbImportRemoveInList(ctrlstr, ctrllist)=
  let getSelectedEdCtrlList ctrllist -> [name lval type] in
    delEdCtrlList ctrllist name;
  0;;


fun cbDlgImportAddScript(dlg, ctrllist, lpfile)=
  if lpfile == nil then nil else
  let 0 -> error in
  (
    let sizelist lpfile -> size in
    let 0 -> i in
    
    while i < size && !error do
    (
      let nth_list lpfile i -> pfile in
      let _PtoScol pfile -> file in
      if file == nil then
      (
        set error = 1;
        0;
      )
      else
      (
        let getEdCtrlListElem ctrllist file -> exist in
        if (exist != nil) then nil else
          addEdCtrlList ctrllist (strlowercase file) nil nil;
        
        set sLastDirectory = getFileDirectory file;
        0;
      );
      
      set i = i + 1;
    );
    if !error then nil else
      _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Your file have to be in a scol partition." 0;
  );
  0;;


fun cbImportAddScript(ctrlstr, ctrllist)=
    _DLGrflopenMulti _DLGOpenFileMulti _channel winImportScene.EDW_win sLastDirectory nil "Ogre scripts\0*.material;*.program\0;*.compositor\0\0" @cbDlgImportAddScript ctrllist;
  0;;


fun cbImportStep5(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext file ctrllist] [viewstr destgroupmark val treefather]] in
  let getEdCtrlListElems ctrllist -> lresdir in
  (
    dsEdWindow stpwinstr;
    let [400 300] -> [iw ih] in
    let crEdWindow _channel winImportScene 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
    let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 strcatn "Select the material and program files for "::file::""::nil ET_BORDER nil -> labeltype in
    let crEdCtrlList stpwinstr 10 80 (iw - 40) 120 nil EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> ctrllist in
    let crEdCtrlButton stpwinstr 20 210 120 20 "Add script" EDWIN_RESIZE_MW -> ctrladd in
    let crEdCtrlButton stpwinstr (iw - 160) 210 120 20 "Remove script" EDWIN_RESIZE_MW -> ctrlremove in
    (
      let sizelist lresdir -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lresdir i -> dir in
        let getFilesFromDir dir "material"::"program"::"compositor"::"particle"::nil -> lfiles in
        let sizelist lfiles -> size2 in
        let 0 -> i2 in
        while i2 < size2 do
        (
          let nth_list lfiles i2 -> script in
          let getEdCtrlListElem ctrllist script -> exist in
          if (exist != nil) then nil else
            addEdCtrlList ctrllist (strlowercase script) nil nil;
          set i2 = i2 + 1;
        );
        set i = i + 1;
      );
      setEdCtrlListCbKeyUp ctrllist @cbImportListKeyUp;
      setEdCtrlListCbKeyDown ctrllist @cbImportListKeyDown;
      setEdCtrlButtonCb ctrladd mkfun2 @cbImportAddScript ctrllist;
      setEdCtrlButtonCb ctrlremove mkfun2 @cbImportRemoveInList ctrllist;
      setEdCtrlButtonCb ctrlnext mkfun2 @cbImportStep6 [[stpwinstr ctrlnext file ctrllist lresdir] [viewstr destgroupmark val treefather]];
    );
  );
  0;;


fun cbDlgImportAddResourceDir(dlg, ctrllist, path)=
  let getEdCtrlListElem ctrllist path -> exist in
  if (path == nil) || (!strcmp "" (strtrim path)) || (exist != nil) then nil else
    addEdCtrlList ctrllist (strlowercase path) nil nil;
  
  set sLastDirectory = path;
  0;;


fun cbImportAddResourceDir(ctrlstr, ctrllist)=
  _DLGrflopenDir (_DLGOpenDir _channel winImportScene.EDW_win nil "Add resource path") @cbDlgImportAddResourceDir ctrllist;
  0;;


fun getImportSceneResourceDir(file, ctrllist)=
  let XMLload file -> xmlscenestr in
  let XMLgetMarkByValue xmlscenestr "scene" -> srcgroupmark in
  let XMLgetMarkByValueFromMarkSons srcgroupmark "resourceLocations" -> resourcesxml in
  let XMLgetMarksByValueFromMarkSons resourcesxml "resourceLocation" -> lresourcexml in
  (
    let getPathFile file "" -> [dir _] in
    (
      addEdCtrlList ctrllist dir nil nil;
      
      let _listofsubdir dir -> lsdir in
      let sizelist lsdir -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lsdir i -> sdir in
        let getEdCtrlListElem ctrllist sdir -> exist in
        if (exist != nil) || ((_listoffiles sdir) == nil) then nil else
          addEdCtrlList ctrllist sdir nil nil;
    
        set i = i + 1;
      );
      
      let sizelist lresourcexml -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lresourcexml i -> resourcexml in
        let XMLgetParam resourcexml "type" -> type in
        let XMLgetParam resourcexml "name" -> path in
        let XMLgetBoolParam resourcexml "recursive" -> recursive in
        if (strcmpi type "FileSystem") || (path == nil) || (!strcmp "" (strtrim path)) || (!strcmp ".." (substr path 0 2)) || ((_listoffiles path) == nil) then nil else
        (
          let if recursive then path::(getDirListFromPath path) else path::nil -> fpath in        
          let sizelist fpath -> size2 in
          let 0 -> i2 in
          while i2 < size2 do
          (
            let nth_list fpath i2 -> elt in
            let getEdCtrlListElem ctrllist elt -> exist in
            if (elt == nil) || (!strcmp "" (strtrim elt)) || (exist != nil) then nil else
              addEdCtrlList ctrllist (strlowercase path) nil nil;
            
            set i2 = i2 + 1;
          );
          
        );
        
        set i = i + 1;
      );
    );
  );
  0;;


fun cbImportStep4(p)=
  let p -> [[ctrlnext file] [viewstr destgroupmark val treefather]] in
  let [400 300] -> [iw ih] in
  let crEdWindow _channel winImportScene 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
  let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 strcatn "Select the resources directories for "::file::" (bitmaps, shaders, program, skeleton ...)"::nil ET_BORDER nil -> labeltype in
  let crEdCtrlList stpwinstr 10 80 (iw - 40) 120 nil EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> ctrllist in
  let crEdCtrlButton stpwinstr 20 210 120 20 "Add directory" EDWIN_RESIZE_MW -> ctrladd in
  let crEdCtrlButton stpwinstr (iw - 160) 210 120 20 "Remove directory" EDWIN_RESIZE_MW -> ctrlremove in
  (
    getImportSceneResourceDir file ctrllist;
    setEdCtrlButtonCb ctrladd mkfun2 @cbImportAddResourceDir ctrllist;
    setEdCtrlButtonCb ctrlremove mkfun2 @cbImportRemoveInList ctrllist;
    setEdCtrlButtonCb ctrlnext mkfun2 @cbImportStep5 [[stpwinstr ctrlnext file ctrllist] [viewstr destgroupmark val treefather]];
    setEdCtrlListCbKeyUp ctrllist @cbImportListKeyUp;
    setEdCtrlListCbKeyDown ctrllist @cbImportListKeyDown;
  );
  0;;


fun cbImportXos(p)=
  let p -> [file [viewstr destgroupmark val treefather]] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
  let if treefather == nil then (getEdCtrlTreeRootItem ctrlSceneTree) else treefather -> treefather in
  let if destgroupmark == nil then (XMLgetMarkByValue xmlEditSceneFile "scene") else destgroupmark -> destgroupmark in
  (
    dsEdWindow winImportScene;
    set winImportScene = nil;
    importOs3DScene viewstr file destgroupmark father treefather;
  );
  0;;


fun cbImportStep3(dlg, p, pfile)=
  let p -> [[stpwinstr ctrlnext ctrlogrescene ctrlos3dscene] [viewstr destgroupmark val treefather]] in
  (
    if pfile == nil then nil else
    let strlowercase (_PtoScol pfile) -> file in
    if file == nil then
    (
      _DLGMessageBox _channel winImportScene.EDW_win "Error" "Your file have to be in a scol partition." 0;
      0;
    )
    else
    let getFileExt file -> ext in
    (
      if !strcmpi "scene" ext then
      (
        dsEdWindow stpwinstr;
        cbImportStep4 [[ctrlnext file] [viewstr destgroupmark val treefather]];
      )
      else if !strcmpi "xos" ext then
      (
        dsEdWindow stpwinstr;
        cbImportXos [file [viewstr destgroupmark val treefather]];
      )
      else
      (
        _DLGMessageBox _channel winImportScene.EDW_win "Error" "Unknow file extension." 0;
        0;
      );
      set sLastDirectory = getFileDirectory file;
      0;
    );
    setEdCtrlButtonEnable ctrlnext 1
  );
  0;;


fun cbImportStep2(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext ctrlogrescene ctrlos3dscene] [viewstr destgroupmark val treefather]] in
  let getEdCtrlRadioState ctrlogrescene -> ogrescene in
  let if ogrescene then "Ogre scene\0*.scene\0\0" else "OpenSpace 3D scene\0*.xos\0\0" -> format in
  (
    setEdCtrlButtonEnable ctrlnext 0;
    _DLGrflopen _DLGOpenFile _channel winImportScene.EDW_win sLastDirectory nil format @cbImportStep3 p;
  );
  0;;


/**  cbDestroyImportWin [EdWindow] I
  *  callback on destroy import window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyImportWin(winstr)=
  set winImportScene = nil;
  0;;


fun importSceneWizard(viewstr, destgroupmark, val, treefather, file)=
  if winImportScene == nil then nil else
  (
    dsEdWindow winImportScene;
    set winImportScene = nil;
  );
  
  let _GETdesktopSize -> [sw sh] in
  let getEdWindowPos mainInterf.MINT_winMain -> [nx ny] in
  let getEdWindowSize mainInterf.MINT_winMain -> [nmw nmh] in  
  let [400 300] -> [iw ih] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain nx + ((nmw / 2) - (iw / 2)) ny + ((nmh / 2) - (ih / 2)) iw ih WN_NOSCOL|WN_MENU nil strcat "Import scene : " val) sWinDlgIcon -> winstr in
  let crEdWindow _channel winstr 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
  let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 "Select the scene file format" ET_BORDER nil -> labeltype in
  let crEdCtrlRadio stpwinstr 20 80 (iw - 50) 20 "Ogre Scene (.scene)" EDWIN_RESIZE_MW -> ctrlogrescene in
  let crEdCtrlRadio stpwinstr 20 105 (iw - 50) 20 "OpenSpace3D Scene (.xos)" EDWIN_RESIZE_MW -> ctrlos3dscene in
  let crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Next" EDWIN_RESIZE_MW -> ctrlnext in
  (
    set winImportScene = winstr;
        
    setEdCtrlRadioState ctrlogrescene 1;
    if file == nil then
    (
      setEdCtrlButtonCb ctrlnext mkfun2 @cbImportStep2 [[stpwinstr ctrlnext ctrlogrescene ctrlos3dscene] [viewstr destgroupmark val treefather]];
      0;
    )
    else
    (
      dsEdWindow stpwinstr;
      cbImportStep4 [[ctrlnext file] [viewstr destgroupmark val treefather]];
      0;
    );
    
    setEdwindowCbDestroy winstr @cbDestroyImportWin;
  );  
  0;;


/* ********************************************************************************************* /
  Import mesh  
/ ********************************************************************************************* */
/**  cbDestroyImportMeshWin [EdWindow] I
  *  callback on destroy import mesh window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyImportMeshWin(winstr)=
  set winImportMesh = nil;
  0;;


fun loadOgreMesh(viewstr, groupstr, meshpath, destmark, father, treefather)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getFileNameWithoutExt meshpath -> meshname in
  let itoa getNewSceneIndex nil -> id in
  let SO3SceneLoadEntity (V3DgetSession sessionstr) groupstr.GRP_sName (strcatn id::"."::meshname::nil) _checkpack meshpath -> mesh in
  (
    if mesh == nil then nil else
    (
      if father == nil then nil else
        SO3ObjectLink mesh father;
      
      SO3ObjectSetPosition mesh [0.0 0.0 0.0];
      SO3ObjectSetOrientation mesh [0.0 0.0 0.0 1.0];
      SO3ObjectSetScale mesh [1.0 1.0 1.0];          
      
      let strlowercase strcat (getFilePathWithoutExt meshpath) ".skeleton" -> sklpath in
      let OGMATfindResourcePath sklpath lResourcesPath -> sklpath in
      let XMLaddMark xmlEditSceneFile "mesh" destmark ["id" id]::["name" meshname]::["path" meshpath]::["castShadows" "true"]::["receiveShadows" "true"]::["renderingDistance" "0"]::["indexMaterials" (XMLgetBoolString 0)]::["visibilityFlags" "0xFFFFFFFF"]::(if sklpath == nil then nil else ["skeletonlink" sklpath])::nil nil -> meshxmlstr in
      let XMLaddMark xmlEditSceneFile "subentities" meshxmlstr nil nil -> meshxmlsubstr in
      let addGraphItem (strcatn meshname::" #"::id::nil) (strcatn id::"."::meshname::nil) iTypeEntity nil meshxmlstr meshpath groupstr.GRP_xmlMark sTreeBitmapEntity treefather 0 0 -> treenode in
      (
        selEdCtrlTreeItem ctrlSceneTree treenode;
        
        if (_checkpack sklpath) == nil then nil else
        (
          V3DaddResource sessionstr sklpath groupstr.GRP_sName SO3_RESOURCE_SKELETON;
          SO3EntityAttachSkeleton mesh _checkpack sklpath;
          addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark sklpath SO3_RESOURCE_SKELETON;
          let SO3GetRootBonesFromMesh mesh -> rootbones in
          let sizelist rootbones -> nbrootbones in
          let 0 -> i in
          while i < nbrootbones do
          (
            loadBonesChilds sessionstr (nth_list rootbones i) meshxmlstr treenode groupstr.GRP_xmlMark;
            set i = i + 1;
          );
        );
        
        let SO3EntityNumOfSubEntities mesh -> nbentities in
        let 0 -> i in
        while i < nbentities do
        (
          let SO3MaterialGetName (SO3EntityGetMaterialByIndex mesh i) -> submatname in
            XMLaddMark xmlEditSceneFile "subentity" meshxmlsubstr ["index" (itoa i)]::["materialName" submatname]::["defaultMaterial" submatname]::nil nil;
  
          set i = i + 1;
        );
        
        // morph anims
        let SO3ObjectGetVertexAnimations mesh -> lmorph in
        if lmorph == nil then nil else
        (
          let sizelist lmorph -> sizemorph in
          let 0 -> imorph in
          while imorph < sizemorph do
          (
            let nth_list lmorph imorph -> anim in
            let if imorph == 0 then 1 else 0 -> defstate in
            let itoa getNewSceneIndex nil -> animid in
            let SO3AnimationGetName anim -> animname in
            let XMLgetMarkByValueFromMarkSons meshxmlstr "animations" -> animsmark in
            let if animsmark != nil then animsmark else XMLaddMark xmlEditSceneFile "animations" meshxmlstr nil nil -> targetanimsmark in          
            let XMLaddMark xmlEditSceneFile "animation" targetanimsmark ["id" animid]::["name" animname]::["type" "morph"]::["enable" (XMLgetBoolString defstate)]::["loop" (XMLgetBoolString 0)]::["speed" (XMLgetShortFloatToString fDefaultAnimationSpeed)]::["weight" (XMLgetShortFloatToString 1.0)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
            let addGraphItem strcatn animname::" #"::animid::nil (strcatn animid::"."::animname::nil) iTypeAnim nil newanimmark nil groupstr.GRP_xmlMark sTreeBitmapAnim treenode defstate 0 -> treenode in
            (
              V3DaddMorphAnimation sessionstr anim mesh (atoi animid) animname (strcatn animid::"."::animname::nil) fDefaultAnimationSpeed 1.0 defstate 0;
            );
            
            set imorph = imorph + 1;
          );
        );
     
        XMLaddMark xmlEditSceneFile "scale" meshxmlstr ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
        XMLaddMark xmlEditSceneFile "position" meshxmlstr ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
        XMLaddMark xmlEditSceneFile "rotation" meshxmlstr ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;          
        
        V3DaddResource sessionstr meshpath groupstr.GRP_sName SO3_RESOURCE_MESH;
        addOsSceneResource xmlEditSceneFile groupstr.GRP_xmlMark meshpath SO3_RESOURCE_MESH;
        
        SO3ObjectSetCastShadows mesh 1;
		SO3EntitySetVisibilityFlags mesh 0xFFFFFFFF;
      );
      mesh;
    );
  );;


fun cbIsOgreMeshReadyToImport(trm, p)=
  let p -> [viewstr groupstr destmark father file treefather] in
  if groupstr.GRP_iWaitForLoad > 0 then nil else
  (
    _deltimer trm;
    
    loadGroupResources groupstr viewstr groupstr.GRP_xmlMark;
    let loadOgreMesh viewstr groupstr file destmark father treefather -> mesh in
    if mesh != nil then addLogMessage "Mesh loaded." else addLogMessage "Error while loading mesh.";
  );
  0;;


fun importOgreMesh(viewstr, file, lresdir, lscripts, destmark, father, treefather)=
  addLogMessage strcatn "Importing Ogre mesh file : "::file::nil;
  
  addOsResourceDir lresdir;
  let getEdCtrlTreeValueByItem ctrlSceneTree treefather -> [fval _] in
  let getGraphByValue fval -> [_ _ _ _ _ groupmark _ _] in
  let switch lGroups groupmark -> groupstr in
  (
    getResourcesScriptFiles groupstr lscripts;
    if groupstr.GRP_iWaitForLoad > 0 then
    (
      _rfltimer _starttimer _channel 1000 @cbIsOgreMeshReadyToImport [viewstr groupstr destmark father file treefather];
      0;
    )
    else
    (
      cbIsOgreMeshReadyToImport nil [viewstr groupstr destmark father file treefather];
      0;
    );
  );
  0;;


fun cbImportMeshEnd(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext file ctrllist lresdir] [viewstr destmark val type treefather]] in
  let getEdCtrlListElems ctrllist -> lscripts in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
  let if (treefather == nil) then (getEdCtrlTreeRootItem ctrlSceneTree) else treefather -> treefather in
  let if destmark != nil then destmark else XMLgetMarkByValue xmlEditSceneFile "scene" -> destmark in
  let if (type == iTypeGroup || type == iTypeScene) then XMLgetMarkByValueFromMarkSons destmark "graph" else destmark -> destmark in
  (
    dsEdWindow winImportMesh;
    set winImportMesh = nil;
    importOgreMesh viewstr file lresdir lscripts destmark father treefather;
    
    resetObjHistory;
  );
  0;;


fun cbImportAddMeshScript(ctrlstr, ctrllist)=
    _DLGrflopenMulti _DLGOpenFileMulti _channel winImportMesh.EDW_win sLastDirectory nil "Ogre scripts\0*.material;*.program\0;*.compositior\0\0" @cbDlgImportAddScript ctrllist;
  0;;


fun cbImportMeshStep5(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext file ctrllist] [viewstr destmark val type treefather]] in
  let getEdCtrlListElems ctrllist -> lresdir in
  (
    dsEdWindow stpwinstr;
    dsEdCtrlButton ctrlnext;
    
    let [400 300] -> [iw ih] in
    let crEdWindow _channel winImportMesh 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
    let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 strcatn "Select the material and program files for "::file::""::nil ET_BORDER nil -> labeltype in
    let crEdCtrlList stpwinstr 10 80 (iw - 40) 120 nil EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> ctrllist in
    let crEdCtrlButton stpwinstr 20 210 120 20 "Add script" EDWIN_RESIZE_MW -> ctrladd in
    let crEdCtrlButton stpwinstr (iw - 160) 210 120 20 "Remove script" EDWIN_RESIZE_MW -> ctrlremove in
    let crEdCtrlButton winImportMesh (iw - 100) (ih - 30) 90 20 "Import" EDWIN_RESIZE_MW -> ctrlend in
    (
      let sizelist lresdir -> size in
      let 0 -> i in
      while i < size do
      (
        let nth_list lresdir i -> dir in
        let getFilesFromDir dir "material"::"program"::"compositor"::"particle"::nil -> lfiles in
        let sizelist lfiles -> size2 in
        let 0 -> i2 in
        while i2 < size2 do
        (
          let nth_list lfiles i2 -> script in
          let getEdCtrlListElem ctrllist script -> exist in
          if (exist != nil) then nil else
            addEdCtrlList ctrllist (strlowercase script) nil nil;
          set i2 = i2 + 1;
        );
        set i = i + 1;
      );
      
      setEdCtrlButtonCb ctrladd mkfun2 @cbImportAddMeshScript ctrllist;
      setEdCtrlButtonCb ctrlremove mkfun2 @cbImportRemoveInList ctrllist;
      setEdCtrlButtonCb ctrlend mkfun2 @cbImportMeshEnd [[stpwinstr ctrlend file ctrllist lresdir] [viewstr destmark val type treefather]];
      setEdCtrlListCbKeyUp ctrllist @cbImportListKeyUp;
      setEdCtrlListCbKeyDown ctrllist @cbImportListKeyDown;
    );
  );
  0;;


fun getImportMeshResourceDir(file, ctrllist)=
  let getPathFile file "" -> [dir _] in
    addEdCtrlList ctrllist dir nil nil;
  0;;


fun cbImportMeshStep4(p)=
  let p -> [[ctrlnext file] [viewstr destmark val type treefather]] in
  let [400 300] -> [iw ih] in
  let crEdWindow _channel winImportMesh 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
  let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 strcatn "Select the resources directories for "::file::" (bitmaps, shaders, program, skeleton ...)"::nil ET_BORDER nil -> labeltype in
  let crEdCtrlList stpwinstr 10 80 (iw - 40) 120 nil EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> ctrllist in
  let crEdCtrlButton stpwinstr 20 210 120 20 "Add directory" EDWIN_RESIZE_MW -> ctrladd in
  let crEdCtrlButton stpwinstr (iw - 160) 210 120 20 "Remove directory" EDWIN_RESIZE_MW -> ctrlremove in
  (
    getImportMeshResourceDir file ctrllist;
    
    setEdCtrlButtonCb ctrladd mkfun2 @cbImportAddResourceDir ctrllist;
    setEdCtrlButtonCb ctrlremove mkfun2 @cbImportRemoveInList ctrllist;
    setEdCtrlButtonCb ctrlnext mkfun2 @cbImportMeshStep5 [[stpwinstr ctrlnext file ctrllist] [viewstr destmark val type treefather]];
    setEdCtrlListCbKeyUp ctrllist @cbImportListKeyUp;
    setEdCtrlListCbKeyDown ctrllist @cbImportListKeyDown;
  );
  0;;


fun cbImportMeshStep3(dlg, p, pfile)=
  let p -> [[stpwinstr ctrlnext] [viewstr destmark val type treefather]] in
  (
    if pfile == nil then nil else
    let strlowercase (_PtoScol pfile) -> file in
    if file == nil then
    (
      _DLGMessageBox _channel winImportMesh.EDW_win "Error" "Your file have to be in a scol partition." 0;
      0;
    )
    else
    let getFileExt file -> ext in
    (
      if (!strcmpi "mesh" ext) || (!strcmpi "xml" ext) then
      (
        dsEdWindow stpwinstr;
        cbImportMeshStep4 [[ctrlnext file] [viewstr destmark val type treefather]];
      )
      else
      (
        _DLGMessageBox _channel winImportMesh.EDW_win "Error" "Unknow file extension." 0;
        0;
      );
      
      set sLastDirectory = getFileDirectory file;
      0;
    );
    setEdCtrlButtonEnable ctrlnext 1
  );
  0;;


fun cbImportMeshStep2(ctrlstr, p)=
  let p -> [[stpwinstr ctrlnext] [viewstr destmark val type treefather]] in
  let "Ogre mesh\0*.mesh\0\0" -> format in
  (
    setEdCtrlButtonEnable ctrlnext 0;
    _DLGrflopen _DLGOpenFile _channel winImportMesh.EDW_win sLastDirectory nil format @cbImportMeshStep3 p;
  );
  0;;
  

fun importMeshWizard(viewstr, destmark, val, type, treefather, file)=
  if winImportMesh == nil then nil else
  (
    dsEdWindow winImportMesh;
    set winImportMesh = nil;
  );
  
  let [400 300] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Import mesh : " val) sWinDlgIcon -> winstr in
  let crEdWindow _channel winstr 10 10 (iw - 20) (ih - 45) WN_CHILDINSIDE nil nil "" -> stpwinstr in
  let crEdCtrlText stpwinstr 10 12 (iw - 40) 60 "Mesh import wizard, press next to select the file" ET_BORDER nil -> labeltype in
  let crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Next" EDWIN_RESIZE_MW -> ctrlnext in
  (
    set winImportMesh = winstr;
    if file == nil then
    (
      setEdCtrlButtonCb ctrlnext mkfun2 @cbImportMeshStep2 [[stpwinstr ctrlnext] [viewstr destmark val type treefather]];
      0;
    )
    else
    (
      dsEdWindow stpwinstr;
      cbImportMeshStep4 [[ctrlnext file] [viewstr destmark val type treefather]];
      0;
    );
    
    setEdwindowCbDestroy winstr @cbDestroyImportMeshWin;
  );
  0;;


/**  cbDestroyMaterialsSetupWin [EdWindow] I
  *  callback on destroy materials window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyMeshMaterialWin(winstr)=
  set winMeshMaterialSetup = nil;
  0;;


fun cbSubEntitySetup(ctrl, pos, elem, param)=
  let param -> [lentitystr ctrlmatname] in
  let nth_list lentitystr pos -> subentitystr in
  let XMLgetParam subentitystr "materialName" -> submatname in
    selectEdCtrlSelect ctrlmatname submatname;
  0;;


fun cbSubEntityMaterialSetup(ctrl, pos, elem, param)=
  let param -> [groupstr sessionstr mesh lentitystr ctrlid] in
  let getSelectedEdCtrlSelectPos ctrlid -> subidx in
  let nth_list lentitystr subidx -> subentitystr in
  let SO3SceneGetMaterial (V3DgetSession sessionstr) groupstr.GRP_sName elem -> submat in
  (
    XMLsetParam subentitystr "materialName" elem;
    
    SO3EntitySetMaterial mesh submat subidx;
  );
  0;;


fun cbBtnResetSubEntityMaterial(ctrl, param)=
  let param -> [groupstr sessionstr mesh lentitystr ctrlid ctrlmatname] in
  let getSelectedEdCtrlSelectPos ctrlid -> subidx in
  let nth_list lentitystr subidx -> subentitystr in
  let XMLgetParam subentitystr "defaultMaterial" -> defmatname in
  let SO3SceneGetMaterial (V3DgetSession sessionstr) groupstr.GRP_sName defmatname -> submat in
  (
    XMLsetParam subentitystr "materialName" defmatname;
    selectEdCtrlSelect ctrlmatname defmatname;
    SO3EntitySetMaterial mesh submat subidx;
  );
  0;;


fun cbTreeMenuMeshMaterialSetup(mnuitem, p)=
  if winMeshMaterialSetup == nil then nil else
  (
    let winMeshMaterialSetup -> [_ winstr] in
      dsEdWindow winstr;
    set winMeshMaterialSetup = nil;
  );
  
  let p -> [viewstr val type markstr groupmark] in
  let [450 75] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> mesh in  
  let XMLgetMarkByValueFromMarkSons markstr "subentities" -> subentitiesstr in
  let XMLgetMarksByValueFromMarkSons subentitiesstr "subentity" -> lentitystr in
  let switch lGroups groupmark -> groupstr in
  
  let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Materials setting : " val) sWinDlgIcon -> winstr in
  
  let crEdCtrlLabel winstr 10 12 130 20 "Material Id" nil -> labelid in
  let crEdCtrlSelect winstr 150 10 (iw - 210) 120 EDWIN_RESIZE_MW -> ctrlid in
  let crEdCtrlButton winstr (iw - 50) 10 40 20 "reset" EDWIN_RESIZE_MW -> ctrlreset in
  
  let crEdCtrlLabel winstr 10 42 130 20 "material name" nil -> labelmat in
  let crEdCtrlSelect winstr 150 40 (iw - 160) 120 EDWIN_RESIZE_MW -> ctrlmatname in
  (
    set winMeshMaterialSetup = [mesh winstr];
    
    let nil -> lid in
    (
      let (sizelist lentitystr) - 1-> i in
      while i >= 0 do
      (
        set lid = (itoa i)::lid;
        set i = i - 1;
      );
      
      fillEdCtrlSelect ctrlid lid;
    );
    selectEdCtrlSelectByPos ctrlid 0;
    
    let SO3SceneParseMaterialsFromGroup (V3DgetSession sessionstr) groupstr.GRP_sName -> l in
    let sizelist l -> size in
    let nil -> lmats in
    let 0 -> i in
    (
      while i < size do
      (
        let nth_list l i -> mat in
        let SO3MaterialGetName mat -> name in
          set lmats = name::lmats;
        
        set i = i + 1;
      );
      fillEdCtrlSelect ctrlmatname quicksort lmats @suppDoublon;
      let XMLgetParam hd lentitystr "materialName" -> submatname in
        selectEdCtrlSelect ctrlmatname submatname;
    );
  
    setEdCtrlSelectCb ctrlid mkfun4 @cbSubEntitySetup [lentitystr ctrlmatname];
    setEdCtrlSelectCb ctrlmatname mkfun4 @cbSubEntityMaterialSetup [groupstr sessionstr mesh lentitystr ctrlid];
    setEdCtrlButtonCb ctrlreset mkfun2 @cbBtnResetSubEntityMaterial [groupstr sessionstr mesh lentitystr ctrlid ctrlmatname];
    setEdwindowCbDestroy winstr @cbDestroyMeshMaterialWin;
    0;
  );
  0;;


fun launchPlayer()=
  if (sCurrentScenePath == nil) then nil else
  let getProjectName -> projname in
  (
    saveSceneFile nil;
    let strcatn "_load \"dms/3d/os3d/os3dload.pkg\"\nmain \""::sCurrentScenePath::"\" \""::projname::"\" \""::(itoa 800)::"\" \""::(itoa 600)::"\" "::(itoa 0)::nil -> script in
    _newmachine (strreplace (strcat projname " Player") " " "_") script nil nil;
  );
  0;;


fun cbSceneFileSaved()=
  setEdWindowName mainInterf.MINT_winMain strcatn "OpenSpace3D Editor : "::getVersionName::" > "::sCurrentScenePath::nil;
  _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Info" strcatn "The scene has been successfully saved to "::sCurrentScenePath::nil 0;
  0;;


fun cbDlgSaveOsScene(dlg, cbfun, wfile)=
  let _PtoScol (_WtoP wfile) -> file in
  if wfile == nil then nil
  else if file == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Your file have to be in a scol partition." 0;
    0;
  )
  else
  let getFileExt file -> ext in
  let if !strcmpi "xos" ext then file else strcat file ".xos" -> file in
  (
    set sCurrentScenePath = file;
    saveSceneFile @cbSceneFileSaved;
    set sLastDirectory = getFileDirectory file;
    exec cbfun with [];
    0;
  );

  let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
  (
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_ENABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_ENABLE|OBJ_VISIBLE 1;
    
    if (sCurrentScenePath == nil) then nil else
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_ENABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_ENABLE|OBJ_VISIBLE 1;
    );
  );
  0;;


fun saveSceneFile(cbfun)=
  if sCurrentScenePath == nil then
  (
    let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
    );
    
    _DLGrflsave _DLGSaveFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory getProjectName "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgSaveOsScene cbfun;
    0;
  )
  else
  let V3DgetDefaultSession v3dMain -> sessionstr in
  let hd sessionstr.V3D_lCamera -> [_ camera] in
  (
    setProjectSetting "projectName" getProjectName;
    
    //default camera
    let XMLgetMarkByValue xmlEditSceneFile "scene" -> scenemark in
    let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in
    let XMLgetMarkByValueFromMarkSons envmark "defaultCamera" -> defcamerastr in
    
    let tCameraPosition -> [vpos vang dist] in
    let if bAppPlay then dist else let SO3ObjectGetPosition (V3DgetDefaultCamera sessionstr) -> [_ _ d] in d -> dist in
    let if bAppPlay then vpos else V3DgetShellNavPos sessionstr -> [xpos ypos zpos] in
    let if bAppPlay then vang else V3DgetShellNavAng sessionstr -> [xang yang zang wang] in
    (
      XMLsetParam defcamerastr "orthographic" XMLgetBoolString (V3DgetOrthographicMode camera);
      XMLsetParam defcamerastr "windowScale" XMLgetShortFloatToString (V3DgetOrthographicScale camera);
      XMLsetParam defcamerastr "fov" XMLgetShortFloatToString (SO3MathsRadianToDegree (SO3CameraGetFOVy camera));
      XMLsetParam defcamerastr "focalLenght" XMLgetShortFloatToString (SO3CameraGetFocalLenght camera);
      XMLsetParam defcamerastr "dist" XMLgetShortFloatToString dist;
      
      let XMLgetMarkByValueFromMarkSons defcamerastr "clipping" -> clippingmark in
      (
        XMLsetParam clippingmark "near" XMLgetShortFloatToString (SO3CameraGetNearClipDistance camera);
        XMLsetParam clippingmark "far" XMLgetShortFloatToString (SO3CameraGetFarClipDistance camera);
      );

      let XMLgetMarkByValueFromMarkSons defcamerastr "position" -> posmark in
      (
        XMLsetParam posmark "x" XMLgetShortFloatToString xpos;
        XMLsetParam posmark "y" XMLgetShortFloatToString ypos;
        XMLsetParam posmark "z" XMLgetShortFloatToString zpos;
      );

      let XMLgetMarkByValueFromMarkSons defcamerastr "rotation" -> angmark in
      let SO3MathsQuatToEulerXYZ [xang yang zang wang] -> [xang yang zang] in
      let [(SO3MathsRadianToDegree xang) (SO3MathsRadianToDegree yang) (SO3MathsRadianToDegree zang)] -> [xang yang zang] in
      (
        XMLsetParam angmark "x" XMLgetShortFloatToString xang;
        XMLsetParam angmark "y" XMLgetShortFloatToString yang;
        XMLsetParam angmark "z" XMLgetShortFloatToString zang;
      );
    );
    
    XMLwrite xmlEditSceneFile sCurrentScenePath;
  
    if cbfun == nil then nil else
      exec cbfun with [];
      
    addLogMessage strcatn "The scene has been successfully saved to "::sCurrentScenePath::"."::nil;
    0;
  );
  0;;


fun cbDlgExportToPlayer(dlg, p, wfile)=
  if wfile == nil then nil else
  let _GetFileNameFromW wfile -> fname in
  let p -> [winstr script] in
  (
    dsEdWindow winstr;
    set winExportSetup = nil;
    
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Info" strcatn "The scol application executable has been successfully saved to "::fname::nil 0;
    addLogMessage strcatn "The project scol executable has been successfully saved to "::fname::nil;
    _createpack script wfile;
  );
  0;;


fun cbSaveOnOpen(viewstr)=
  let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
  (
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
  );
  
  _DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgOpenOs3dScene viewstr;
  0;;


fun cbSaveBeforeOpen(dlg, viewstr, state)=
  if (state == 2) then nil else // Cancel
  if (state == 1) then // OK
  (
    saveSceneFile mkfun1 @cbSaveOnOpen viewstr;
    0;
  )
  else // No
  (
    let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
    );
    
    _DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgOpenOs3dScene viewstr;
    0;
  );
  0;;


/**  cbTbBtnOpenScene [EdToolBar CompRollOver I I V3Dview] I
  *  callback on open os3d scene button
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnOpenScene(tbstr, croll, btn, mask, viewstr)=  
  if (!bAppPlay) then nil else
    playEditor viewstr 0;
  
  if (isSceneModified) then
  (
    _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Do you want to save the current scene before loading a new one ?" 3 @cbSaveBeforeOpen viewstr;
    0;
  )
  else
  (
    let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
    (
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
      _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
    );
    
    _DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgOpenOs3dScene viewstr;
    0;
  );
  0;;


/**  cbTbBtnImportScene [EdToolBar CompRollOver I I V3Dview] I
  *  callback on import ogre scene button
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnImportScene(tbstr, croll, btn, mask, viewstr)=
  //_DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "Scene format\0*.scene;*.xos\0Ogre scene\0*.scene\0OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgImportScene [viewstr nil nil nil];
  importSceneWizard viewstr nil nil nil nil;
  0;;


/**  cbTbBtnSaveAsOsScene [EdToolBar CompRollOver I I V3Dview] I
  *  callback on save as scene button
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnSaveAsOsScene(tbstr, croll, btn, mask, viewstr)=
  let mainInterf.MINT_tbMain -> [cmpnew cmpopen cmpimport cmprsave cmprsaveas cmpsetting cmpexport cmpplayer _ _ ] in
  (
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpnew OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpopen OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpimport OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsave OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmprsaveas OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpplayer OBJ_DISABLE|OBJ_VISIBLE 1;
    _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode cmpexport OBJ_DISABLE|OBJ_VISIBLE 1;
  );
  
  let getPathFile sCurrentScenePath "" -> [fpath fname] in
    _DLGrflsave _DLGSaveFile _channel mainInterf.MINT_winMain.EDW_win fpath fname "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgSaveOsScene nil;
  0;;


/**  cbTbBtnSaveOsScene [EdToolBar CompRollOver I I V3Dview] I
  *  callback on save scene button
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnSaveOsScene(tbstr, croll, btn, mask, viewstr)=
  saveSceneFile nil;
  0;;


/**  cbDestroyExportWin [EdWindow] I
  *  callback on destroy export setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyExportWin(winstr)=
  set winExportSetup = nil;
  0;;


fun cbBtnCancelExportToPlayer(ctrlbtn, winstr)=
  dsEdWindow winstr;
  set winExportSetup = nil;
  0;;


fun cbExportToPlayerOk(btnstr, p)=
  let p -> [winstr ctrllocal ctrlstdalone ctrlapplet ctrlname ctrlw ctrlh] in
  let getEdCtrlTextLineValue ctrlname -> projname in
  let ftoi getEdCtrlFloatValue ctrlw -> w in
  let ftoi getEdCtrlFloatValue ctrlh -> h in
  let strcatn "_load \"dms/3d/os3d/os3dload.pkg\"\nmain \""::
  sCurrentScenePath::"\" \""::projname::"\" \""::(itoa w)::"\" \""::(itoa h)::"\" "::(itoa 0)::nil -> script in
  if sCurrentScenePath == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Save your current scene before." 0;
    0;
  )
  else if (!strcmp (strtrim projname) "") || (projname == nil) then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Set an application name." 0;
    0;
  )
  else if (getEdCtrlRadioState ctrllocal) then
  (
    saveSceneFile nil;
    let getFileNameWithoutExt sCurrentScenePath -> fname in
      _DLGrflsave _DLGSaveFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory (strcat fname ".scol") "Scol executable\0*.scol\0All\0*.*\0\0" @cbDlgExportToPlayer [winstr script];
    0;
  )
  else if (getEdCtrlRadioState ctrlstdalone) then
  (
    dsEdWindow winstr;
    saveSceneFile nil;
    mkStandAlone mainInterf.MINT_winMain projname sCurrentScenePath script w h;
    0;
  )
  else if (getEdCtrlRadioState ctrlapplet) then
  (
    dsEdWindow winstr;
    set winExportSetup = nil;
    saveSceneFile nil;
    mkApplet mainInterf.MINT_winMain projname sCurrentScenePath script w h;
    0;
  )
  else nil;
  0;;


/**  cbTbBtnExportToPlayer [EdToolBar CompRollOver I I V3Dview] I
  *  callback on export to player
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnExportToPlayer(tbstr, croll, btn, mask, viewstr)=
  if sCurrentScenePath == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Save your current scene before." 0;
    0;
  )
  else if winExportSetup != nil then nil else
  (
    let [300 195] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Export to Player setting") sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 120 20 "Application name" nil -> labelproj in
    let crEdCtrlTextLine winstr 130 10 (iw - 140) 20 getProjectName nil EDWIN_RESIZE_MW -> ctrlname in
    let crEdCtrlLabel winstr 10 37 120 20 "Window width" nil -> labelw in
    let crEdCtrlFloat winstr 130 35 (iw - 140) 20 itof iWinW 1.0 1920.0 1.0 0 nil EDWIN_RESIZE_MW -> ctrlw in
    let crEdCtrlLabel winstr 10 62 120 20 "Window height" nil -> labelh in
    let crEdCtrlFloat winstr 130 60 (iw - 140) 20 itof iWinH 1.0 1200.0 1.0 0 nil EDWIN_RESIZE_MW -> ctrlh in

    let crEdCtrlRadio winstr 10 85 (iw - 50) 20 "As a Scol file (for local only)" EDWIN_RESIZE_MW -> ctrllocal in
    let crEdCtrlRadio winstr 10 110 (iw - 50) 20 "As a Stand alone application" EDWIN_RESIZE_MW -> ctrlstdalone in
    let crEdCtrlRadio winstr 10 135 (iw - 50) 20 "As a web page (to FTP)" EDWIN_RESIZE_MW -> ctrlapplet in
    (
      setEdCtrlRadioState ctrllocal 1;
      set winExportSetup = winstr;
      setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 @cbExportToPlayerOk [winstr ctrllocal ctrlstdalone ctrlapplet ctrlname ctrlw ctrlh];
      setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancelExportToPlayer winstr;
      
      setEdwindowCbDestroy winstr @cbDestroyExportWin;
      0;
    );
  );
  0;;


/**  cbTbBtnLaunchPlayer [EdToolBar CompRollOver I I V3Dview] I
  *  launch in player
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnLaunchPlayer(tbstr, croll, btn, mask, viewstr)=
  launchPlayer;
  0;;


fun cbBtnCancel(ctrlbtn, winstr)=
  dsEdWindow winstr;
  0;;


fun cbDestroyProjectSettingWin(winstr)=
  set settingWindow = nil;
  0;;


fun cbBtnProjectSettingOk(btnstr, p)=
  let p -> [winstr ctrlname ctrlversion ctrlwebsite ctrldesc ctrllicense ctrlaname ctrlcompany ctrlemail] in
  let getEdCtrlTextLineValue ctrlname -> projname in
  let XMLgetShortFloatToString (getEdCtrlFloatValue ctrlversion) -> projver in
  let getEdCtrlTextLineValue ctrlwebsite -> projwebsite in
  let getEdCtrlEditTextValue ctrldesc -> projdesc in
  let getEdCtrlEditTextValue ctrllicense -> projlicense in
  
  let getEdCtrlTextLineValue ctrlaname -> authorname in
  let getEdCtrlTextLineValue ctrlcompany -> authorcompany in
  let getEdCtrlTextLineValue ctrlemail -> authorEmail in
  (
    setProjectSetting "projectName" projname;
    setProjectSetting "projectVersion" projver;
    setProjectSetting "projectWebsite" projwebsite;
    setProjectSetting "projectDescription" projdesc;
    setProjectSetting "projectLicense" projlicense;
    
    setProjectSetting "authorName" authorname;
    setProjectSetting "authorCompany" authorcompany;
    setProjectSetting "authorEmail" authorEmail;
  
    dsEdWindow winstr;  
  );
  0;;


/**  cbTbBtnProjectSetting [EdToolBar CompRollOver I I V3Dview] I
  *  show the project setting interface
  *  
  *  private
  *
  *  return 0
  **/
fun cbTbBtnProjectSetting(tbstr, croll, btn, mask, viewstr)=
  if (settingWindow != nil) then nil else
  let [300 470] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let 10 -> ypos in
  let setEdWindowIcon (crEdWindow _channel mainInterf.MINT_winMain x y iw ih nil nil EDWIN_DIALOG "Project setting") sWinDlgIcon -> projwinstr in
  
  let atof (getProjectSetting "projectVersion") -> projversion in
  let if projversion == nil then 1.0 else projversion -> projversion in
  
  let crEdFrameWindow _channel projwinstr 0 0 iw 335 EDWIN_RESIZE_MW nil "Project" nil -> winfrm in
  let crEdWindow _channel winfrm 0 18 iw 320 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW nil nil -> winstr in
  let crEdCtrlLabel winstr 10 ((set ypos = 10) + 2) 120 20 "Name" nil -> labelname in
  let crEdCtrlTextLine winstr 130 ypos (iw - 140) 20 getProjectName nil EDWIN_RESIZE_MW -> ctrlname in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 120 20 "Version" nil -> labelversion in
  let crEdCtrlFloat winstr 130 ypos (iw - 140) 20 projversion 0.0 100000.0 0.1 3 nil EDWIN_RESIZE_MW -> ctrlversion in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 120 20 "Website" nil -> labelwebsite in
  let crEdCtrlTextLine winstr 130 ypos (iw - 140) 20 (getProjectSetting "projectWebsite") nil EDWIN_RESIZE_MW -> ctrlwebsite in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) (iw - 20) 20 "Project description" nil -> labeldesc in
  let crEdCtrlEditText winstr 10 ((set ypos = ypos + 20) + 2) (iw - 20) 90 (getProjectSetting "projectDescription" ) nil EDWIN_RESIZE_MW -> ctrldesc in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 95) + 2) (iw - 20) 20 "Project license" nil -> labellicense in
  let crEdCtrlEditText winstr 10 ((set ypos = ypos + 20) + 2) (iw - 20) 90 (getProjectSetting "projectLicense" ) nil EDWIN_RESIZE_MW -> ctrllicense in
  
  let crEdFrameWindow _channel projwinstr 0 335 iw 110 EDWIN_RESIZE_MW nil "Author" nil -> winfrm in
  let crEdWindow _channel winfrm 0 18 iw 85 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW nil nil -> winstr in
  let crEdCtrlLabel winstr 10 ((set ypos = 10) + 2) 120 20 "Author" nil -> labelaname in
  let crEdCtrlTextLine winstr 130 ypos (iw - 140) 20 (getProjectSetting "authorName") nil EDWIN_RESIZE_MW -> ctrlaname in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 120 20 "Company" nil -> labelcompany in
  let crEdCtrlTextLine winstr 130 ypos (iw - 140) 20 (getProjectSetting "authorCompany") nil EDWIN_RESIZE_MW -> ctrlcompany in
  let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 120 20 "Email" nil -> labelemail in
  let crEdCtrlTextLine winstr 130 ypos (iw - 140) 20 (getProjectSetting "authorEmail") nil EDWIN_RESIZE_MW -> ctrlemail in
  (
    set settingWindow = projwinstr;

    setEdCtrlButtonCb (crEdCtrlButton projwinstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 @cbBtnProjectSettingOk [projwinstr ctrlname ctrlversion ctrlwebsite ctrldesc ctrllicense ctrlaname ctrlcompany ctrlemail];
    setEdCtrlButtonCb (crEdCtrlButton projwinstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel projwinstr;

    setEdwindowCbDestroy projwinstr @cbDestroyProjectSettingWin;
  );
  0;;


/**  cbTbBtnHelp [EdToolBar CompRollOver I I V3Dview] I
  *  callback on help button
  *  Open the online help  
  *
  *  private
  *
  *  return 0
  **/
fun cbTbBtnHelp(tbstr, croll, btn, mask, viewstr)=
  _openbrowserhttp sHelpUrl;
  0;;


/**  cbDestroyAboutWin [EdWindow ObjWebNavigator] I
  *  callback on destroy about window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyAboutWin(winstr, navigator)=
  SO3WebNavigatorDestroy navigator;
  set winAbout = nil;
  0;;


fun cbAboutBtnWww(ctrlbtn)=
  _openbrowserhttp sOSD3Url;
  0;;


fun cbAboutNavigatorPopup(navigator, p, x, y, w, h, url)=
  _openbrowserhttp url;
  0;;


/**  cbTbBtnAbout [EdToolBar CompRollOver I I V3Dview] I
  *  callback on about button
  *  Show the about dialog
  *
  *  private
  *
  *  return 0
  **/
fun cbTbBtnAbout(tbstr, croll, btn, mask, viewstr)=
  if winAbout != nil then nil else
  let [450 500] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  let setEdWindowIcon (crEdWindow _channel mainInterf.MINT_winMain x y iw ih nil nil EDWIN_DIALOG "About OpenSpace3D Editor") sWinDlgIcon -> aboutwinstr in
  let SO3WebNavigatorCreate _channel aboutwinstr.EDW_win 10 130 (iw - 20) 300 "google.com" -> navigator in
  (
    crEdCtrlBitmap aboutwinstr 5 5 150 120 "dms/3d/os3dedit/res/logo.jpg" 0xf0f0f0 nil;
    crEdCtrlLabel aboutwinstr 160 10 (iw - 170) 20 "OpenSpace3D Editor" nil;
    crEdCtrlLabel aboutwinstr 160 40 (iw - 170) 20 strcat "Current version : " getVersionName nil;
    crEdCtrlLabel aboutwinstr 160 65 (iw - 170) 20 strcat "Released on : " getVersionDate nil;
    crEdCtrlLabel aboutwinstr 160 90 (iw - 170) 20 "License : GNU Lesser General Public License" nil;
    crEdCtrlLabel aboutwinstr 10 (ih - 28) (iw - 105) 20 "Copyright I-Maginer 2012" nil;
    
    setEdCtrlButtonCb (crEdCtrlButton aboutwinstr 10 170 (iw-20) 40 "www.openspace3d.com" EDWIN_RESIZE_MW) @cbAboutBtnWww;
    setEdCtrlButtonCb (crEdCtrlButton aboutwinstr (iw - 100) (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel aboutwinstr;
    
    SO3WebNavigatorLoadFile navigator _checkpack "dms/3d/os3dedit/res/about/about.html" nil;
    SO3WebNavigatorCbOnPopup navigator @cbAboutNavigatorPopup nil;
    set winAbout = aboutwinstr;
    setEdwindowCbDestroy winAbout mkfun2 @cbDestroyAboutWin navigator;
  );
  0;;
  

fun cbObjectSetupRenderVisibility(ctrlstr, value, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    SO3ObjectSetRenderingDistance obj value;
    XMLsetParam markstr "renderingDistance" (XMLgetShortFloatToString value);
  );
  0;;


fun cbTreeMenuSetActiveCamera(mnuitem, p)=
  let p -> [viewstr val type markstr camstate] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> cam in
  let !strcmp "default_camera" val -> isdefaultcam in
  let V3DgetObjectByName sessionstr "default_camera" -> defaultcam in
  (
    if(camstate && !isdefaultcam) then
    (
      V3DsetDefaultCamera sessionstr defaultcam;
      V3DenableNavigate sessionstr 1;
      V3DchangeCameraViewport sessionstr (V3DgetDefaultViewport viewstr) defaultcam;
    )
    else
    (
      if (!isdefaultcam) then
      (
        V3DenableNavigate sessionstr 0;
      )
      else
      (
        V3DsetDefaultCamera sessionstr cam;
        V3DenableNavigate sessionstr 1;
      );
      V3DchangeCameraViewport sessionstr (V3DgetDefaultViewport viewstr) cam;
    );
  );
  0;;


/*
// TODO replace by a subentity material management
fun cbTreeMenuObjectIndexMaterials(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetParent obj -> father in
  let SO3ObjectGetName father -> fathername in
  let XMLgetBoolParam markstr "indexMaterials" -> indexmat in
  let getGraphByValue val -> tgraph in
  let tgraph -> [treeitem [_ path groupmark]] in
  let getGroupName groupmark -> resgroup in
  let getGraphByValue fathername -> tgraphfather in
  let tgraphfather -> [treefather _] in
  (
    XMLsetParam markstr "indexMaterials" (XMLgetBoolString !indexmat);
    
    //del object hierarchy and reload
    
    // apply on all sons
    removeObjectSons viewstr treeitem 0;
    
    set lSceneGraph = G2DremoveFromList lSceneGraph tgraph;
    delEdCtrlTreeItem ctrlSceneTree treeitem;
    
    V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 0;
    V3DshowObjectHelper viewstr sessionstr obj nil 0;
    SO3ObjectDestroy obj;
    
    //reload mark
    let XMLgetParam markstr "id" -> id in
    let XMLgetParam markstr "name" -> meshname in
    let XMLgetParam markstr "path" -> meshres in
    let XMLgetBoolParam markstr "indexMaterials" -> indexmat in
    let XMLgetBoolParam markstr "castShadows" -> meshcastshadow in
    let XMLgetBoolParam markstr "receiveShadows" -> meshreceiveshadow in  
    
    let XMLgetMarkByValueFromMarkSons markstr "position" -> nodeposstr in
    let atof XMLgetParam nodeposstr "x" -> xpos in
    let atof XMLgetParam nodeposstr "y" -> ypos in
    let atof XMLgetParam nodeposstr "z" -> zpos in
    let XMLgetMarkByValueFromMarkSons markstr "rotation" -> noderotstr in
    let atof XMLgetParam noderotstr "qx" -> xang in
    let atof XMLgetParam noderotstr "qy" -> yang in
    let atof XMLgetParam noderotstr "qz" -> zang in
    let atof XMLgetParam noderotstr "qw" -> wang in
    let XMLgetMarkByValueFromMarkSons markstr "scale" -> nodescalestr in
    let atof XMLgetParam nodescalestr "x" -> xscale in
    let atof XMLgetParam nodescalestr "y" -> yscale in
    let atof XMLgetParam nodescalestr "z" -> zscale in
    
    let OGMATfindResourcePath meshres lResourcesPath -> meshpath in
    let if meshpath != nil then
          if indexmat then
            SO3SceneLoadEntityWithIndex (V3DgetSession sessionstr) meshpath meshname id resgroup
          else
            SO3SceneLoadEntity (V3DgetSession sessionstr) meshpath (strcatn id::"."::meshname::nil)
        else nil
    -> mesh in
    (
      let addEdCtrlTreeItem ctrlSceneTree treefather (strcatn id::"."::meshname::nil) (strcatn id::"."::meshname::nil) iTypeEntity sTreeBitmapEntity -> treenode in
      (
        if father == nil then nil else
          SO3ObjectLink mesh father;
        
        SO3ObjectSetPosition mesh [xpos ypos zpos];
        SO3ObjectSetOrientation mesh [xang yang zang wang];
        SO3ObjectSetScale mesh [xscale yscale zscale];
        
        set lSceneGraph = [treenode [markstr meshpath groupmark]]::lSceneGraph;
        
        V3DaddResource sessionstr meshpath resgroup SO3_RESOURCE_MESH;
        addOsSceneResource xmlEditSceneFile groupmark meshpath SO3_RESOURCE_MESH;
        
        SO3ObjectSetCastShadows mesh meshcastshadow;
        loadOsGraph viewstr markstr nil groupmark mesh treenode 0;
        
        selEdCtrlTreeItem ctrlSceneTree treenode;
      );
    );
  );
  0;;
*/


/* ********************************************************************************************* /
  Light
/ ********************************************************************************************* */
fun cbTreeMenuLightCastShadow(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetCastShadows obj -> lightcastshadow in
  (
    SO3ObjectSetCastShadows obj !lightcastshadow;
    XMLsetParam markstr "castShadows" (XMLgetBoolString !lightcastshadow);
  );
  0;;


fun cbTreeMenuLightEnable(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in
  let SO3LightGetVisible light -> lightstate in
  (
    SO3LightSetVisible light !lightstate;
    setGraphItemInitState val !lightstate;
    XMLsetParam markstr "enable" (XMLgetBoolString !lightstate);
  );
  0;;


/**  cbDestroySetupWin [EdWindow] I
  *  callback on destroy light setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyLightSetupWin(winstr)=
  set winLightSetup = nil;
  0;;


fun cbLightSetupType(ctrl, pos, elem, param)=
  let param -> [p ctrlrange ctrlinner ctrlouter] in
  let p -> [viewstr val type lightstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in  
  let (getOgreMaxLightType elem) -> lighttype in
  (
    if lighttype == SO3_DIRECTIONAL_LIGHT then
    (
      setEdCtrlFloatEnable ctrlrange 0;
      setEdCtrlFloatEnable ctrlinner 0;
      setEdCtrlFloatEnable ctrlouter 0;
      
    )
    else if lighttype == SO3_POINT_LIGHT then
    (
      setEdCtrlFloatEnable ctrlrange 1;
      setEdCtrlFloatEnable ctrlinner 0;
      setEdCtrlFloatEnable ctrlouter 0;
    )
    else
    (
      setEdCtrlFloatEnable ctrlrange 1;
      setEdCtrlFloatEnable ctrlinner 1;
      setEdCtrlFloatEnable ctrlouter 1;
    );
    
    XMLsetParam lightstr "type" elem;
    SO3LightSetType light lighttype;
    V3DshowObjectHelper viewstr sessionstr light nil 0;
    V3DshowObjectHelper viewstr sessionstr light iTypeLight 1;
  );
  0;;


/**  cbLightSetupDiffuseColor [EdControl I V3Dview] I
  *  callback on light diffuse color change
  *  
  *  private
  *
  *  return 0
  **/
fun cbLightSetupDiffuseColor(ctrlstr, color, p)=
  if color == nil then nil else
  let p -> [viewstr val type lightstr] in
  let XMLgetMarkByValueFromMarkSons lightstr "colourDiffuse" -> lightdiffusestr in
  let G2Dgetrgb color -> [r g b] in
  let ftoa ((itof r) /. 255.0) -> fr in
  let ftoa ((itof g) /. 255.0) -> fg in
  let ftoa ((itof b) /. 255.0) -> fb in
 
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in
  (
    XMLsetParam lightdiffusestr "r" fr;
    XMLsetParam lightdiffusestr "g" fg;
    XMLsetParam lightdiffusestr "b" fb;

    SO3LightSetDiffuseColor light G2Drgb2rgba color 0;
  );
  0;;


/**  cbLightSetupSpecularColor [EdControl I [V3Dview S I XMLmark]] I
  *  callback on light specular color change
  *  
  *  private
  *
  *  return 0
  **/
fun cbLightSetupSpecularColor(ctrlstr, color, p)=
  if color == nil then nil else
  let p -> [viewstr val type lightstr] in
  let XMLgetMarkByValueFromMarkSons lightstr "colourSpecular" -> lightspecularstr in
  let G2Dgetrgb color -> [r g b] in
  let ftoa ((itof r) /. 255.0) -> fr in
  let ftoa ((itof g) /. 255.0) -> fg in
  let ftoa ((itof b) /. 255.0) -> fb in  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in  
  (
    XMLsetParam lightspecularstr "r" fr;
    XMLsetParam lightspecularstr "g" fg;
    XMLsetParam lightspecularstr "b" fb;
    SO3LightSetSpecularColor light G2Drgb2rgba color 0;
  );
  0;;


/**  cbLightSetupPower [EdControl F [V3Dview S I XMLmark]] I
  *  callback on light power change
  *  
  *  private
  *
  *  return 0
  **/
fun cbLightSetupPower(ctrl, value, p)=
  let p -> [viewstr val type lightstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in  
  (
    XMLsetParam lightstr "power" XMLgetShortFloatToString value;
    SO3LightSetPowerScale light value;
  );  
  0;;


/**  cbLightSetupRange [EdControl F [V3Dview S I XMLmark]] I
  *  callback on light range change
  *  
  *  private
  *
  *  return 0
  **/
fun cbLightSetupRange(ctrl, value, p)=
  let p -> [viewstr val type lightstr] in
  let XMLgetMarkByValueFromMarkSons lightstr "lightAttenuation" -> lightattenuationstr in  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in  
  (
    XMLsetParam lightattenuationstr "range" XMLgetShortFloatToString value;
    SO3LightSetAttenuationAuto light value;
  );
  0;;


/**  cbLightSetupInnerRange [EdControl F [[V3Dview S I XMLmark] EdControl]] I
  *  callback on light inner spot range change
  *  
  *  private
  *  
  *  return 0
  **/
fun cbLightSetupInnerRange(ctrl, value, p)=
  let p -> [[viewstr val type lightstr] ctrlouter] in
  let SO3MathsDegreeToRadian value -> radang in
  let XMLgetMarkByValueFromMarkSons lightstr "lightRange" -> lightrangestr in
  let if lightrangestr == nil then (XMLaddMark xmlEditSceneFile "lightRange" lightstr nil nil) else lightrangestr -> lightrangestr in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in
  let getEdCtrlFloatValue ctrlouter -> outval in
  (
    if (outval >=. value) then nil else
    (
      setEdCtrlFloatValue ctrlouter value;
      SO3LightSetSpotOuterAngle light radang;
      XMLsetParam lightrangestr "outer" XMLgetShortFloatToString radang;
    );
    
    XMLsetParam lightrangestr "inner" XMLgetShortFloatToString radang;
    SO3LightSetSpotInnerAngle light radang;
  );
  0;;


/**  cbLightSetupOuterRange [EdControl F [[V3Dview S I XMLmark] EdControl]] I
  *  callback on light outer spot range change
  *  
  *  private
  *  
  *  return 0
  **/
fun cbLightSetupOuterRange(ctrl, value, p)=
  let p -> [[viewstr val type lightstr] ctrlinner] in
  let SO3MathsDegreeToRadian value -> radang in
  let XMLgetMarkByValueFromMarkSons lightstr "lightRange" -> lightrangestr in  
  let if lightrangestr == nil then (XMLaddMark xmlEditSceneFile "lightRange" lightstr nil nil) else lightrangestr -> lightrangestr in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in  
  let getEdCtrlFloatValue ctrlinner -> inval in
  (
    if (inval <=. value) then nil else
    (
      setEdCtrlFloatValue ctrlinner value;
      SO3LightSetSpotInnerAngle light radang;
      XMLsetParam lightrangestr "inner" XMLgetShortFloatToString radang;
    );
    
    XMLsetParam lightrangestr "outer" XMLgetShortFloatToString radang;
    SO3LightSetSpotOuterAngle light radang;
  );
  0;;


/**  cbLightSetupCastShadow [EdControl F [V3Dview S I XMLmark]] I
  *  callback on light outer spot range change
  *  
  *  private
  *  
  *  return 0
  **/
fun cbLightSetupCastShadow(ctrl, state, p)=
  let p -> [viewstr val type lightstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> light in
  (
    XMLsetParam lightstr "castShadows" (XMLgetBoolString state);
    SO3ObjectSetCastShadows light state;
  );
  0;;


fun cbTreeMenuLightEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let winLightSetup -> [wobj owinstr] in
  if wobj == obj then nil else
  (
    if winLightSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winLightSetup = nil;
    );
    
    let [400 175] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let SO3LightGetType obj -> lighttype in
    let SO3ObjectGetCastShadows obj -> lightcastshadow in
    let G2Drgba2rgb (SO3LightGetDiffuseColor obj) -> diffusecolor in
    let G2Drgba2rgb (SO3LightGetSpecularColor obj) -> specularcolor in
    
    let SO3LightGetPowerScale obj -> powerscale in
    let SO3LightGetAttenuation obj -> [range const linear quad] in
    let SO3LightGetSpotInnerAngle obj -> innerang in
    let SO3LightGetSpotOuterAngle obj -> outerang in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Light setting : " val) sWinDlgIcon -> winstr in
    let crEdCtrlLabel winstr 10 12 120 20 "Light type" nil -> labeltype in
    let crEdCtrlSelect winstr 140 10 100 120 EDWIN_RESIZE_MW -> ctrltype in
    let crEdCtrlLabel winstr 10 37 120 20 "Diffuse color" nil -> labeldcolor in
    let crEdCtrlColorButton winstr 140 35 100 20 diffusecolor 0 EDWIN_RESIZE_MW nil -> ctrldcolor in
    let crEdCtrlLabel winstr 10 62 120 20 "Specular color" nil -> labelscolor in
    let crEdCtrlColorButton winstr 140 60 100 20 specularcolor 0 EDWIN_RESIZE_MW nil -> ctrlscolor in
    
    let crEdCtrlLabel winstr 10 97 90 20 "Range" nil -> labelrange in
    let crEdCtrlFloat winstr 100 95 90 20 range 0.0 10000000.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlrange in
    let crEdCtrlLabel winstr 10 122 90 20 "Power" nil -> labelpower in
    let crEdCtrlFloat winstr 100 120 90 20 powerscale 0.0 10000.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlpower in
    
    let crEdCtrlLabel winstr 200 97 90 20 "Inner range" nil -> labelinnerrange in
    let crEdCtrlFloat winstr 300 95 90 20 (SO3MathsRadianToDegree innerang) 0.0 180.0 1.0 2 nil EDWIN_RESIZE_MW -> ctrlinner in
    let crEdCtrlLabel winstr 200 122 90 20 "Outer range" nil -> labelouterrange in
    let crEdCtrlFloat winstr 300 120 90 20 (SO3MathsRadianToDegree outerang) 0.0 180.0 1.0 2 nil EDWIN_RESIZE_MW -> ctrlouter in

    let crEdCtrlCheck winstr 10 150 190 20 "Cast shadow" EDWIN_RESIZE_MW -> ctrlshadow in
    
    let if (lighttype == SO3_SPOT_LIGHT) then "spot" else if (lighttype == SO3_DIRECTIONAL_LIGHT) then "directional" else "point" -> slighttype in  
    (
      set winLightSetup = [obj winstr];
      
      fillEdCtrlSelect ctrltype "point"::"directional"::"spot"::nil;
      if lighttype == SO3_DIRECTIONAL_LIGHT then
      (
        setEdCtrlFloatEnable ctrlrange 0;
        setEdCtrlFloatEnable ctrlinner 0;
        setEdCtrlFloatEnable ctrlouter 0;
      )
      else if lighttype == SO3_POINT_LIGHT then
      (
        setEdCtrlFloatEnable ctrlinner 0;
        setEdCtrlFloatEnable ctrlouter 0;
      )
      else nil;
      
      setEdCtrlCheckState ctrlshadow lightcastshadow;
      
      selectEdCtrlSelect ctrltype slighttype;
      setEdCtrlSelectCb ctrltype mkfun4 @cbLightSetupType [p ctrlrange ctrlinner ctrlouter];
      
      setEdCtrlColorButtonCb ctrldcolor mkfun3 @cbLightSetupDiffuseColor p;
      setEdCtrlColorButtonCb ctrlscolor mkfun3 @cbLightSetupSpecularColor p;
      
      setEdCtrlFloatCbChange ctrlpower mkfun3 @cbLightSetupPower p;
      setEdCtrlFloatCbChange ctrlrange mkfun3 @cbLightSetupRange p;
      
      setEdCtrlFloatCbChange ctrlinner mkfun3 @cbLightSetupInnerRange [p ctrlouter];
      setEdCtrlFloatCbChange ctrlouter mkfun3 @cbLightSetupOuterRange [p ctrlinner];
      
      setEdCtrlCheckCbState ctrlshadow mkfun3 @cbLightSetupCastShadow p;
        
      setEdwindowCbDestroy winstr @cbDestroyLightSetupWin;
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  Camera
/ ********************************************************************************************* */
/**  cbDestroySetupWin [EdWindow] I
  *  callback on destroy camera setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyCameraSetupWin(winstr)=
  set winCameraSetup = nil;
  0;;


fun cbCameraSetupFovy(ctrl, value, p)=
  let p -> [viewstr val type camerastr] in
  let SO3MathsDegreeToRadian value -> radang in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> camera in  
  (
    XMLsetParam camerastr "fov" XMLgetShortFloatToString radang;
    SO3CameraSetFOVy camera radang;
  );
  0;;


fun cbCameraSetupNearClip(ctrl, value, p)=
  let p -> [viewstr val type camerastr] in
  let XMLgetMarkByValueFromMarkSons camerastr "clipping" -> cameraclipstr in  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> camera in  
  (
    XMLsetParam cameraclipstr "near" XMLgetShortFloatToString value;
    SO3CameraSetNearClipDistance camera value;
  );
  0;;


fun cbCameraSetupFarClip(ctrl, value, p)=
  let p -> [viewstr val type camerastr] in
  let XMLgetMarkByValueFromMarkSons camerastr "clipping" -> cameraclipstr in  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> camera in  
  (
    XMLsetParam cameraclipstr "far" XMLgetShortFloatToString value;
    SO3CameraSetFarClipDistance camera value;
  );
  0;;


fun cbCameraSetupFovLenght(ctrl, value, p)=
  let p -> [viewstr val type camerastr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> camera in  
  (
    XMLsetParam camerastr "focalLenght" XMLgetShortFloatToString value;
    SO3CameraSetFocalLenght camera value;
  );
  0;;


fun cbTreeMenuCameraEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> cam in
  let winCameraSetup -> [wobj owinstr] in
  if wobj == cam then nil else
  (
    if winCameraSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winCameraSetup = nil;
    );
    
    let [280 110] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
    let SO3CameraGetFocalLenght cam -> fovlenght in
    let SO3CameraGetFOVy cam -> fovy in
    let SO3CameraGetNearClipDistance cam -> nearclip in
    let SO3CameraGetFarClipDistance cam -> farclip in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Camera setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 160 20 "Fov Y" nil -> labelfovy in
    let crEdCtrlFloat winstr 170 10 90 20 (SO3MathsRadianToDegree fovy) 1.0 180.0 1.0 2 nil EDWIN_RESIZE_MW -> ctrlfovy in
    let crEdCtrlLabel winstr 10 37 160 20 "Near clip" nil -> labelnearclip in
    let crEdCtrlFloat winstr 170 35 90 20 nearclip 0.001 10000000.0 0.1 4 nil EDWIN_RESIZE_MW -> ctrlnearclip in
    let crEdCtrlLabel winstr 10 62 160 20 "Far clip" nil -> labelfarclip in
    let crEdCtrlFloat winstr 170 60 90 20 farclip 0.0 10000000.0 0.1 4 nil EDWIN_RESIZE_MW -> ctrlfarclip in
    let crEdCtrlLabel winstr 10 87 160 20 "Focal lenght (STEREO)" nil -> labelfovlenght in
    let crEdCtrlFloat winstr 170 85 90 20 fovlenght 0.0 10000000.0 0.01 4 nil EDWIN_RESIZE_MW -> ctrlfovlenght in
    (
      set winCameraSetup = [cam winstr];

      setEdCtrlFloatCbChange ctrlfovy mkfun3 @cbCameraSetupFovy p;
      setEdCtrlFloatCbChange ctrlnearclip mkfun3 @cbCameraSetupNearClip p;
      setEdCtrlFloatCbChange ctrlfarclip mkfun3 @cbCameraSetupFarClip p;
      setEdCtrlFloatCbChange ctrlfovlenght mkfun3 @cbCameraSetupFovLenght p;    
      
      setEdwindowCbDestroy winstr @cbDestroyCameraSetupWin;
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  Entities
/ ********************************************************************************************* */
/**  cbDestroySetupWin [EdWindow] I
  *  callback on destroy Entity setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyEntitySetupWin(winstr)=
  set winEntitySetup = nil;
  0;;


fun cbObjectSetupCastShadow(ctrlstr, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    V3DsetObjectReceiveShadows sessionstr obj state;
    XMLsetParam markstr "castShadows" (XMLgetBoolString state);
  );
  0;;


fun cbObjectSetupHidden(ctrlstr, state, p)=
  let p -> [[viewstr val type markstr] sons] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    SO3ObjectSetVisible obj !state sons;
    XMLsetParam markstr "hidden" (XMLgetBoolString state);
  );
  0;;


fun cbObjectSetupStaticGeometry(ctrlstr, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    XMLsetParam markstr "staticGeometry" (XMLgetBoolString state);
    setGraphItemStaticGeometryState val state;
  );
  0;;

  
fun cbEntityLayerEnable(ctrlstr, state, p)=
  let p -> [[viewstr val type markstr] layerIndex] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    SO3EntitySetVisibilityFlagIndexEnable obj layerIndex state;
    XMLsetParam markstr "visibilityFlags" (itoh (SO3EntityGetVisibilityFlags obj));
  );
  0;;


/**  cbDestroySetupWin [EdWindow] I
  *  callback on destroy Entity info window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyEntityInfoWin(winstr)=
  set winEntityInfo = nil;
  0;;


fun cbTreeMenuEntityInformations(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> ent in
  let winEntityInfo -> [wobj owinstr] in
  let if winEntityInfo == nil then 1 else 0 -> reposition in
  let getEdWindowPos owinstr -> [ox oy] in
  if wobj == ent then nil else
  (
    if winEntityInfo == nil then nil else
    (
      dsEdWindow owinstr;
      set winEntityInfo = nil;
    );
    
    let [450 90] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    let if reposition then [x y] else [ox oy] -> [x y] in
    
    let SO3ObjectGetPolygonCount ent -> polycount in
    let SO3ObjectGetBoundingBoxInfo ent 0 -> [[bx by bz] _ _] in
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Object informations : " val) sWinDlgIcon -> winstr in 
    (
      crEdCtrlLabel winstr 10 12 100 20 "Mesh file name :" nil;
      crEdCtrlLabel winstr 115 12 (iw - 125) 20 (XMLgetParam markstr "path") nil;
      crEdCtrlLabel winstr 10 37 100 20 "Bounding box :" nil;
      crEdCtrlLabel winstr 115 37 (iw - 125) 20 strcatn (ftoa bx)::" "::(ftoa by)::" "::(ftoa bz)::nil nil;
      crEdCtrlLabel winstr 10 62 100 20 "Polygon count :" nil;
      crEdCtrlLabel winstr 115 62 (iw - 125) 20 (itoa polycount) nil;
      
      set winEntityInfo = [ent winstr];
      
      setEdwindowCbDestroy winstr @cbDestroyEntityInfoWin;
      0;
    );
  );
  0;;


fun cbTreeMenuEntityEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> ent in
  let winEntitySetup -> [wobj owinstr] in
  if wobj == ent then nil else
  (
    if winEntitySetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winEntitySetup = nil;
    );
    
    let [280 170] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
    let XMLgetMarkByValue xmlEditSceneFile "scene" -> scenestr in
    let XMLgetMarkByValueFromMarkSons scenestr "environment" -> envstr in
    let XMLgetMarkByValueFromMarkSons envstr "layers" -> layersstr in
    let atof (XMLgetParam markstr "renderingDistance") -> dist in
    let XMLgetBoolParam markstr "castShadows" -> castshadow in
    let XMLgetBoolParam markstr "staticGeometry" -> staticGeometry in
    let XMLgetBoolParam markstr "hidden" -> hidden in
    let htoi XMLgetParam markstr "visibilityFlags" -> visibilityflags in
    let setEdWindowIcon (crEdWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU|WN_SIZEBOX nil nil strcat "Object setting : " val) sWinDlgIcon -> mwinstr in
    let crEdScrollWindow _channel mwinstr 0 0 iw ih WN_CHILDINSIDE|WN_VSCROLL|WN_HSCROLL EDWIN_RESIZE_MW|EDWIN_RESIZE_MH EDWIN_GROUP nil -> ewinstr in
    let 10 -> ypos in
    let crEdFrameWindow _channel ewinstr 0 0 (iw - 20) 130 EDWIN_RESIZE_MW nil "Entity settings" "Minimize / Restore" -> winfrm in
    let crEdWindow _channel winfrm 0 18 (iw - 20) 110 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW nil nil -> winstr in
    let crEdCtrlLabel winstr 10 ypos + 2 120 20 "Distance visibility" nil -> labelvisibility in
    let crEdCtrlFloat winstr 130 ypos (iw - 160) 20 dist 0.0 1000000.0 0.1 6 nil nil -> ctrldist in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) (iw - 20) 20 "Cast shadow" nil -> ctrlshadow in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) (iw - 20) 20 "Hidden" nil -> ctrlhidden in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) (iw - 20) 20 "Static geometry (applied on all sons)" nil -> ctrlstatic in
    let crEdFrameWindowEx _channel ewinstr 0 0 (iw - 20) (25 * 32 + 35) nil nil "Entity visibility layers" "Minimize / Restore" 1 -> winfrm in
    let crEdWindow _channel winfrm 0 18 (iw-20) (25 * 32 + 15) WN_CHILDINSIDE|WN_NOBORDER nil nil nil -> winstr in
    (
      setEdWindowMinimumSize mwinstr iw 90;
      setEdWindowMaximumSize mwinstr iw nil;
      set winEntitySetup = [ent mwinstr];
      setEdCtrlFloatCbChange ctrldist mkfun3 @cbObjectSetupRenderVisibility p;
      setEdCtrlCheckState ctrlshadow castshadow;
      setEdCtrlCheckCbState ctrlshadow mkfun3 @cbObjectSetupCastShadow p;
      setEdCtrlCheckState ctrlhidden hidden;
      setEdCtrlCheckCbState ctrlhidden mkfun3 @cbObjectSetupHidden [p 0];
      setEdCtrlCheckState ctrlstatic staticGeometry;
      setEdCtrlCheckCbState ctrlstatic mkfun3 @cbObjectSetupStaticGeometry p;

      set ypos = 10;
      let XMLgetMarksByValueFromMarkSons layersstr "layer" -> layerlistmark in
      let 0 -> i in
      let sizelist layerlistmark -> size in
      while (i < size) do
      (
        let XMLgetParam (nth_list layerlistmark i) "name" -> layername in
        let crEdCtrlCheck winstr 10 ypos 20 20 "" EDWIN_RESIZE_MW -> ctrllayerenable in
        let crEdCtrlTextLine winstr 35 (ypos + 2) (iw - 65) 20 layername nil nil -> ctrllayername in
        (
          setEdCtrlCheckState ctrllayerenable ((visibilityflags >> i) & 1);
          setEdCtrlCheckCbState ctrllayerenable mkfun3 @cbEntityLayerEnable [p i];
          setEdCtrlTextLineEnable ctrllayername 0;
          set ypos = ypos + 25;
        );
        set i = i + 1;
      );
      
      setEdwindowCbDestroy mwinstr @cbDestroyEntitySetupWin;
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  Nodes
/ ********************************************************************************************* */
/**  cbDestroyNodeSetupWin [EdWindow] I
  *  callback on destroy Node setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyNodeSetupWin(winstr)=
  set winNodeSetup = nil;
  0;;


fun cbTreeMenuNodeEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> node in
  let winNodeSetup -> [wobj owinstr] in
  if wobj == node then nil else
  (
    if winNodeSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winNodeSetup = nil;
    );
    
    let [280 60] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
    let XMLgetBoolParam markstr "hidden" -> hidden in
    let XMLgetBoolParam markstr "staticGeometry" -> staticGeometry in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Object setting : " val) sWinDlgIcon -> winstr in
    let 10 -> ypos in
    let crEdCtrlCheck winstr 10 (set ypos = 10) (iw - 20) 20 "Hidden (applied on all sons)" EDWIN_RESIZE_MW -> ctrlhidden in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) (iw - 20) 20 "Static geometry (applied on all sons)" EDWIN_RESIZE_MW -> ctrlstatic in
    (
      set winNodeSetup = [node winstr];

      setEdCtrlCheckState ctrlhidden hidden;
      setEdCtrlCheckCbState ctrlhidden mkfun3 @cbObjectSetupHidden [p 1];
      setEdCtrlCheckState ctrlstatic staticGeometry;
      setEdCtrlCheckCbState ctrlstatic mkfun3 @cbObjectSetupStaticGeometry p;
      
      setEdwindowCbDestroy winstr @cbDestroyNodeSetupWin;
      0;
    );
  );
  0;;


/* ********************************************************************************************* /
  Animations
/ ********************************************************************************************* */
/**  cbDestroyAnimSetupWin [EdWindow] I
  *  callback on destroy animation setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyAnimSetupWin(winstr, p)=
  let p -> [viewstr val type markstr] in
  let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    if trm == nil then nil else
      _deltimer trm;
      
    V3DanimationsEnableScene sessionstr 0 0;
  );
  
  set winAnimSetup = nil;
  0;;


fun cbAnimSetupEnable(ctrl, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    setGraphItemInitState val state;
  );
  0;;


fun cbAnimSetupLoop(mnuitem, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "loop" XMLgetBoolString state;
    V3DsetAnimationLoop animstr state;
  );
  0;;


fun cbAnimSetupSkipFrame(mnuitem, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "skipFrame" XMLgetBoolString state;
    V3DanimationSetDefaultSkipFrame animstr state;
  );
  0;;


fun cbAnimSetupSpeed(ctrl, value, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "speed" XMLgetShortFloatToString value;
    V3DsetAnimationSpeed animstr value;
  );
  0;;


fun cbAnimSetupWeight(ctrl, value, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "weight" XMLgetShortFloatToString value;
    V3DsetAnimationWeight animstr value;
  );
  0;;


fun cbAnimSetupInterpolationMode(ctrl, pos, elem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "interpolationMode" elem;
    V3DsetAnimationInterpolationMode animstr (getOgreAnimationInterpolationType elem);
  );
  0;;


fun cbAnimSetupRotInterpolationMode(ctrl, pos, elem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    XMLsetParam markstr "rotationInterpolationMode" elem;
    V3DsetAnimationRotInterpolationMode animstr (getOgreAnimationRotInterpolationType elem);
  );
  0;;


fun cbAnimSetupPlayPause(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    if state then
    (
      V3DsetAnimationState animstr 0;
      if (!animstr.V3D_bAnimReset) then nil else
        V3DinitializeAnimation animstr 0;

      V3DplayAnimation animstr;
    )
    else
    (
      V3DpauseAnimation animstr;
    );
  );
  0;;


fun cbAnimSetupStop(tbstr, check, btn, mask, p)=
  let p -> [[viewstr val type markstr] chkplaypause] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  (
    V3DstopAnimation animstr;
    V3DresetAnimation animstr;
    
    setEdToolBarCheckState tbstr chkplaypause 0;
  );
  0;;


fun cbTreeMenuAnimEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  let winAnimSetup -> [wanimstr owinstr _ _ _] in
  if wanimstr == animstr then nil else
  (
    if winAnimSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winAnimSetup = nil;
    );
            
    let [320 218] -> [iw ih] in
    let 10 -> ypos in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let XMLgetBoolParam markstr "enable" -> animstate in
    let XMLgetBoolParam markstr "loop" -> animloop in
    let XMLgetParam markstr "type" -> animtype in
    let XMLgetParam markstr "interpolationMode" -> intmode in
    let XMLgetParam markstr "rotationInterpolationMode" -> rotintmode in
    let atof (XMLgetParam markstr "speed") -> animspeed in
    let atof (XMLgetParam markstr "weight") -> animweight in
    let XMLgetBoolParam markstr "skipFrame" -> skipframe in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Animation setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 (ypos + 2) 190 20 "Interpolation mode" nil -> labelint in
    let crEdCtrlSelect winstr 210 ypos 100 120 EDWIN_RESIZE_MW -> ctrlint in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 190 20 "Rotation interpolation mode" nil -> labelrotint in
    let crEdCtrlSelect winstr 210 ypos 100 120 EDWIN_RESIZE_MW -> ctrlrotint in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 190 20 "Speed" nil -> labelspeed in
    let crEdCtrlFloat winstr 210 ypos 100 20 animspeed (-.100000.0) 100000.0 0.1 5 nil EDWIN_RESIZE_MW -> ctrlspeed in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 190 20 "Weight" nil -> labelweight in
    let crEdCtrlFloat winstr 210 ypos 100 20 animweight (0.0) 1.0 0.001 5 nil EDWIN_RESIZE_MW -> ctrlweight in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Loop" EDWIN_RESIZE_MW -> ctrlloop in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Skip frame (Ignore lost frames)" EDWIN_RESIZE_MW -> ctrlskipframe in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    
    let crEdWindowToolBar winstr 0 (ih-28) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_stop.png" -> astop in
    let crEdToolBarButton tbstr astop ETB_ALIGN_LEFT "Stop" nil -> chkstop in
    (
      setEdToolBarVisible tbstr 1;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbAnimSetupPlayPause p;
      setEdToolBarButtonCbClick tbstr chkstop mkfun5 @cbAnimSetupStop [p chkplaypause];
      
      if (!strcmpi animtype "node") then nil else
      (
        setEdCtrlSelectEnable ctrlint 0;
        setEdCtrlSelectEnable ctrlrotint 0;
      );
      
      set winAnimSetup = [animstr winstr tbstr chkplaypause nil];
      
      setEdCtrlCheckState ctrlloop animloop;
      setEdCtrlCheckCbState ctrlloop mkfun3 @cbAnimSetupLoop p;
      
      setEdCtrlCheckState ctrlskipframe skipframe;
      setEdCtrlCheckCbState ctrlskipframe mkfun3 @cbAnimSetupSkipFrame p;
      
      setEdCtrlCheckState ctrlenable animstate;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbAnimSetupEnable p;
      
      fillEdCtrlSelect ctrlint "linear"::"spline"::nil;
      selectEdCtrlSelect ctrlint intmode;
      setEdCtrlSelectCb ctrlint mkfun4 @cbAnimSetupInterpolationMode p;
      
      fillEdCtrlSelect ctrlrotint "linear"::"spherical"::nil;
      selectEdCtrlSelect ctrlrotint rotintmode;
      setEdCtrlSelectCb ctrlrotint mkfun4 @cbAnimSetupRotInterpolationMode p;
      
      setEdCtrlFloatCbChange ctrlspeed mkfun3 @cbAnimSetupSpeed p;
      setEdCtrlFloatCbChange ctrlweight mkfun3 @cbAnimSetupWeight p;
      
      setEdwindowCbDestroy winstr mkfun2 @cbDestroyAnimSetupWin p;
      
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


fun cbAnimSetupSlider(ctrlstr, value, p)=
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  (
    if trm == nil then nil else
    (
      _deltimer trm;
      mutate winAnimSetup <- [_ _ _ _ nil];
    );
      
    if (!animstr.V3D_bAnimReset) then nil else
      V3DinitializeAnimation animstr 0;
    
    V3DplayAnimation animstr;
    V3DsetAnimationPosition animstr value;
    V3DpauseAnimation animstr;
    
    setEdToolBarCheckState tbstr chkplaypause 0;
  );
  0;;


fun refreshAnimSetupTrack(ctrltimeline, animstr, trackidx)=
  let V3DgetNbAnimationTrackKeys animstr trackidx -> nbkeys in
  let getEdCtrlTimeLineTrackByPos ctrltimeline trackidx -> trackstr in
  let 0 -> i in
  while i < nbkeys do
  (
    let V3DgetSequenceAnimationKeyInfos animstr trackidx i -> [_ kpos klength ktrans kdecal] in
    let getEdCtrlTimeLineKeyByPos trackstr i -> keystr in
      setEdCtrlTimeLinekeyParams ctrltimeline keystr kpos klength;
    
    set i = i + 1;
  );
  setEdCtrlTimeLineLength ctrltimeline (V3DgetAnimationLenght animstr);
  0;;


fun cbAnimSetupKeyLength(ctrlstr, value, p)=
  let p -> [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx] in
  let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
  let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
  let nth_list ltrackmarks trackidx -> trackmark in
  let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
  let nth_list lkeymarks keyidx -> keymark in
  (
    XMLsetParam keymark "length" XMLgetShortFloatToString value;
    V3DsetSequenceAnimationKeyInfos animstr trackidx keyidx value ktrans kdecal;
    
    refreshAnimSetupTrack ctrltimeline animstr trackidx;
  );
  0;;


fun cbAnimSetupKeyTrans(ctrlstr, value, p)=
  let p -> [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx] in
  let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
  let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
  let nth_list ltrackmarks trackidx -> trackmark in
  let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
  let nth_list lkeymarks keyidx -> keymark in
  (
    XMLsetParam keymark "transition" XMLgetShortFloatToString value;
    V3DsetSequenceAnimationKeyInfos animstr trackidx keyidx klength value kdecal;
    
    refreshAnimSetupTrack ctrltimeline animstr trackidx;
  );
  0;;


fun cbAnimSetupKeyDecal(ctrlstr, value, p)=
  let p -> [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx] in
  let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
  let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
  let nth_list ltrackmarks trackidx -> trackmark in
  let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
  let nth_list lkeymarks keyidx -> keymark in
  (
    XMLsetParam keymark "decal" XMLgetShortFloatToString value;
    V3DsetSequenceAnimationKeyInfos animstr trackidx keyidx klength ktrans value;
    
    refreshAnimSetupTrack ctrltimeline animstr trackidx;
  );
  0;;


fun cbAnimSetupSelectKey(ctrlstr, keystr, p)=
  let p -> [[viewstr val type markstr] ctrltimeline ctrllength ctrltrans ctrldecal] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  if keystr != nil then
  let getEdCtrlTimeLineKeyTrack keystr -> trackstr in
  let getEdCtrlTimeLineTrackPos trackstr -> trackidx in
  let getEdCtrlTimeLineKeyPos keystr -> keyidx in
  let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
  (
    setEdCtrlFloatCbChange ctrllength mkfun3 @cbAnimSetupKeyLength [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx];
    setEdCtrlFloatCbChange ctrltrans mkfun3 @cbAnimSetupKeyTrans [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx];
    setEdCtrlFloatCbChange ctrldecal mkfun3 @cbAnimSetupKeyDecal [[viewstr val type markstr] ctrltimeline animstr trackidx keyidx];

    setEdCtrlFloatEnable ctrllength 1;
    setEdCtrlFloatEnable ctrltrans 1;
    setEdCtrlFloatEnable ctrldecal 1;
    
    setEdCtrlFloatValue ctrllength klength;
    setEdCtrlFloatValue ctrltrans ktrans;
    setEdCtrlFloatValue ctrldecal kdecal;
    
    if (!animstr.V3D_bAnimReset) then nil else
      V3DinitializeAnimation animstr 0;
    
    setEdCtrlTimeLineValue ctrltimeline kpos;
    
    V3DplayAnimation animstr;
    V3DsetAnimationPosition animstr kpos;
    V3DpauseAnimation animstr;
    
    setEdToolBarCheckState tbstr chkplaypause 0;
  )
  else
  (
    setEdCtrlFloatCbChange ctrllength nil;
    setEdCtrlFloatCbChange ctrltrans nil;
    setEdCtrlFloatCbChange ctrldecal nil;
    
    setEdCtrlFloatEnable ctrllength 0;
    setEdCtrlFloatEnable ctrltrans 0;
    setEdCtrlFloatEnable ctrldecal 0;
    
    setEdCtrlFloatValue ctrllength 0.0;
    setEdCtrlFloatValue ctrltrans 0.0;
    setEdCtrlFloatValue ctrldecal 0.0;
  );
  0;;


fun cbAnimSetupSeqUpdate(trm, p)=
  let p -> [animstr ctrltimeline] in
  (      
    setEdCtrlTimeLineValue ctrltimeline V3DgetAnimationPosition animstr;
  );
  0;;


fun cbAnimSetupSeqPlayPause(tbstr, check, btn, mask, state, ctrltimeline)=
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  (      
    if state then
    (
      V3DsetAnimationState animstr 0;
      if (!animstr.V3D_bAnimReset) then nil else
        V3DinitializeAnimation animstr 0;
      
      V3DplayAnimation animstr;
      
      if trm != nil then nil else
        mutate winAnimSetup <- [_ _ _ _ (_rfltimer _starttimer _channel (1000/30) @cbAnimSetupSeqUpdate [animstr ctrltimeline])];
    )
    else
    (
      V3DpauseAnimation animstr;
      if trm == nil then nil else
      (
        _deltimer trm;
        mutate winAnimSetup <- [_ _ _ _ nil];
      );
    );
  );
  0;;


fun cbAnimSetupSeqStop(tbstr, check, btn, mask, ctrltimeline)=
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  (
    V3DstopAnimation animstr;
    V3DresetAnimation animstr;
    setEdCtrlTimeLineValue ctrltimeline 0.0;
    
    setEdToolBarCheckState tbstr chkplaypause 0;
    if trm == nil then nil else
    (
      _deltimer trm;
      mutate winAnimSetup  <- [_ _ _ _ nil];
    );
  );
  0;;


fun cbAnimSetupSeqZoomIn(tbstr, check, btn, mask, ctrltimeline)=
  let (getEdCtrlTimeLinePixelPerUnit ctrltimeline) -> cursize in
  if cursize >= 200 then nil else
    setEdCtrlTimeLinePixelPerUnit ctrltimeline cursize * 2 1;
  0;;


fun cbAnimSetupSeqZoomOut(tbstr, check, btn, mask, ctrltimeline)=
  let (getEdCtrlTimeLinePixelPerUnit ctrltimeline) -> cursize in
  if cursize <= 2 then nil else
    setEdCtrlTimeLinePixelPerUnit ctrltimeline cursize / 2 1;
  0;;


fun cbAnimSetupSeqAddTrack(tbstr, check, btn, mask, p)=
  let p -> [ctrltimeline [viewstr val type markstr]] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  let addEdCtrlTimeLineTrack ctrltimeline 1 -> trackstr in
  (
    selectEdCtrlTimeLineTrack ctrltimeline trackstr;
    V3DaddSequenceAnimationTrack animstr;
    XMLaddMark xmlEditSceneFile "track" markstr nil nil;
  );
  0;;


fun cbDlgAnimSetupRemoveTrack(dlg, p, state)=
  if !state then nil else
  let p -> [winstr ctrltimeline [viewstr val type markstr]] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  let getEdCtrlTimeLineSelectedTrack ctrltimeline -> trackstr in
  let getEdCtrlTimeLineTrackPos trackstr -> trackidx in
  let getEdCtrlTimeLineTrackByPos ctrltimeline (if trackidx >= 1 then trackidx - 1 else trackidx + 1) -> prevtrack in
  (
    removeEdCtrlTimeLineTrack ctrltimeline trackstr 1;
    V3DdelSequenceAnimationTrack animstr trackidx;
    let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
    let nth_list ltrackmarks trackidx -> trackmark in
      XMLdelMark xmlEditSceneFile trackmark;
    
    selectEdCtrlTimeLineTrack ctrltimeline prevtrack;
  );
  0;;


fun cbAnimSetupSeqDelTrack(tbstr, check, btn, mask, p)=
  let p -> [winstr ctrltimeline [viewstr val type markstr]] in
  let getEdCtrlTimeLineSelectedTrack ctrltimeline -> trackstr in
  if trackstr == nil then nil else
    _DLGrflmessage _DLGMessageBox _channel winstr.EDW_win "Warning" "Are you sure to remove the selected track ?" 1 @cbDlgAnimSetupRemoveTrack p;
  0;;


fun cbAnimSetupAddSelectAnimKey(kanimname, type, p)=
  let p -> [ctrltimeline [viewstr val type markstr]] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getEdCtrlTimeLineSelectedTrack ctrltimeline -> trackstr in
  let V3DgetAnimationByName sessionstr kanimname -> kanimstr in
  if (trackstr == nil) || (kanimstr == nil) || (kanimstr == animstr) then nil else
  (
    if (!kanimstr.V3D_bAnimReset) then nil else
      V3DinitializeAnimation kanimstr 0;
    
    let getEdCtrlTimeLineTrackPos trackstr -> trackidx in
    let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
    let nth_list ltrackmarks trackidx -> trackmark in
    let (V3DgetAnimationLenght kanimstr) -> lenght in
    let if lenght <=. 0.0 then 0.10 else lenght -> lenght in
    let V3DaddSequenceAnimationKey animstr trackidx kanimstr lenght 0.0 0.0 -> keyidx in
    let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
    (
      addEdCtrlTimeLineKey ctrltimeline trackidx kanimstr.V3D_sAnimName kpos klength 1;
      XMLaddMark xmlEditSceneFile "keyframe" trackmark ["animId" (itoa kanimstr.V3D_iAnimId)]::["animName" kanimstr.V3D_sBaseName]::["length" (XMLgetShortFloatToString klength)]::["transition" (XMLgetShortFloatToString ktrans)]::["decal" (XMLgetShortFloatToString kdecal)]::nil nil;
      setEdCtrlTimeLineLength ctrltimeline (V3DgetAnimationLenght animstr);
    );
  );
  0;;


fun cbAnimSetupCloseRes(p)=
  let p -> [tbstr check] in
    setEdToolBarButtonEnable tbstr check 1;
  0;;


fun cbAnimSetupSeqAddKey(tbstr, check, btn, mask, p)=
  let p -> [winstr ctrltimeline kp] in
  (
    setEdToolBarButtonEnable tbstr check 0;
    dlgSelectPluginResource (getGroupByName "Scene") winstr iTypeGroup|iTypeAnim nil mkfun3 @cbAnimSetupAddSelectAnimKey [ctrltimeline kp] mkfun1 @cbAnimSetupCloseRes [tbstr check] 0;
  );
  0;;


fun cbDlgAnimSetupRemoveKey(dlg, p, state)=
  if !state then nil else
  let p -> [winstr ctrltimeline [viewstr val type markstr]] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  let getEdCtrlTimeLineSelectedTrack ctrltimeline -> trackstr in
  let getEdCtrlTimeLineTrackPos trackstr -> trackidx in
  let getEdCtrlTimeLineSelectedKey ctrltimeline -> keystr in
  let getEdCtrlTimeLineKeyPos keystr -> keyidx in
  let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ kpos klength ktrans kdecal] in
  let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
  let nth_list ltrackmarks trackidx -> trackmark in
  (
    removeEdCtrlTimeLineKey ctrltimeline keystr 1;
    V3DdelSequenceAnimationKey animstr trackidx keyidx;

    let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
    let nth_list lkeymarks keyidx -> keymark in
      XMLdelMark xmlEditSceneFile keymark;
    
    //decal the next key to keep it in place
    let getEdCtrlTimeLineKeyByPos trackstr keyidx -> nextkeystr in
    if (nextkeystr == nil) then nil else
    let XMLgetMarksByValueFromMarkSons trackmark "keyframe" -> lkeymarks in
    let nth_list lkeymarks keyidx -> nextkeymark in
    let V3DgetSequenceAnimationKeyInfos animstr trackidx keyidx -> [_ nkpos nklength nktrans nkdecal] in
    let kdecal +. klength -. ktrans +. nkdecal -> ndecal in
    (
      V3DsetSequenceAnimationKeyInfos animstr trackidx keyidx nklength nktrans ndecal;
      XMLsetParam nextkeymark "decal" XMLgetShortFloatToString ndecal; 
    );
    setEdCtrlTimeLineLength ctrltimeline (V3DgetAnimationLenght animstr);
  );
  0;;


fun cbAnimSetupSeqDelKey(tbstr, check, btn, mask, p)=
  let p -> [winstr ctrltimeline [viewstr val type markstr]] in
  let getEdCtrlTimeLineSelectedKey ctrltimeline -> keystr in
  if keystr == nil then nil else
    _DLGrflmessage _DLGMessageBox _channel winstr.EDW_win "Warning" "Are you sure to remove the selected key ?" 1 @cbDlgAnimSetupRemoveKey p;
  0;;


fun cbAnimSetupSeqMoveKey(tbstr, check, btn, mask, p)=
  let p -> [winstr ctrltimeline [viewstr val type markstr] dir] in
  let winAnimSetup -> [animstr ewinstr tbstr chkplaypause trm] in
  let getEdCtrlTimeLineSelectedTrack ctrltimeline -> trackstr in
  let getEdCtrlTimeLineTrackPos trackstr -> trackidx in
  let getEdCtrlTimeLineSelectedKey ctrltimeline -> keystr in
  let getEdCtrlTimeLineKeyPos keystr -> keyidx in
  let V3DgetNbAnimationTrackKeys animstr trackidx -> nbkeys in
  if (trackstr == nil) || (keystr == nil) ||
     ((keyidx >= (nbkeys - 1)) && (dir >= 0)) ||
     ((keyidx <= 0) && (dir <= 0))
  then nil else
  
  let XMLgetMarksByValueFromMarkSons markstr "track" -> ltrackmarks in
  let nth_list ltrackmarks trackidx -> trackmark in
  (
    //addLogMessage strcat "val > " itoa (keyidx + dir);
    V3DmoveSequenceAnimationKey animstr trackidx keyidx keyidx + dir;
    moveEdCtrlTimeLineKey trackstr keyidx keyidx + dir;
    XMLmoveMarkSons trackmark keyidx keyidx + dir;
    refreshAnimSetupTrack ctrltimeline animstr trackidx;
  );
  0;;


fun cbTreeMenuAnimEdit(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  let winAnimSetup -> [wanimstr owinstr _ _ _] in
  if wanimstr == animstr then nil else
  (
    if winAnimSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winAnimSetup = nil;
    );
    
    V3DanimationsEnableScene sessionstr 1 0;
    
    let [600 400] -> [iw ih] in
    let 38 -> ypos in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let XMLgetBoolParam markstr "enable" -> animstate in
    let XMLgetBoolParam markstr "loop" -> animloop in
    let XMLgetParam markstr "type" -> animtype in
    let atof (XMLgetParam markstr "speed") -> animspeed in
    let atof (XMLgetParam markstr "weight") -> animweight in
    let XMLgetBoolParam markstr "skipFrame" -> skipframe in
    
    let setEdWindowIcon (crEdWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU|WN_SIZEBOX nil EDWIN_GROUP strcat "Animation setting : " val) sWinDlgIcon -> ewinstr in
    
    let crEdFrameWindow _channel ewinstr 0 0 iw 236 EDWIN_RESIZE_MW|EDWIN_RESIZE_MH nil "Animation editor" "Minimize / Restore" -> winfrm in
    let crEdWindow _channel winfrm 0 18 iw 220 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_MH nil nil -> winstr in
    let crEdWindowToolBar winstr 0 (set ypos = 1) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_stop.png" -> astop in
    let crEdToolBarButton tbstr astop ETB_ALIGN_LEFT "Stop" nil -> chkstop in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_hseparator.png" -> asep in
    let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_addtrack.png" -> aaddtrack in
    let crEdToolBarButton tbstr aaddtrack ETB_ALIGN_LEFT "Add track" nil -> chkaddtrack in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_deltrack.png" -> adeltrack in
    let crEdToolBarButton tbstr adeltrack ETB_ALIGN_LEFT "Del track" nil -> chkdeltrack in
    let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_addkey.png" -> aaddkey in
    let crEdToolBarButton tbstr aaddkey ETB_ALIGN_LEFT "Add key" nil -> chkaddkey in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_delkey.png" -> adelkey in
    let crEdToolBarButton tbstr adelkey ETB_ALIGN_LEFT "Del key" nil -> chkdelkey in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_movekey_left.png" -> amvleftkey in
    let crEdToolBarButton tbstr amvleftkey ETB_ALIGN_LEFT "Move key on left" nil -> chkmvleftkey in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_movekey_right.png" -> amvrightkey in
    let crEdToolBarButton tbstr amvrightkey ETB_ALIGN_LEFT "Move key on right" nil -> chkmvrightkey in
    let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_zoomin.png" -> azoomin in
    let crEdToolBarButton tbstr azoomin ETB_ALIGN_LEFT "Zoom in" nil -> chkzoomin in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_zoomout.png" -> azoomout in
    let crEdToolBarButton tbstr azoomout ETB_ALIGN_LEFT "Zoom out" nil -> chkzoomout in
    
    //let crEdCtrlSlider winstr 10 35 (iw - 20) 20 0.0 0.0 (V3DgetAnimationLenght animstr) nil EDWIN_RESIZE_MW nil -> ctrlslider in
    let crEdCtrlTimeLineEditor winstr 0 (set ypos = ypos + 29) iw 190 40 100 (V3DgetAnimationLenght animstr) 400 EDWIN_RESIZE_MW|EDWIN_RESIZE_MH nil -> ctrltimeline in
    let setEdWindowBackgroundColor (crEdWindow _channel winstr 0 190 402 29 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_LH|EDWIN_RESIZE_RW nil nil) iG2DDEFAULTBACKGROUNDCOLOR -> statuswinstr in
    let crEdCtrlColorLabel statuswinstr 10 5 50 18 "Length :" nil iG2DDEFAULTBACKGROUNDCOLOR nil -> labellength in
    let crEdCtrlFloat statuswinstr 60 4 70 20 0.001 0.001 1000.0 0.001 5 nil nil -> ctrllength in
    let crEdCtrlColorLabel statuswinstr 140 5 70 18 "Transition :" nil iG2DDEFAULTBACKGROUNDCOLOR nil -> labeltrans in
    let crEdCtrlFloat statuswinstr 210 4 70 20 0.0 0.0 1000.0 0.001 5 nil nil -> ctrltrans in    
    let crEdCtrlColorLabel statuswinstr 290 5 40 18 "Decal :" nil iG2DDEFAULTBACKGROUNDCOLOR nil -> labeldecal in
    let crEdCtrlFloat statuswinstr 330 4 70 20 0.0 0.0 1000.0 0.001 5 nil nil -> ctrldecal in
    
    let crEdFrameWindow _channel ewinstr 0 135 iw 160 EDWIN_RESIZE_MW nil "Animation setting" "Minimize / Restore" -> winfrm in
    let crEdWindow _channel winfrm 0 18 iw 135 WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW nil nil -> winstr in
    let crEdCtrlLabel winstr 10 ((set ypos = 10) + 2) 190 20 "Speed" nil -> labelspeed in
    let crEdCtrlFloat winstr 210 ypos 100 20 animspeed (-.100000.0) 100000.0 0.1 5 nil nil -> ctrlspeed in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 190 20 "Weight" nil -> labelweight in
    let crEdCtrlFloat winstr 210 ypos 100 20 animweight (0.0) 1.0 0.001 5 nil nil -> ctrlweight in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Loop" nil -> ctrlloop in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Skip frame (Ignore lost frames)" nil -> ctrlskipframe in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Enable" nil -> ctrlenable in
    (
      setEdWindowMinimumSize ewinstr iw ih;
      setEdToolBarVisible tbstr 1;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbAnimSetupSeqPlayPause ctrltimeline;
      setEdToolBarButtonCbClick tbstr chkstop mkfun5 @cbAnimSetupSeqStop ctrltimeline;

      setEdToolBarButtonCbClick tbstr chkaddtrack mkfun5 @cbAnimSetupSeqAddTrack [ctrltimeline p];
      setEdToolBarButtonCbClick tbstr chkdeltrack mkfun5 @cbAnimSetupSeqDelTrack [winfrm ctrltimeline p];
      setEdToolBarButtonCbClick tbstr chkaddkey mkfun5 @cbAnimSetupSeqAddKey [winfrm ctrltimeline p];
      setEdToolBarButtonCbClick tbstr chkdelkey mkfun5 @cbAnimSetupSeqDelKey [winfrm ctrltimeline p];
      setEdToolBarButtonCbClick tbstr chkmvleftkey mkfun5 @cbAnimSetupSeqMoveKey [winfrm ctrltimeline p (-1)];
      setEdToolBarButtonCbClick tbstr chkmvrightkey mkfun5 @cbAnimSetupSeqMoveKey [winfrm ctrltimeline p 1];
                  
      setEdToolBarButtonCbClick tbstr chkzoomin mkfun5 @cbAnimSetupSeqZoomIn ctrltimeline;
      setEdToolBarButtonCbClick tbstr chkzoomout mkfun5 @cbAnimSetupSeqZoomOut ctrltimeline;
      
      set winAnimSetup = [animstr ewinstr tbstr chkplaypause nil];
      
      setEdCtrlFloatEnable ctrllength 0;
      setEdCtrlFloatEnable ctrltrans 0;
      setEdCtrlFloatEnable ctrldecal 0;
      setEdCtrlTimeLineCbValue ctrltimeline mkfun3 @cbAnimSetupSlider nil;
      setEdCtrlTimeLineCbSelectKey ctrltimeline mkfun3 @cbAnimSetupSelectKey [p ctrltimeline ctrllength ctrltrans ctrldecal];
      
      setEdCtrlCheckState ctrlloop animloop;
      setEdCtrlCheckCbState ctrlloop mkfun3 @cbAnimSetupLoop p;
      
      setEdCtrlCheckState ctrlskipframe skipframe;
      setEdCtrlCheckCbState ctrlskipframe mkfun3 @cbAnimSetupSkipFrame p;
      
      setEdCtrlCheckState ctrlenable animstate;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbAnimSetupEnable p;
      
      setEdCtrlFloatCbChange ctrlspeed mkfun3 @cbAnimSetupSpeed p;
      setEdCtrlFloatCbChange ctrlweight mkfun3 @cbAnimSetupWeight p;
      
      setEdwindowCbDestroy ewinstr mkfun2 @cbDestroyAnimSetupWin p;
      
      let V3DgetNbAnimationTracks animstr -> nbtracks in
      let 0 -> i in
      while i < nbtracks do
      (
        let V3DgetNbAnimationTrackKeys animstr i -> nbkeys in
        let if nbkeys == nil then 0 else nbkeys -> nbkeys in
        let addEdCtrlTimeLineTrack ctrltimeline 0 -> trackstr in
        let 0 -> j in
        while j < nbkeys do
        (
          let V3DgetSequenceAnimationKeyInfos animstr i j -> [kanimstr kpos klength ktrans kdecal] in
          (
            addEdCtrlTimeLineKey ctrltimeline i kanimstr.V3D_sAnimName kpos klength 0;
          );
          
          set j = j + 1;
        );
        
        set i = i + 1;
      );
      
      updateEdCtrlTimeLineTracks ctrltimeline 1;
      
      selectEdCtrlTimeLineTrack ctrltimeline (getEdCtrlTimeLineTrackByPos ctrltimeline 0);
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


fun cbTreeMenuObjectCastShadow(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetCastShadows obj -> meshcastshadow in
  (
    SO3ObjectSetCastShadows obj !meshcastshadow;
    XMLsetParam markstr "castShadows" (XMLgetBoolString !meshcastshadow);
  );
  0;;


fun cbTreeMenuObjectReceiveShadow(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let XMLgetBoolParam markstr "receiveShadows" -> meshreceiveshadow in
  (
    V3DsetObjectReceiveShadows sessionstr obj !meshreceiveshadow;
    XMLsetParam markstr "receiveShadows" (XMLgetBoolString !meshreceiveshadow);
  );
  0;;


fun removeObjectSons(viewstr, treenode, delmark)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getEdCtrlTreeSonsItem ctrlSceneTree treenode -> lsons in
  let sizelist lsons -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list lsons i -> treeitem in
    let getEdCtrlTreeValueByItem ctrlSceneTree treeitem -> [sname _] in
    let SO3SceneGetObject (V3DgetSession sessionstr) sname -> son in
    let getGraphByValue sname -> tgraph in
    let tgraph -> [_ type alias markstr path groupmark initstate staticgeometry] in
    (
      removeObjectSons viewstr treeitem delmark;
      
      // remove from resources and mesh list and tree
      delGraphItem sname;
      
      if (type != iTypeCamera) then nil else
      if (son != (V3DgetViewportCamera (V3DgetDefaultViewport viewstr))) then nil else
      let V3DgetObjectByName sessionstr "default_camera" -> defaultcam in
      (
        V3DsetDefaultCamera sessionstr defaultcam;
        V3DenableNavigate sessionstr 1;
      );      
      
      if type != iTypeGroup then nil else
        deleteOsGroup viewstr markstr;
      
      if type != iTypeAnim then nil else
      let (V3DgetAnimationByName sessionstr sname) -> animstr in
      (
        let winAnimSetup -> [lobj swinstr _ _ trm] in
        if animstr != lobj then nil else
        (
          if trm == nil then nil else
            _deltimer trm;
          dsEdWindow swinstr;
          set winAnimSetup = nil;
        );
        
        V3DdelAnimation sessionstr animstr;
      );
      
      if treeitem == nil then nil else
        delEdCtrlTreeItem ctrlSceneTree treeitem;
      
      if !delmark then nil else
        XMLdelMark xmlEditSceneFile markstr;
      
      if (path == nil) || !delmark then nil else
      let XMLgetMarkByValueFromMarkSons groupmark "graph" -> ggraph in
      let XMLgetMarkByValueAndParamValueFromMark ggraph "mesh" "path" path -> resexist in
      if (resexist.XMLvalue != nil) then nil else
      let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
      let XMLgetMarkByValueAndParamValueFromMarkSons resourcesmark "resource" "path" (strlowercase path) -> resmark in
      (
        XMLdelMark xmlEditSceneFile resmark;
        delEdCtrlList ctrlResourcesList (strlowercase path);
        delEdCtrlList ctrlMeshList (strlowercase path);
      );
      
      let winLightSetup -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winLightSetup = nil;
      );
      
      let winCameraSetup -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winCameraSetup = nil;
      );
      
      //physics
      physicsDestroyNodeSetting son;
      
      let winMeshMaterialSetup -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winMeshMaterialSetup = nil;
      );      
      
      let winSkySetup -> [skname swinstr] in
      if (strcmp sname skname) then nil else
      (
        dsEdWindow swinstr;
        set winSkySetup = nil;
      );
      
      let winParticleSetup -> [lobj swinstr _ _] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winParticleSetup = nil;
      );
            
      let winCubeMapSetup -> [lobj swinstr _ _] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winCubeMapSetup = nil;
      );
      
      let winReflectionMapSetup -> [lobj swinstr _ _] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winReflectionMapSetup = nil;
      );
      
      let winCompositorSetup -> [name swinstr] in
      if (strcmp sname name) then nil else
      (
        dsEdWindow swinstr;
        set winCompositorSetup = nil;
      );
      
      let winNodeSetup -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winNodeSetup = nil;
      );
      
      let winEntitySetup -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winEntitySetup = nil;
      );
      
      let winEntityInfo -> [lobj swinstr] in
      if son != lobj then nil else
      (
        dsEdWindow swinstr;
        set winEntityInfo = nil;
      );
      
      V3DshowObjectHelper viewstr sessionstr son nil 0;
      SO3ObjectDestroy son;
      
      if type != iTypeGroup then nil else
        SO3GroupDelete (V3DgetSession sessionstr) sname;
    );
    
    set i = i + 1;
  );
  0;;


fun cbDlgObjectRemove(dlg, p, rep)=
  let p -> [viewstr val type markstr] in
  (
    if !rep then nil else
    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
    let getGraphByValue val -> tgraph in
    let tgraph -> [treeitem type alias _ path groupmark initstate staticgeometry] in  
    (
      // apply on all sons
      removeObjectSons viewstr treeitem 1;
      
      // refresh physic materials
      updateScenePhysicsMaterialList;
      
      if (type != iTypeGroup) then nil else      
        deleteOsGroup viewstr markstr;
      
      if (type != iTypeCamera) then nil else
      if (obj != (V3DgetViewportCamera (V3DgetDefaultViewport viewstr))) then nil else
      let V3DgetObjectByName sessionstr "default_camera" -> defaultcam in
      (
        V3DsetDefaultCamera sessionstr defaultcam;
        V3DenableNavigate sessionstr 1;
      );
       
      delEdCtrlTreeItem ctrlSceneTree treeitem;
      
      XMLdelMark xmlEditSceneFile markstr;
      
      // remove from resources and mesh list and tree
      delGraphItem val;
      
      if path == nil then
        nil
      else if (isPathInGroup groupmark "path" path) then nil else
      let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
      let XMLgetMarkByValueAndParamValueFromMarkSons resourcesmark "resource" "path" (strlowercase path) -> resmark in
      (
        XMLdelMark xmlEditSceneFile resmark;
        delEdCtrlList ctrlResourcesList (strlowercase path);
        delEdCtrlList ctrlMeshList (strlowercase path);
      );
      
      let winLightSetup -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winLightSetup = nil;
      );
      
      let winCameraSetup -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winCameraSetup = nil;
      );
      
      physicsDestroyNodeSetting obj;
      
      let winMeshMaterialSetup -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winMeshMaterialSetup = nil;
      );       
      
      let winSkySetup -> [skname swinstr] in
      if (strcmp val skname) then nil else
      (
        dsEdWindow swinstr;
        set winSkySetup = nil;
      );
      
      let winParticleSetup -> [lobj swinstr _ _] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winParticleSetup = nil;
      );
      
      let winCubeMapSetup -> [lobj swinstr _ _] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winCubeMapSetup = nil;
      );
      
      let winReflectionMapSetup -> [lobj swinstr _ _] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winReflectionMapSetup = nil;
      );
      
      let winCompositorSetup -> [name swinstr] in
      if (strcmp val name) then nil else
      (
        dsEdWindow swinstr;
        set winCompositorSetup = nil;
      );
      
      let winNodeSetup -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winNodeSetup = nil;
      );
      
      let winEntitySetup -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winEntitySetup = nil;
      );
      
      let winEntityInfo -> [lobj swinstr] in
      if obj != lobj then nil else
      (
        dsEdWindow swinstr;
        set winEntityInfo = nil;
      );
      
      V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 0;
      V3DshowObjectHelper viewstr sessionstr obj nil 0;
      SO3ObjectDestroy obj;
      
      if type != iTypeGroup then nil else
        SO3GroupDelete (V3DgetSession sessionstr) val;
        
      resetObjHistory;
    );
    V3DviewSetFocus viewstr;
  );
  0;;


fun cbTreeMenuObjectRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the selected object and all his sons ?" 1 @cbDlgObjectRemove p;
  0;;


fun cbDlgAnimRemove(dlg, p, rep)=
  let p -> [viewstr item val type markstr] in
  (
    if !rep then nil else
    let V3DgetDefaultSession viewstr -> sessionstr in
    let V3DgetAnimationByName sessionstr val -> animstr in
    (
      delEdCtrlTreeItem ctrlSceneTree item;
      
      XMLdelMark xmlEditSceneFile markstr;
      
      // remove from resources and mesh list and tree
      delGraphItem val;
      
      let winAnimSetup -> [lanimstr swinstr _ _ trm] in
      if animstr != lanimstr then nil else
      (
        if trm == nil then nil else
          _deltimer trm;
        dsEdWindow swinstr;
        set winAnimSetup = nil;
      );
      
      V3DdelAnimation sessionstr animstr;
    );
    
    V3DviewSetFocus viewstr;
  );
  0;;


fun cbTreeMenuAnimRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the selected animation ?" 1 @cbDlgAnimRemove p;
  0;;


/**  cbDestroySkySetupWin [EdWindow] I
  *  callback on destroy sky setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroySkySetupWin(winstr)=
  set winSkySetup = nil;
  0;;
  

fun cbSkySetupMaterial(ctrl, pos, elem, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup elem -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> skyboxqx in
  let atof XMLgetParam skyboxrotstr "qy" -> skyboxqy in
  let atof XMLgetParam skyboxrotstr "qz" -> skyboxqz in
  let atof XMLgetParam skyboxrotstr "qw" -> skyboxqw in
  (
    XMLsetParam markstr "material" elem;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [skyboxqx skyboxqy skyboxqz skyboxqw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [skyboxqx skyboxqy skyboxqz skyboxqw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupTiling(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "tiling" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) value xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale value (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupSegmentX(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "xSegments" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling (ftoi value) ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) (ftoi value) ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupSegmentY(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "ySegments" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments (ftoi value) (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments (ftoi value) resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupDistance(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "distance" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat value [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat value [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupCurvature(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "curvature" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] value tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupScale(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "scale" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] value tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupBow(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "bow" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling value xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupPlaneX(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "planeX" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [value planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupPlaneY(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "planeY" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex value planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupPlaneZ(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "planeZ" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey value] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupPlaneD(ctrl, value, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetParam markstr "material" -> matname in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "planeD" XMLgetShortFloatToString value;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat value [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbSkySetupOrientation(ctrl, value, p)=
  let p -> [[viewstr item val type markstr] [ctrlx ctrly ctrlz]] in
  let getEdCtrlFloatValue ctrlx -> xval in
  let getEdCtrlFloatValue ctrly -> yval in
  let getEdCtrlFloatValue ctrlz -> zval in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let XMLgetParam markstr "material" -> matname in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let SO3MathsQuatFromDegreeAngle [xval yval zval] -> [qx qy qz qw] in
  let SO3MathsQuatGetDegreePitch [qx qy qz qw] 1 -> xov in
  let SO3MathsQuatGetDegreeYaw [qx qy qz qw] 1 -> yov in
  let SO3MathsQuatGetDegreeRoll [qx qy qz qw] 1 -> zov in
  (
    setEdCtrlFloatValue ctrlx xov;
    setEdCtrlFloatValue ctrly yov;
    setEdCtrlFloatValue ctrlz zov;
    
    XMLsetParam skyboxrotstr "qx" XMLgetShortFloatToString qx;
    XMLsetParam skyboxrotstr "qy" XMLgetShortFloatToString qy;
    XMLsetParam skyboxrotstr "qz" XMLgetShortFloatToString qz;
    XMLsetParam skyboxrotstr "qw" XMLgetShortFloatToString qw;
    
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable skyboxdrawfirst;
      0;
    );
  );
  0;;


/**  cbSkySetupDrawFirst [EdControl F [V3Dview S I XMLmark]] I
  *  callback on sky drawfirst change
  *  
  *  private
  *  
  *  return 0
  **/
fun cbSkySetupDrawFirst(ctrl, state, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let XMLgetParam markstr "material" -> matname in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "drawFirst" XMLgetBoolString state;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup skyboxenable state;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup skyboxenable state;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup skyboxenable state;
      0;
    );
  );
  0;;


/**  cbSkySetupEnable [EdControl F [V3Dview S I XMLmark]] I
  *  callback on sky drawfirst change
  *  
  *  private
  *  
  *  return 0
  **/
fun cbSkySetupEnable(ctrl, state, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
  let getGroupName currentProject groupmark -> resgroup in
  let XMLgetParam markstr "material" -> matname in
  let atof (XMLgetParam markstr "distance") -> distance in
  let XMLgetBoolParam markstr "enable" -> skyboxenable in
  let XMLgetBoolParam markstr "drawFirst" -> skyboxdrawfirst in
  let atof (XMLgetParam markstr "tiling") -> tiling in
  let atoi (XMLgetParam markstr "xSegments") -> xsegments in
  let atoi (XMLgetParam markstr "ySegments") -> ysegments in
  let atof (XMLgetParam markstr "curvature") -> curvature in
  let atof (XMLgetParam markstr "planeX") -> planex in
  let atof (XMLgetParam markstr "planeY") -> planey in
  let atof (XMLgetParam markstr "planeZ") -> planez in
  let atof (XMLgetParam markstr "planeD") -> planed in
  let atof (XMLgetParam markstr "bow") -> bow in
  
  let atof (XMLgetParam markstr "scale") -> scale in
  
  let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> skymat in
  let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
  let atof XMLgetParam skyboxrotstr "qx" -> qx in
  let atof XMLgetParam skyboxrotstr "qy" -> qy in
  let atof XMLgetParam skyboxrotstr "qz" -> qz in
  let atof XMLgetParam skyboxrotstr "qw" -> qw in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    if type == iTypeSkyBox then
    (
      SO3SceneSetSkyBox (V3DgetSession sessionstr) skymat distance [qx qy qz qw] resgroup state skyboxdrawfirst;
      0;
    )
    else if type == iTypeSkyDome then
    (
      SO3SceneSetSkyDome (V3DgetSession sessionstr) skymat distance [qx qy qz qw] (if curvature != nil then curvature else 0.0) tiling xsegments ysegments (-1) resgroup state skyboxdrawfirst;
      0;
    )
    else
    (
      SO3SceneSetSkyPlane (V3DgetSession sessionstr) skymat planed [planex planey planez] scale tiling (if bow != nil then bow else 0.0) xsegments ysegments resgroup state skyboxdrawfirst;
      0;
    );
  );
  0;;


fun cbTreeMenuSkyEditParameters(mnuitem, p)=
  let p -> [viewstr item val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    if winSkySetup == nil then nil else
    (
      let winSkySetup -> [sname winstr] in
        dsEdWindow winstr;
      set winSkySetup = nil;
    );
    
    let [320 312] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let XMLgetBoolParam markstr "enable" -> state in
    let XMLgetBoolParam markstr "drawFirst" -> drawfirst in
    let XMLgetParam markstr "material" -> matname in
    let atof (XMLgetParam markstr "distance") -> distance in
    let atof (XMLgetParam markstr "tiling") -> tiling in
    let atof (XMLgetParam markstr "xSegments") -> xsegments in
    let atof (XMLgetParam markstr "ySegments") -> ysegments in
    let atof (XMLgetParam markstr "curvature") -> curvature in
    
    let atof (XMLgetParam markstr "planeX") -> planex in
    let atof (XMLgetParam markstr "planeY") -> planey in
    let atof (XMLgetParam markstr "planeZ") -> planez in
    let atof (XMLgetParam markstr "planeD") -> planed in
    
    let atof (XMLgetParam markstr "scale") -> scale in
    let atof (XMLgetParam markstr "bow") -> bow in
    
    let XMLgetMarkByValueFromMarkSons markstr "rotation" -> skyboxrotstr in
    let atof XMLgetParam skyboxrotstr "qx" -> skyboxqx in
    let atof XMLgetParam skyboxrotstr "qy" -> skyboxqy in
    let atof XMLgetParam skyboxrotstr "qz" -> skyboxqz in
    let atof XMLgetParam skyboxrotstr "qw" -> skyboxqw in
    let SO3MathsQuatGetDegreePitch [skyboxqx skyboxqy skyboxqz skyboxqw] 1 -> xov in
    let SO3MathsQuatGetDegreeYaw [skyboxqx skyboxqy skyboxqz skyboxqw] 1 -> yov in
    let SO3MathsQuatGetDegreeRoll [skyboxqx skyboxqy skyboxqz skyboxqw] 1 -> zov in

    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let getGroupName currentProject groupmark -> resgroup in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Sky setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 190 20 "Material" nil -> labelint in
    let crEdCtrlSelect winstr 210 10 100 120 EDWIN_RESIZE_MW -> ctrlmat in
    let crEdCtrlLabel winstr 10 37 190 20 "Distance" nil -> labeldist in
    let crEdCtrlFloat winstr 210 35 100 20 distance 0.0 100000000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrldistance in
    
    let crEdCtrlLabel winstr 10 62 190 20 "Tiling" nil -> labeltiling in
    let crEdCtrlFloat winstr 210 60 100 20 tiling 0.0 10000.0 1.0 0 nil EDWIN_RESIZE_MW -> ctrltiling in
    let crEdCtrlLabel winstr 10 87 160 20 "Segments" nil -> labelseg in
    let crEdCtrlFloat winstr 185 85 60 20 xsegments 0.0 1024.0 1.0 0 nil EDWIN_RESIZE_MW -> ctrlsegx in
    let crEdCtrlFloat winstr 250 85 60 20 ysegments 0.0 1024.0 1.0 0 nil EDWIN_RESIZE_MW -> ctrlsegy in
    let crEdCtrlLabel winstr 10 112 100 20 "Curvature" nil -> labelcurv in
    let crEdCtrlFloat winstr 210 110 100 20 curvature 0.0 100.0 0.1 3 nil EDWIN_RESIZE_MW -> ctrlcurv in
    
    let crEdCtrlLabel winstr 10 137 100 20 "Orientation" nil -> labelor in
    let crEdCtrlFloat winstr 120 135 60 20 xov (-.720.0) 720.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlorx in
    let crEdCtrlFloat winstr 185 135 60 20 yov (-.720.0) 720.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlory in
    let crEdCtrlFloat winstr 250 135 60 20 zov (-.720.0) 720.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlorz in
    
    let crEdCtrlLabel winstr 10 162 100 20 "plane" nil -> labelplanex in
    let crEdCtrlFloat winstr 120 160 60 20 planex (-.100000000.0) 100000000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlplanex in    
    let crEdCtrlFloat winstr 185 160 60 20 planey (-.100000000.0) 100000000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlplaney in    
    let crEdCtrlFloat winstr 250 160 60 20 planez (-.100000000.0) 100000000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlplanez in    
    let crEdCtrlLabel winstr 10 187 190 20 "planeD" nil -> labelplanex in
    let crEdCtrlFloat winstr 210 185 100 20 planed (-.100000000.0) 100000000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlplaned in    
    
    let crEdCtrlLabel winstr 10 212 190 20 "Bow" nil -> labelcurv in
    let crEdCtrlFloat winstr 210 210 100 20 bow 0.0 20.0 0.1 3 nil EDWIN_RESIZE_MW -> ctrlbow in
    
    let crEdCtrlLabel winstr 10 237 190 20 "Scale" nil -> labelplanex in
    let crEdCtrlFloat winstr 210 235 100 20 scale 0.0 100000.0 1.0 3 nil EDWIN_RESIZE_MW -> ctrlscale in  
    
    let crEdCtrlCheck winstr 10 262 190 20 "Draw first" EDWIN_RESIZE_MW -> ctrldrawfirst in
    let crEdCtrlCheck winstr 10 287 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    (
      set winSkySetup = [val winstr];
      setEdCtrlSelectEnable ctrlmat 1;
      
      if type == iTypeSkyBox then
      (
        setEdCtrlFloatEnable ctrltiling 0;
        setEdCtrlFloatEnable ctrlsegx 0;
        setEdCtrlFloatEnable ctrlsegy 0;
        
        setEdCtrlFloatEnable ctrlplanex 0;
        setEdCtrlFloatEnable ctrlplaney 0;
        setEdCtrlFloatEnable ctrlplanez 0;
        setEdCtrlFloatEnable ctrlplaned 0;
        
        setEdCtrlFloatEnable ctrlcurv 0;
        setEdCtrlFloatEnable ctrlbow 0;
        setEdCtrlFloatEnable ctrlscale 0;
      )
      else if type == iTypeSkyDome then
      (
        setEdCtrlFloatEnable ctrlplanex 0;
        setEdCtrlFloatEnable ctrlplaney 0;
        setEdCtrlFloatEnable ctrlplanez 0;
        setEdCtrlFloatEnable ctrlplaned 0;
        
        setEdCtrlFloatEnable ctrlbow 0;
        setEdCtrlFloatEnable ctrlscale 0;
      )
      else
      (
        setEdCtrlFloatEnable ctrlcurv 0;
        setEdCtrlFloatEnable ctrldistance 0;
        setEdCtrlFloatEnable ctrlorx 0;
        setEdCtrlFloatEnable ctrlory 0;
        setEdCtrlFloatEnable ctrlorz 0;
      );
      
      
      let SO3SceneParseMaterialsFromGroup (V3DgetSession sessionstr) resgroup -> l in
      let sizelist l -> size in
      let nil -> lmats in
      let 0 -> i in
      (
        while i < size do
        (
          let nth_list l i -> mat in
          let SO3MaterialGetName mat -> name in
            set lmats = name::lmats;
          
          set i = i + 1;
        );
        fillEdCtrlSelect ctrlmat quicksort lmats @suppDoublon;
        
        selectEdCtrlSelect ctrlmat matname;
        
        if (matname != nil) && (strcmp matname "") then nil else
          cbSkySetupMaterial ctrlmat 0 hd lmats p;
      );
      
      setEdCtrlCheckState ctrldrawfirst drawfirst;
      setEdCtrlCheckState ctrlenable state;
      
      setEdCtrlSelectCb ctrlmat mkfun4 @cbSkySetupMaterial p;
      setEdCtrlFloatCbChange ctrldistance mkfun3 @cbSkySetupDistance p;
      setEdCtrlFloatCbChange ctrltiling mkfun3 @cbSkySetupTiling p;
      setEdCtrlFloatCbChange ctrlsegx mkfun3 @cbSkySetupSegmentX p;
      setEdCtrlFloatCbChange ctrlsegy mkfun3 @cbSkySetupSegmentY p;
      setEdCtrlFloatCbChange ctrlcurv mkfun3 @cbSkySetupCurvature p;
      setEdCtrlFloatCbChange ctrlscale mkfun3 @cbSkySetupScale p;
      setEdCtrlFloatCbChange ctrlplanex mkfun3 @cbSkySetupPlaneX p;
      setEdCtrlFloatCbChange ctrlplaney mkfun3 @cbSkySetupPlaneY p;
      setEdCtrlFloatCbChange ctrlplanez mkfun3 @cbSkySetupPlaneZ p;
      setEdCtrlFloatCbChange ctrlplaned mkfun3 @cbSkySetupPlaneD p;
      setEdCtrlFloatCbChange ctrlbow mkfun3 @cbSkySetupBow p;
      
      setEdCtrlFloatCbValidate ctrlorx mkfun3 @cbSkySetupOrientation [p [ctrlorx ctrlory ctrlorz]];
      setEdCtrlFloatCbValidate ctrlory mkfun3 @cbSkySetupOrientation [p [ctrlorx ctrlory ctrlorz]];
      setEdCtrlFloatCbValidate ctrlorz mkfun3 @cbSkySetupOrientation [p [ctrlorx ctrlory ctrlorz]];
      
      setEdCtrlCheckCbState ctrldrawfirst mkfun3 @cbSkySetupDrawFirst p;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbSkySetupEnable p;
      
      setEdwindowCbDestroy winstr @cbDestroySkySetupWin;
      0;
    );
  );
  0;;


fun cbDlgSkyBoxRemove(dlg, p, rep)=
  if !rep then nil else
  let p -> [viewstr treeitem val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    delEdCtrlTreeItem ctrlSceneTree treeitem;
    XMLdelMark xmlEditSceneFile markstr;
    SO3SceneSetSkyBoxEnable (V3DgetSession sessionstr) 0;
    delGraphItem val;
    
    let winSkySetup -> [skname swinstr] in
    if strcmp val skname then nil else
    (
      dsEdWindow swinstr;
      set winSkySetup = nil;
    );
  );
  0;;


fun cbTreeMenuSkyBoxRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the sky box ?" 1 @cbDlgSkyBoxRemove p;
  0;;


fun cbDlgSkyDomeRemove(dlg, p, rep)=
  if !rep then nil else
  let p -> [viewstr treeitem val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    delEdCtrlTreeItem ctrlSceneTree treeitem;
    XMLdelMark xmlEditSceneFile markstr;
    SO3SceneSetSkyDomeEnable (V3DgetSession sessionstr) 0;
    delGraphItem val;
    
    let winSkySetup -> [skname swinstr] in
    if strcmp val skname then nil else
    (
      dsEdWindow swinstr;
      set winSkySetup = nil;
    );
  );
  0;;


fun cbTreeMenuSkyDomeRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the sky dome ?" 1 @cbDlgSkyDomeRemove p;
  0;;


fun cbDlgSkyPlanRemove(dlg, p, rep)=
  if !rep then nil else
  let p -> [viewstr treeitem val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  (
    delEdCtrlTreeItem ctrlSceneTree treeitem;
    XMLdelMark xmlEditSceneFile markstr;
    SO3SceneSetSkyPlaneEnable (V3DgetSession sessionstr) 0;
    delGraphItem val;
    
    let winSkySetup -> [skname swinstr] in
    if strcmp val skname then nil else
    (
      dsEdWindow swinstr;
      set winSkySetup = nil;
    );
  );
  0;;


fun cbTreeMenuSkyPlanRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the sky plan ?" 1 @cbDlgSkyPlanRemove p;
  0;;


fun cbDlgCompositorRemove(dlg, p, rep)=
  if !rep then nil else
  let p -> [viewstr treeitem val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let (V3DgetDefaultViewport viewstr) -> viewportstr in
  let XMLgetParam markstr "name" -> compname in
  (
    delEdCtrlTreeItem ctrlSceneTree treeitem;
    XMLdelMark xmlEditSceneFile markstr;
    SO3ViewportRemoveCompositor viewportstr.V3D_viewport compname;
    delGraphItem val;
    
    let winCompositorSetup -> [name swinstr] in
    if strcmp val name then nil else
    (
      dsEdWindow swinstr;
      set winCompositorSetup = nil;
    );
  );
  0;;


fun cbTreeMenuCompositorRemove(mnuitem, p)=
  _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove the compositor ?" 1 @cbDlgCompositorRemove p;
  0;;


fun cbTreeMenuObjectEnable(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let XMLgetBoolParam markstr "enable" -> state in
  (
    setGraphItemInitState val !state;
    XMLsetParam markstr "enable" XMLgetBoolString !state;
  );
  0;;


/**  cbDestroyParticleSetupWin [EdWindow] I
  *  callback on destroy particle setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyParticleSetupWin(winstr, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> partsystem in
  (
    SO3ParticleSystemSetEnable partsystem 0;
    SO3ParticleSystemClear partsystem;
  );
  
  set winParticleSetup = nil;
  0;;


fun cbParticleSetupEnable(ctrl, state, p)=
  let p -> [viewstr val type markstr] in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    setGraphItemInitState val state;
  );
  0;;


fun cbParticleSetupSpeed(ctrl, value, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> partsystem in
  (
    XMLsetParam markstr "speed" XMLgetShortFloatToString value;
    SO3ParticleSystemSetSpeedFactor partsystem value;
  );
  0;;


fun cbParticleSetupPlayPause(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> partsystem in
  (
    if state then
    (
      if (SO3ParticleSystemGetEnable partsystem) then nil else
        SO3ParticleSystemSetEnable partsystem 1;
      SO3ParticleSystemSetPause partsystem 0;
    )
    else
    (
      SO3ParticleSystemSetPause partsystem 1;
    );
  );
  0;;


fun cbParticleSetupStop(tbstr, check, btn, mask, p)=
  let p -> [[viewstr val type markstr] chkplaypause] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> partsystem in
  (
     SO3ParticleSystemSetEnable partsystem 0;
     SO3ParticleSystemClear partsystem;
     setEdToolBarCheckState tbstr chkplaypause 0;
  );
  0;;


fun cbTreeMenuParticleEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> partsystem in
  let winParticleSetup -> [wobj owinstr _ _] in
  if wobj == partsystem then nil else
  (
    if winParticleSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winParticleSetup = nil;
    );
    
    let [230 113] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
    let XMLgetBoolParam markstr "enable" -> partenable in
    let atof (XMLgetParam markstr "speed") -> partspeed in
    let atof (XMLgetParam markstr "renderingDistance") -> dist in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Particle system setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 120 20 "Speed" nil -> labelspeed in
    let crEdCtrlFloat winstr 130 10 90 20 partspeed 0.0 100000.0 0.1 6 nil EDWIN_RESIZE_MW -> ctrlspeed in
    
    let crEdCtrlLabel winstr 10 37 120 20 "Distance visibility" nil -> labelvisibility in
    let crEdCtrlFloat winstr 130 35 90 20 dist 0.0 1000000.0 0.1 6 nil EDWIN_RESIZE_MW -> ctrldist in
    let crEdCtrlCheck winstr 10 62 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    
    let crEdWindowToolBar winstr 0 (ih-28) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_stop.png" -> astop in
    let crEdToolBarButton tbstr astop ETB_ALIGN_LEFT "Stop" nil -> chkstop in
    (
      setEdToolBarVisible tbstr 1;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbParticleSetupPlayPause p;
      setEdToolBarButtonCbClick tbstr chkstop mkfun5 @cbParticleSetupStop [p chkplaypause];
    
      set winParticleSetup = [partsystem winstr tbstr chkplaypause];
      setEdCtrlFloatCbChange ctrldist mkfun3 @cbObjectSetupRenderVisibility p;
      setEdCtrlCheckState ctrlenable partenable;
      setEdCtrlFloatCbChange ctrlspeed mkfun3 @cbParticleSetupSpeed p;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbParticleSetupEnable p;
      
      setEdwindowCbDestroy winstr mkfun2 @cbDestroyParticleSetupWin p;
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


/**  cbDestroyCompositorSetupWin [EdWindow] I
  *  callback on destroy compositor setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyCompositorSetupWin(winstr, p)=
  let p -> [viewstr val type markstr play] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let (V3DgetDefaultViewport viewstr) -> viewportstr in
    SO3ViewportRemoveCompositor viewportstr.V3D_viewport val;
  
  set winCompositorSetup = nil;
  0;;


fun cbCompositorSetupEnable(ctrl, state, p)=
  let p -> [viewstr val type markstr play] in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    setGraphItemInitState val state;
  );
  0;;


fun cbCompositorSetupPlayStop(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr val type markstr play] in
  let XMLgetParam markstr "scheme" -> compschemename in
  let (V3DgetDefaultViewport viewstr) -> viewportstr in
  (
    if state then
    (
      SO3ViewportAddCompositor viewportstr.V3D_viewport val compschemename;
    )
    else
    (
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport val;
    );
    mutate p <- [_ _ _ _ state];
  );
  0;;


fun cbCompositorSetupScheme(ctrl, pos, schemename, p)=
  let p -> [viewstr val type markstr play] in
  let if pos == 0 then nil else schemename -> schemename in
  let XMLgetParam markstr "name" -> compositorname in
  (
    XMLsetParam markstr "scheme" schemename;
    
    if !play then nil else
    let (V3DgetDefaultViewport viewstr) -> viewportstr in
    (
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport compositorname;
      SO3ViewportAddCompositor viewportstr.V3D_viewport compositorname schemename;
    );
  );
  0;;


fun cbTreeMenuCompositorEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let winCompositorSetup -> [name owinstr] in
  if !strcmp name val then nil else
  (
    if winCompositorSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winCompositorSetup = nil;
    );
    
    let [300 118] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let XMLgetBoolParam markstr "enable" -> compenable in
    let XMLgetParam markstr "scheme" -> schemename in
    let lcat (V3DgetDefaultCompositorsList sessionstr) (SO3SceneParseCompositorsFromGroup (V3DgetSession sessionstr) "Scene") -> lcompname in
    let let nil -> nl in
      (
        let sizelist lcompname -> size in
        let 0 -> i in
        while i < size do
        (
          let nth_list lcompname i -> compname in
          set nl =compname::nl;
          
          set i = i + 1;
        );
        quicksort nl @suppDoublon
      )
    -> lcompname in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Compositor setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 140 20 "Select a compositor" nil -> labelcomp in
    let crEdCtrlSelect winstr 160 10 (iw - 170) 120 CB_AHSCROLL -> ctrlselect in
    let crEdCtrlLabel winstr 10 37 140 20 "Scheme mask" nil -> labelscheme in
    let crEdCtrlSelect winstr 160 35 (iw - 170) 120 EDWIN_RESIZE_MW -> ctrlscheme in
    let crEdCtrlCheck winstr 10 62 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    
    let crEdWindowToolBar winstr 0 (ih-28) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    let [viewstr val type markstr 0] -> p in
    (
      fillEdCtrlSelect ctrlscheme "all"::(getAllMaterialScheme viewstr);
      if (schemename == nil) || (!strcmp "" schemename) then
        selectEdCtrlSelectByPos ctrlscheme 0
      else
        selectEdCtrlSelect ctrlscheme schemename;
      
      setEdCtrlSelectCb ctrlscheme mkfun4 @cbCompositorSetupScheme p;
      
      setEdToolBarVisible tbstr 1;
      fillEdCtrlSelect ctrlselect lcompname;
      selectEdCtrlSelect ctrlselect val;
      setEdCtrlSelectEnable ctrlselect 0;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbCompositorSetupPlayStop p;
      
      set winCompositorSetup = [val winstr];
      setEdCtrlCheckState ctrlenable compenable;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbCompositorSetupEnable p;
            
      setEdwindowCbDestroy winstr mkfun2 @cbDestroyCompositorSetupWin p;
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


fun cbTreeMenuImport(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
    importSceneWizard viewstr markstr val item nil;
  //  _DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "Scene format\0*.scene;*.xos\0Ogre scene\0*.scene\0OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgImportScene [viewstr markstr val item];
  0;;


fun cbTreeMenuAddResources(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
    _DLGrflopenMulti _DLGOpenFileMulti _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "All\0*.*\0\0" @cbDlgAddResources [viewstr markstr val item];
  0;;


fun cbTreeMenuAddMesh(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
    importMeshWizard viewstr markstr val type item nil;
    //_DLGrflopen _DLGOpenFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory nil "Ogre mesh\0*.mesh\0All\0*.*\0\0" @cbDlgAddMesh [viewstr markstr val type item];
  0;;


fun cbTreeMenuClone(mnuitem, p)=
  let p -> [viewstr val type markstr groupmark item] in
    cloneNode viewstr val type markstr groupmark item;
  0;;


fun cbTreeMenuAddSkyBox(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let XMLgetMarkByValueFromMarkSons markstr "environment" -> envmark in
  let XMLaddMark xmlEditSceneFile "skyBox" envmark ["enable" (XMLgetBoolString 0)]::["material" ""]::["distance" "1000"]::["drawFirst" (XMLgetBoolString 1)]::nil nil -> skymark in
  let addGraphItem "SkyBox" "SkyBox" iTypeSkyBox nil skymark nil markstr sTreeBitmapSky item 1 0 -> treenode in
  (
    XMLaddMark xmlEditSceneFile "rotation" skymark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
    selEdCtrlTreeItem ctrlSceneTree treenode;
    cbTreeMenuSkyEditParameters treenode [viewstr item "SkyBox" iTypeSkyBox skymark];
  );
  0;;


fun cbTreeMenuAddSkyDome(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let XMLgetMarkByValueFromMarkSons markstr "environment" -> envmark in
  let XMLaddMark xmlEditSceneFile "skyDome" envmark ["enable" (XMLgetBoolString 0)]::["material" ""]::["tiling" "4"]::["distance" "1000"]::["drawFirst" (XMLgetBoolString 1)]::["curvature" "1"]::["xSegments" "32"]::["ySegments" "16"]::nil nil -> skymark in
  let addGraphItem "SkyDome" "SkyDome" iTypeSkyDome nil skymark nil markstr sTreeBitmapSky item 1 0 -> treenode in
  (
    XMLaddMark xmlEditSceneFile "rotation" skymark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
    selEdCtrlTreeItem ctrlSceneTree treenode;
    cbTreeMenuSkyEditParameters treenode [viewstr item "skyDome" iTypeSkyDome skymark];
  );
  0;;


fun cbTreeMenuAddSkyPlane(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let XMLgetMarkByValueFromMarkSons markstr "environment" -> envmark in
  let XMLaddMark xmlEditSceneFile "skyPlane" envmark ["enable" (XMLgetBoolString 0)]::["material" ""]::["planeX" "0"]::["planeY" "1"]::["planeZ" "0"]::["planeD" "200"]::["scale" "120"]::["tiling" "2"]::["drawFirst" (XMLgetBoolString 1)]::["bow" "0"]::["xSegments" "4"]::["ySegments" "4"]::nil nil -> skymark in
  let addGraphItem "SkyPlane" "SkyPlane" iTypeSkyPlane nil skymark nil markstr sTreeBitmapSky item 1 0 -> treenode in
  (
    selEdCtrlTreeItem ctrlSceneTree treenode;
    cbTreeMenuSkyEditParameters treenode [viewstr item "SkyPlane" iTypeSkyPlane skymark];
  );
  0;;


fun cbAddCompositor(ctrlstr, p2)=
  let p2 -> [winstr ctrlselect chkplaypause p lastcompo] in
  let p -> [viewstr val type markstr item] in
  let getSelectedEdCtrlSelect ctrlselect -> compname in
  let XMLgetMarkByValueFromMarkSons markstr "environment" -> envmark in
  let XMLaddMark xmlEditSceneFile "compositor" envmark ["name" compname]::["enable" XMLgetBoolString 0]::nil nil -> compmark in
  let addGraphItem strcatn "Compositor \""::compname::"\""::nil compname iTypeCompositor nil compmark nil markstr sTreeBitmapCompositor item 0 0 -> treenode in
  (
    if (lastcompo == nil) then nil else
    let (V3DgetDefaultViewport viewstr) -> viewportstr in
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport lastcompo;
    
    selEdCtrlTreeItem ctrlSceneTree treenode;
    dsEdWindow winstr;
  );
  0;;


fun cbBtnDestroyAddCompositorWin(winstr, p2)=
  let p2 -> [winstr ctrlselect chkplaypause p lastcompo] in
  let p -> [viewstr _ _ _ _] in
  (
    if (lastcompo == nil) then nil else
    let (V3DgetDefaultViewport viewstr) -> viewportstr in
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport lastcompo;
  );
  0;;


fun cbBtnCancelAddCompositor(ctrlbtn, p2)=
  let p2 -> [winstr ctrlselect chkplaypause p lastcompo] in
  let p -> [viewstr _ _ _ _] in
  (
    if (lastcompo == nil) then nil else
    let (V3DgetDefaultViewport viewstr) -> viewportstr in
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport lastcompo;
    
    dsEdWindow winstr;
  );
  0;;


fun cbCompositorAddSelect(ctrl, pos, compname, p2)=
  let p2 -> [winstr ctrlselect chkplaypause p lastcompo] in
  let p -> [viewstr _ _ _ _] in
  (
    if (lastcompo == nil) then nil else
    let (V3DgetDefaultViewport viewstr) -> viewportstr in
    (
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport lastcompo;
      SO3ViewportAddCompositor viewportstr.V3D_viewport compname nil;
      mutate p2 <- [_ _ _ _ compname];
    );
  );
  0;;


fun cbCompositorAddPlayStop(tbstr, check, btn, mask, state, p2)=
  let p2 -> [winstr ctrlselect chkplaypause p lastcompo] in
  let p -> [viewstr _ _ _ _] in
  let (V3DgetDefaultViewport viewstr) -> viewportstr in
  (
    if state then
    let getSelectedEdCtrlSelect ctrlselect -> compname in
    (
      SO3ViewportAddCompositor viewportstr.V3D_viewport compname nil;
      mutate p2 <- [_ _ _ _ compname];
    )
    else
    (
      SO3ViewportRemoveCompositor viewportstr.V3D_viewport lastcompo;
      mutate p2 <- [_ _ _ _ nil];
    );
  );
  0;;


fun cbTreeMenuAddCompositor(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let XMLgetMarkByValueFromMarkSons markstr "environment" -> envmark in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let lcat (V3DgetDefaultCompositorsList sessionstr) (SO3SceneParseCompositorsFromGroup (V3DgetSession sessionstr) "Scene") -> lcompname in
  let XMLgetMarksParamValueByValueAndParamFromMarkSons envmark "compositor" "name" -> lp in
  let let nil -> nl in
      (
        let sizelist lcompname -> size in
        let 0 -> i in
        while i < size do
        (
          let nth_list lcompname i -> compname in
          if (isStringInList lp compname) then nil else
            set nl = compname::nl;
          
          set i = i + 1;
        );
        quicksort nl @suppDoublon;
      )
  -> lcompname in
  if lcompname == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "No compositor resources found in scene" 0;
    0;
  )
  else
  (
    let [330 90] -> [iw ih] in    
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Add compositor") sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 140 20 "Select a compositor" nil -> labelcomp in
    let crEdCtrlSelect winstr 160 10 (iw - 200) 120 CB_AHSCROLL -> ctrlselect in
    let crEdWindowToolBar winstr (160 + (iw - 200) + 6) 9 24 24 0 0 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    let [winstr ctrlselect chkplaypause p nil] -> p2 in
    (
      setEdToolBarVisible tbstr 1;
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbCompositorAddPlayStop p2;
      
      fillEdCtrlSelect ctrlselect lcompname;
      setEdCtrlSelectCb ctrlselect mkfun4 @cbCompositorAddSelect p2;
      setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 @cbAddCompositor p2;
      setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancelAddCompositor p2;
      setEdwindowCbDestroy winstr mkfun2 @cbBtnDestroyAddCompositorWin p2;
      paintEdToolBar tbstr;
    );
    0;
  );
  0;;


fun cbAddParticleSystem(ctrlstr, d, p)=
  let p -> [winstr ctrltext ctrlselect [viewstr val type markstr item groupmark]] in
  let getSelectedEdCtrlSelect ctrlselect -> tplname in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "particle" destmark ["id" id]::["name" name]::["template" tplname]::["renderingDistance" "0"]::["enable" (XMLgetBoolString 0)]::["speed" (XMLgetShortFloatToString 1.0)]::nil nil -> partmark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeParticle nil partmark nil groupmark sTreeBitmapParticle item 0 0 -> treenode in
    let V3DaddParticleSystem sessionstr (strcatn id::"."::name::nil) tplname -> partsystem in
    (
      if father == nil then nil else
        SO3ObjectLink partsystem father;
     
      XMLaddMark xmlEditSceneFile "position" partmark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" partmark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "scale" partmark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
            
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemSetSpeedFactor partsystem 1.0;
      SO3ParticleSystemClear partsystem;
      V3DshowObjectHelper viewstr sessionstr partsystem iTypeParticle 1;
      
      selEdCtrlTreeItem ctrlSceneTree treenode;
      cbTreeMenuParticleEditParameters treenode [viewstr (strcatn id::"."::name::nil) iTypeParticle partmark];
      
      dsEdWindow winstr;
    );
  );
  0;;


fun cbTreeMenuAddParticle(mnuitem, p)=
  let p -> [viewstr val type markstr item groupmark] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneParseParticleSystemsFromGroup (V3DgetSession sessionstr) resgroup -> ltplname in
  if ltplname == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "No particle system template resources found in scene" 0;
    0;
  )
  else
  (
    let [300 115] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Add particle system") sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
    let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "particle" nil EDWIN_RESIZE_MW -> ctrltext in
    let crEdCtrlLabel winstr 10 37 140 20 "Select a particle system template" nil -> labeltpl in
    let crEdCtrlSelect winstr 160 35 (iw - 170) 120 CB_AHSCROLL -> ctrlselect in
    (
      fillEdCtrlSelect ctrlselect quicksort ltplname @suppDoublon;
      setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbAddParticleSystem [winstr ctrltext ctrlselect p];
      setEdctrlTextLineFocus ctrltext;
      setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbAddParticleSystem [winstr ctrltext ctrlselect p] nil;
      setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
    );
    0;
  );
  0;;


fun cbTreeMenuAnimSetLoop(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let V3DgetAnimationByName sessionstr val -> animstr in
  let XMLgetBoolParam markstr "loop" -> animloop in
  (
    XMLsetParam markstr "loop" XMLgetBoolString !animloop;
    V3DsetAnimationLoop animstr !animloop;
  );
  0;;


fun cbBtnNewGroup(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let newOsSceneGroup viewstr xmlEditSceneFile markstr name nil nil father nil nil nil item 0 0 -> [_ _ treenode] in
      selEdCtrlTreeItem ctrlSceneTree treenode;
    
    paintEdCtrlModuleEditor mainInterf.MINT_meGroups;
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddGroup(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New group") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "group" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewGroup [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewGroup [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbDlgSaveOsGroup(dlg, p, wfile)=
  let p -> [val markstr] in
  let _PtoScol (_WtoP wfile) -> file in
  if wfile == nil then nil
  else if file == nil then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Your file have to be in a scol partition." 0;
    0;
  )
  else
  let getFileExt file -> ext in
  let if !strcmpi "xos" ext then file else strcat file ".xos" -> file in
  let XMLcreate file nil -> xmlfilestr in
  (
    XMLcopyMark xmlfilestr markstr nil;
    XMLwrite xmlfilestr file;
    set sLastDirectory = getFileDirectory file;
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Info" strcatn "The group has been successfully saved to "::file::nil 0;
    0;
  );
  0;;


fun cbTreeMenuExportGroup(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  (
    _DLGrflsave _DLGSaveFile _channel mainInterf.MINT_winMain.EDW_win sLastDirectory (strcat val ".xos") "OpenSpace 3D scene\0*.xos\0All\0*.*\0\0" @cbDlgSaveOsGroup [val markstr];
  );
  0;;


fun cbBtnChangeAlias(ctrlbtn, d, p)=
  let p -> [[viewstr val type alias markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  let XMLgetParam markstr "id" -> id in
  let XMLgetParam markstr "name" -> objname in
  let if (name == nil) || (!strcmp "" (strtrim name)) then
        (strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))
      else if type == iTypeCompositor then
        strcatn name::" ("::"Compositor \""::objname::"\")"::nil
      else if type == iTypeSkyBox then
        strcatn name::" (SkyBox)"::nil
      else if type == iTypeSkyDome then
        strcatn name::" (SkyDome)"::nil
      else if type == iTypeSkyPlane then
        strcatn name::" (SkyPlane)"::nil
      else
        strcatn name::" ("::(strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))::")"::nil
  -> nalias in
  (
    addObjHistoryState val markstr nil 5;
    
    setGraphItemAlias val name;
    setEdCtrlTreeLabel ctrlSceneTree item nalias; 
    XMLsetParam markstr "alias" name;
    
    if (type != iTypeGroup) then nil else
    let getGroupByName val -> groupstr in
    let mainInterf.MINT_winPlugins -> [plugswinstr [tbstr tabbarstr minmaxchk1]] in
    let if (name == nil) || (!strcmp "" (strtrim name)) then
          (strcatn lcat objname::nil (if id == nil then nil else " #"::id::nil))
        else
          name
    -> groupname in
    (
      setEdCtrlModuleEditorBoxLabel mainInterf.MINT_meGroups (getEdCtrlModuleEditorBoxByName mainInterf.MINT_meGroups val) groupname;
      renameEdTab tabbarstr groupstr.GRP_tabPlugins groupname;
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuChangeAlias(mnuitem, p)=
  let p -> [viewstr val type alias markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Set alias") sWinDlgIcon -> winstr in
  let if (alias == nil) || (!strcmp alias "") then XMLgetParam markstr "name" else alias -> alias in
  let crEdCtrlLabel winstr 10 12 60 20 "Alias" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 alias nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnChangeAlias [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnChangeAlias [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbBtnNewCamera(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "camera" destmark ["id" id]::["name" name]::["fov" "1.0"]::nil nil -> cammark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeCamera nil cammark nil groupmark sTreeBitmapCamera item 0 0 -> treenode in
    let V3DaddCamera sessionstr (strcatn id::"."::name::nil) -> camera in
    (
      if father == nil then nil else
        SO3ObjectLink camera father;
      
      XMLaddMark xmlEditSceneFile "scale" cammark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "position" cammark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" cammark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "clipping" cammark ["near" "0.01"]::["far" "100000"]::nil nil;
      
      V3DsetCamera camera nil 1.0 0.01 10000.0;
      V3DshowObjectHelper viewstr sessionstr camera iTypeCamera 1;

      selEdCtrlTreeItem ctrlSceneTree treenode;
      cbTreeMenuCameraEditParameters treenode [viewstr (strcatn id::"."::name::nil) iTypeCamera cammark];
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddCamera(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU|WN_DIALOG nil "New camera") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "camera" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewCamera [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewCamera [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbBtnNewLight(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "light" destmark ["id" id]::["name" name]::["type" (getOgreMaxLightByType SO3_POINT_LIGHT)]::["castShadows" (XMLgetBoolString 0)]::["power" "1"]::["enable" XMLgetBoolString 1]::nil nil -> lightmark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeLight nil lightmark nil groupmark sTreeBitmapLight item 1 0 -> treenode in
    let SO3LightCreate (V3DgetSession sessionstr) (strcatn id::"."::name::nil) -> light in
    (
      if father == nil then nil else
        SO3ObjectLink light father;
            
      XMLaddMark xmlEditSceneFile "scale" lightmark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "position" lightmark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" lightmark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      
      XMLaddMark xmlEditSceneFile "colourDiffuse" lightmark ["r" "0.8"]::["g" "0.8"]::["b" "0.8"]::nil nil;
      XMLaddMark xmlEditSceneFile "colourSpecular" lightmark  ["r" "1"]::["g" "1"]::["b" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "lightAttenuation" lightmark ["range" "10"]::nil nil;
      
      //remove default light
      V3DshowObjectHelper viewstr sessionstr (V3DgetDefaultLight sessionstr) nil 0;
      V3DuseDefaultLight sessionstr 0;
      set bLastDefaultLightState = 0;
      
      V3DshowObjectHelper viewstr sessionstr light iTypeLight 1;
      SO3LightSetType light SO3_POINT_LIGHT;
      SO3LightSetPowerScale light 1.0;
      SO3LightSetDiffuseColor light (make_rgba (ftoi (0.8 *. 255.0)) (ftoi (0.8 *. 255.0)) (ftoi (0.8 *. 255.0)) 0);
      SO3LightSetSpecularColor light (make_rgba (ftoi (1.0 *. 255.0)) (ftoi (1.0 *. 255.0)) (ftoi (1.0 *. 255.0)) 0);
      SO3LightSetAttenuationAuto light 10.0;
      SO3ObjectSetCastShadows light 0;
      selEdCtrlTreeItem ctrlSceneTree treenode;
      cbTreeMenuLightEditParameters treenode [viewstr (strcatn id::"."::name::nil) iTypeLight lightmark];
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddLight(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New light") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "light" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewLight [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewLight [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbBtnNewDummy(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "shell" destmark ["id" id]::["name" name]::nil nil -> shellmark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeNode nil shellmark nil groupmark sTreeBitmapNode item 0 0 -> treenode in
    let SO3SceneNodeCreate (V3DgetSession sessionstr) (strcatn id::"."::name::nil) -> shell in
    (
      if father == nil then nil else
        SO3ObjectLink shell father;
      
      XMLaddMark xmlEditSceneFile "scale" shellmark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "position" shellmark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" shellmark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      
      V3DshowObjectHelper viewstr sessionstr shell iTypeNode 1;
      selEdCtrlTreeItem ctrlSceneTree treenode;
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddDummy(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New dummy") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "dummy" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewDummy [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewDummy [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbBtnNewCinematic(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> animname in
  if (animname == nil) || (!strcmp "" (strtrim animname)) then nil else
  (
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let V3DgetDefaultSession viewstr -> sessionstr in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "animation" markstr ["id" id]::["name" animname]::["type" "cinematic"]::["enable" (XMLgetBoolString 0)]::["loop" (XMLgetBoolString 0)]::["speed" (XMLgetShortFloatToString 1.0)]::["weight" (XMLgetShortFloatToString 1.0)]::["skipFrame" (XMLgetBoolString 1)]::nil nil -> newanimmark in
    let addGraphItem strcatn animname::" #"::id::nil (strcatn id::"."::animname::nil) iTypeAnim nil newanimmark nil groupmark sTreeBitmapAnim item 0 0 -> treenode in  
    let V3DaddSequenceAnimation sessionstr (atoi id) animname (strcatn id::"."::animname::nil) 1.0 1.0 0 0 -> animstr in
    (
      V3DanimationSetDefaultSkipFrame animstr 1;
      V3DaddSequenceAnimationTrack animstr;
      XMLaddMark xmlEditSceneFile "track" newanimmark nil nil;
      selEdCtrlTreeItem ctrlSceneTree treenode;
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddCinematic(mnuitem, p)=
  let p -> [viewstr val type markstr item] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New cinematic") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "cinematic" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewCinematic [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewCinematic [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


/**  cbDestroyCubeMapSetupWin [EdWindow] I
  *  callback on destroy cube map setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyCubeMapSetupWin(winstr, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    SO3DynamicCubeMapSetEnable object 0;
  );
  
  set winCubeMapSetup = nil;
  0;;


fun cbCubeMapSetupPlayPause(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    SO3DynamicCubeMapSetEnable object state;
  );
  0;;


fun cbCubeMapSetupEnable(ctrl, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    setGraphItemInitState val state;
  );
  0;;


fun cbCubeMapSetupAutoUpdate(ctrl, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    XMLsetParam markstr "autoUpdate" XMLgetBoolString state;
    SO3DynamicCubeMapSetAutoUpdate object state;
  );
  0;;


fun cbCubeMapSetupMatName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmattech ctrlmatpass ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if elem != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup elem else nil -> material in
  (
    fillMaterialTechSelector viewstr [ctrlmattech ctrlstr ctrlmatpass ctrlmattex] material;
    
    XMLsetParam markstr "material" elem;
    XMLsetParam markstr "technique" "0";
    XMLsetParam markstr "pass" "0";
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicCubeMapSetTargetMaterial object material 0 0 0;
  );
  0;;


fun cbCubeMapSetupMatTechniqueName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmatpass ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if matname != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname else nil -> material in
  (
    fillMaterialPassSelector viewstr [ctrlmatpass ctrlmatname ctrlstr ctrlmattex] material pos;
    
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa pos;
    XMLsetParam markstr "pass" "0";
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicCubeMapSetTargetMaterial object material pos 0 0;
  );
  0;;


fun cbCubeMapSetupMatPassName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmattech ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let getSelectedEdCtrlSelectPos ctrlmattech -> tech in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if matname != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname else nil -> material in
  (
    fillMaterialTextureSelector viewstr ctrlmattex material tech pos;
    
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa tech;
    XMLsetParam markstr "pass" itoa pos;
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicCubeMapSetTargetMaterial object material tech pos 0;
  );
  0;;


fun cbCubeMapSetupMatTexName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmattech ctrlmatpass [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let getSelectedEdCtrlSelectPos ctrlmattech -> technique in
  let getSelectedEdCtrlSelectPos ctrlmatpass -> pass in
  (
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa technique;
    XMLsetParam markstr "pass" itoa pass;
    XMLsetParam markstr "texunit" itoa pos;
    
    let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> material in
      SO3DynamicCubeMapSetTargetMaterial object material technique pass pos;
  );
  0;;


fun cbCubeMapSetupTexSize(ctrlstr, pos, elem, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    XMLsetParam markstr "texsize" elem;

    SO3DynamicCubeMapSetTextureSize object atoi elem;
  );
  0;;


fun cbTreeMenuCubeMapEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGroupName currentProject groupmark -> resgroup in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let winCubeMapSetup -> [wobj owinstr _ _] in
  if wobj == object then nil else
  (
    if winCubeMapSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winCubeMapSetup = nil;
    );
    
    let [380 260] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let 10 -> ypos in
    
    let XMLgetBoolParam markstr "enable" -> state in
    let XMLgetParam markstr "material" -> matname in
    let atoi XMLgetParam markstr "technique" -> mattech in
    let if mattech == nil then 0 else mattech -> mattech in
    let atoi XMLgetParam markstr "pass" -> matpass in
    let if matpass == nil then 0 else matpass -> matpass in
    let atoi XMLgetParam markstr "texunit" -> mattex in
    let if mattex == nil then 0 else mattex -> mattex in
    let atoi XMLgetParam markstr "texsize" -> texsize in
    let if texsize == nil then 256 else texsize -> texsize in
    let atof (XMLgetParam markstr "renderingDistance") -> dist in
    let XMLgetBoolParam markstr "autoUpdate" -> autoupdate in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Dynamic cube map setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 (ypos + 2) 170 20 "Material name" nil -> labelmat in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmatname in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Material technique" nil -> labeltech in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmattech in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Technique pass" nil -> labelpass in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmatpass in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Pass texture" nil -> labelpass in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmattex in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Texture size" nil -> labelsize in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrltexsize in
    
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 35) + 2) 170 20 "Distance visibility" nil -> labelvisibility in
    let crEdCtrlFloat winstr 180 ypos 90 20 dist 0.0 1000000.0 0.1 6 nil EDWIN_RESIZE_MW -> ctrldist in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Auto update" EDWIN_RESIZE_MW -> ctrlautoupdate in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    
    let crEdWindowToolBar winstr 0 (ih-28) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    (
      setEdCtrlFloatEnable ctrldist 0;
      setEdToolBarVisible tbstr 1;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbCubeMapSetupPlayPause p;
      
      setEdCtrlSelectCb ctrlmatname mkfun4 @cbCubeMapSetupMatName [ctrlmattech ctrlmatpass ctrlmattex p];
      setEdCtrlSelectCb ctrlmattech mkfun4 @cbCubeMapSetupMatTechniqueName [ctrlmatname ctrlmatpass ctrlmattex p];
      setEdCtrlSelectCb ctrlmatpass mkfun4 @cbCubeMapSetupMatPassName [ctrlmatname ctrlmattech ctrlmattex p];
      setEdCtrlSelectCb ctrlmattex mkfun4 @cbCubeMapSetupMatTexName [ctrlmatname ctrlmattech ctrlmatpass p];
      
      fillEdCtrlSelect ctrltexsize "32"::"64"::"128"::"256"::"512"::"1024"::"2048"::"4096"::nil;
      selectEdCtrlSelect ctrltexsize itoa texsize;
      
      setEdCtrlSelectCb ctrltexsize mkfun4 @cbCubeMapSetupTexSize p;
      
      fillMaterialSelector viewstr resgroup ctrlmatname ctrlmattech ctrlmatpass ctrlmattex;
      selectEdCtrlSelect ctrlmatname matname;
      
      let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> mat in
      if mat == nil then nil else
      (
        selectEdCtrlSelectByPos ctrlmattech mattech;
        
        fillMaterialPassSelector viewstr [ctrlmatpass ctrlmatname ctrlmattech ctrlmattex] mat mattech;
        selectEdCtrlSelectByPos ctrlmatpass matpass;
        
        fillMaterialTextureSelector viewstr ctrlmattex mat mattech matpass;
        selectEdCtrlSelectByPos ctrlmattex mattex;
      );
      
      set winCubeMapSetup = [object winstr tbstr chkplaypause];
      setEdCtrlFloatCbChange ctrldist mkfun3 @cbObjectSetupRenderVisibility [viewstr val type markstr];
      
      setEdCtrlCheckState ctrlautoupdate autoupdate;
      setEdCtrlCheckCbState ctrlautoupdate mkfun3 @cbCubeMapSetupAutoUpdate p;
      setEdCtrlCheckState ctrlenable state;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbCubeMapSetupEnable p;
      
      
      setEdwindowCbDestroy winstr mkfun2 @cbDestroyCubeMapSetupWin p;
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


fun cbBtnNewCubeMap(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item groupmark] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "cubemap" destmark ["id" id]::["name" name]::nil nil -> shellmark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeCubeMap nil shellmark nil groupmark sTreeBitmapCubeMap item 0 0 -> treenode in
    let SO3DynamicCubeMapCreate (V3DgetSession sessionstr) (strcatn id::"."::name::nil) -> shell in 
    (
      if father == nil then nil else
        SO3ObjectLink shell father;
      
      XMLaddMark xmlEditSceneFile "scale" shellmark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "position" shellmark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" shellmark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      
      V3DshowObjectHelper viewstr sessionstr shell iTypeCubeMap 1;
      selEdCtrlTreeItem ctrlSceneTree treenode;
      cbTreeMenuCubeMapEditParameters treenode [viewstr (strcatn id::"."::name::nil) iTypeCubeMap shellmark groupmark];
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddCubeMap(mnuitem, p)=
  let p -> [viewstr val type markstr item groupmark] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New dynamic cube map") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "cubemap" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewCubeMap [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewCubeMap [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


/**  cbDestroyReflectionMapSetupWin [EdWindow] I
  *  callback on destroy reflection map setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyReflectionMapSetupWin(winstr, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    SO3DynamicReflectionMapSetEnable object 0;
  );
  
  set winReflectionMapSetup = nil;
  0;;


fun cbReflectionMapSetupPlayPause(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    SO3DynamicReflectionMapSetEnable object state;
  );
  0;;


fun cbReflectionMapSetupEnable(ctrl, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  (
    XMLsetParam markstr "enable" XMLgetBoolString state;
    setGraphItemInitState val state;
  );
  0;;


fun cbReflectionMapSetupRevertClipPlane(ctrl, state, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    XMLsetParam markstr "revertClipPlane" XMLgetBoolString state;
    SO3DynamicReflectionMapSetRevertClipPlane object state;
  );
  0;;


fun cbReflectionMapSetupMatName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmattech ctrlmatpass ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if elem != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup elem else nil -> material in
  (
    fillMaterialTechSelector viewstr [ctrlmattech ctrlstr ctrlmatpass ctrlmattex] material;
    
    XMLsetParam markstr "material" elem;
    XMLsetParam markstr "technique" "0";
    XMLsetParam markstr "pass" "0";
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicReflectionMapSetTargetMaterial object material 0 0 0;
  );
  0;;


fun cbReflectionMapSetupMatTechniqueName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmatpass ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if matname != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname else nil -> material in
  (
    fillMaterialPassSelector viewstr [ctrlmatpass ctrlmatname ctrlstr ctrlmattex] material pos;
    
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa pos;
    XMLsetParam markstr "pass" "0";
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicReflectionMapSetTargetMaterial object material pos 0 0;
  );
  0;;


fun cbReflectionMapSetupMatPassName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmattech ctrlmattex [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let getSelectedEdCtrlSelectPos ctrlmattech -> tech in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let if matname != nil then SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname else nil -> material in
  (
    fillMaterialTextureSelector viewstr ctrlmattex material tech pos;
    
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa tech;
    XMLsetParam markstr "pass" itoa pos;
    XMLsetParam markstr "texunit" "0";
    
    SO3DynamicReflectionMapSetTargetMaterial object material tech pos 0;
  );
  0;;


fun cbReflectionMapSetupMatTexName(ctrlstr, pos, elem, p)=
  let p -> [ctrlmatname ctrlmattech ctrlmatpass [viewstr val type markstr groupmark]] in
  let getGroupName currentProject groupmark -> resgroup in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let getSelectedEdCtrlSelect ctrlmatname -> matname in
  let getSelectedEdCtrlSelectPos ctrlmattech -> technique in
  let getSelectedEdCtrlSelectPos ctrlmatpass -> pass in
  (
    XMLsetParam markstr "material" matname;
    XMLsetParam markstr "technique" itoa technique;
    XMLsetParam markstr "pass" itoa pass;
    XMLsetParam markstr "texunit" itoa pos;
    
    let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> material in
      SO3DynamicReflectionMapSetTargetMaterial object material technique pass pos;
  );
  0;;


fun cbReflectionMapSetupTexSize(ctrlstr, pos, elem, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  (
    XMLsetParam markstr "texsize" elem;

    SO3DynamicReflectionMapSetTextureSize object atoi elem;
  );
  0;;


fun cbTreeMenuReflectionMapEditParameters(mnuitem, p)=
  let p -> [viewstr val type markstr groupmark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getGroupName currentProject groupmark -> resgroup in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> object in
  let winReflectionMapSetup -> [wobj owinstr _ _] in
  if wobj == object then nil else
  (
    if winReflectionMapSetup == nil then nil else
    (
      dsEdWindow owinstr;
      set winReflectionMapSetup = nil;
    );
    
    let [380 260] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    let 10 -> ypos in
    
    let XMLgetBoolParam markstr "enable" -> state in
    let XMLgetParam markstr "material" -> matname in
    let atoi XMLgetParam markstr "technique" -> mattech in
    let if mattech == nil then 0 else mattech -> mattech in
    let atoi XMLgetParam markstr "pass" -> matpass in
    let if matpass == nil then 0 else matpass -> matpass in
    let atoi XMLgetParam markstr "texunit" -> mattex in
    let if mattex == nil then 0 else mattex -> mattex in
    let atoi XMLgetParam markstr "texsize" -> texsize in
    let if texsize == nil then 256 else texsize -> texsize in
    let atof (XMLgetParam markstr "renderingDistance") -> dist in
    let XMLgetBoolParam markstr "revertClipPlane" -> revertclip in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat "Dynamic reflection map setting : " val) sWinDlgIcon -> winstr in 
    let crEdCtrlLabel winstr 10 (ypos + 2) 170 20 "Material name" nil -> labelmat in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmatname in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Material technique" nil -> labeltech in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmattech in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Technique pass" nil -> labelpass in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmatpass in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Pass texture" nil -> labelpass in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrlmattex in
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 25) + 2) 170 20 "Texture size" nil -> labelsize in
    let crEdCtrlSelect winstr 180 ypos 180 120 EDWIN_RESIZE_MW -> ctrltexsize in
        
    let crEdCtrlLabel winstr 10 ((set ypos = ypos + 35) + 2) 170 20 "Distance visibility" nil -> labelvisibility in
    let crEdCtrlFloat winstr 180 ypos 90 20 dist 0.0 1000000.0 0.1 6 nil EDWIN_RESIZE_MW -> ctrldist in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) (iw-20) 20 "Revert clip plane (for refract)" EDWIN_RESIZE_MW -> ctrlrevertclip in
    let crEdCtrlCheck winstr 10 (set ypos = ypos + 25) 190 20 "Enable" EDWIN_RESIZE_MW -> ctrlenable in
    
    let crEdWindowToolBar winstr 0 (ih-28) iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playpause.png" -> aplaypause in
    let crEdToolBarCheck tbstr aplaypause ETB_ALIGN_LEFT "Play / Pause" nil -> chkplaypause in
    (
      setEdToolBarVisible tbstr 1;
      
      setEdCtrlFloatEnable ctrldist 0;
      
      setEdToolBarCheckCbClick tbstr chkplaypause mkfun6 @cbReflectionMapSetupPlayPause p;
      
      setEdCtrlSelectCb ctrlmatname mkfun4 @cbReflectionMapSetupMatName [ctrlmattech ctrlmatpass ctrlmattex p];
      setEdCtrlSelectCb ctrlmattech mkfun4 @cbReflectionMapSetupMatTechniqueName [ctrlmatname ctrlmatpass ctrlmattex p];
      setEdCtrlSelectCb ctrlmatpass mkfun4 @cbReflectionMapSetupMatPassName [ctrlmatname ctrlmattech ctrlmattex p];
      setEdCtrlSelectCb ctrlmattex mkfun4 @cbReflectionMapSetupMatTexName [ctrlmatname ctrlmattech ctrlmatpass p];
      
      fillEdCtrlSelect ctrltexsize "32"::"64"::"128"::"256"::"512"::"1024"::"2048"::"4096"::nil;
      selectEdCtrlSelect ctrltexsize itoa texsize;
      
      setEdCtrlSelectCb ctrltexsize mkfun4 @cbReflectionMapSetupTexSize p;
      
      fillMaterialSelector viewstr resgroup ctrlmatname ctrlmattech ctrlmatpass ctrlmattex;
      selectEdCtrlSelect ctrlmatname matname;
      
      let SO3SceneGetMaterial (V3DgetSession sessionstr) resgroup matname -> mat in
      if mat == nil then nil else
      (
        selectEdCtrlSelectByPos ctrlmattech mattech;
        
        fillMaterialPassSelector viewstr [ctrlmatpass ctrlmatname ctrlmattech ctrlmattex] mat mattech;
        selectEdCtrlSelectByPos ctrlmatpass matpass;
        
        fillMaterialTextureSelector viewstr ctrlmattex mat mattech matpass;
        selectEdCtrlSelectByPos ctrlmattex mattex;
      );
      
      set winReflectionMapSetup = [object winstr tbstr chkplaypause];
      setEdCtrlFloatCbChange ctrldist mkfun3 @cbObjectSetupRenderVisibility [viewstr val type markstr];
      
      setEdCtrlCheckState ctrlrevertclip revertclip;
      setEdCtrlCheckCbState ctrlrevertclip mkfun3 @cbReflectionMapSetupRevertClipPlane p;
      setEdCtrlCheckState ctrlenable state;
      setEdCtrlCheckCbState ctrlenable mkfun3 @cbReflectionMapSetupEnable p;
      
      
      setEdwindowCbDestroy winstr mkfun2 @cbDestroyReflectionMapSetupWin p;
      paintEdToolBar tbstr;
      0;
    );
  );
  0;;


fun cbBtnNewReflectionMap(ctrlbtn, d, p)=
  let p -> [[viewstr val type markstr item groupmark] winstr ctrltext] in
  let getEdCtrlTextLineValue ctrltext -> name in
  if (name == nil) || (!strcmp "" (strtrim name)) then nil else
  (
    let if (type == iTypeGroup || type == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> destmark in
    let getGraphByValue val -> [_ _ _ _ _ groupmark _ _] in
    let if (type == iTypeGroup || type == iTypeScene) then markstr else groupmark -> groupmark in

    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) val -> father in
    let itoa (getNewSceneIndex nil) -> id in
    let XMLaddMark xmlEditSceneFile "reflectionmap" destmark ["id" id]::["name" name]::nil nil -> shellmark in
    let addGraphItem (strcatn name::" #"::id::nil) (strcatn id::"."::name::nil) iTypeReflectionMap nil shellmark nil groupmark sTreeBitmapReflectionMap item 0 0 -> treenode in
    let V3DgetDefaultViewport viewstr -> viewport in
    let SO3DynamicReflectionMapCreate (V3DgetSession sessionstr) viewport.V3D_viewport (strcatn id::"."::name::nil) -> shell in 
    (
      if father == nil then nil else
        SO3ObjectLink shell father;
      
      XMLaddMark xmlEditSceneFile "scale" shellmark ["x" "1"]::["y" "1"]::["z" "1"]::nil nil;
      XMLaddMark xmlEditSceneFile "position" shellmark ["x" "0"]::["y" "0"]::["z" "0"]::nil nil;
      XMLaddMark xmlEditSceneFile "rotation" shellmark ["qx" "0"]::["qy" "0"]::["qz" "0"]::["qw" "1"]::nil nil;
      
      V3DshowObjectHelper viewstr sessionstr shell iTypeReflectionMap 1;
      selEdCtrlTreeItem ctrlSceneTree treenode;
      cbTreeMenuReflectionMapEditParameters treenode [viewstr (strcatn id::"."::name::nil) iTypeReflectionMap shellmark groupmark];
    );
    
    dsEdWindow winstr;
  );
  0;;


fun cbTreeMenuAddReflectionMap(mnuitem, p)=
  let p -> [viewstr val type markstr item groupmark] in
  let [230 90] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
  let setEdWindowIcon (crEdModalDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "New dynamic reflection map") sWinDlgIcon -> winstr in
  let crEdCtrlLabel winstr 10 12 60 20 "Name" nil -> label in
  let crEdCtrlTextLine winstr 80 10 (iw - 90) 20 "reflectionmap" nil EDWIN_RESIZE_MW -> ctrltext in
  (
    setEdctrlTextLineFocus ctrltext;
    setEdCtrlTextLineCbValidate ctrltext mkfun3 @cbBtnNewReflectionMap [p winstr ctrltext];
    setEdCtrlButtonCb (crEdCtrlButton winstr 10 (ih - 30) 90 20 "Ok" EDWIN_RESIZE_MW) mkfun2 mkfun3 @cbBtnNewReflectionMap [p winstr ctrltext] nil;
    setEdCtrlButtonCb (crEdCtrlButton winstr (iw - 100) (ih - 30) 90 20 "Cancel" EDWIN_RESIZE_MW) mkfun2 @cbBtnCancel winstr;
  );
  0;;


fun cbFogSetupMode(ctrl, pos, elem, p)=
  let p -> [[viewstr val type scenemark] ctrldensity ctrlstart ctrlend] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in
  let XMLgetMarkByValueFromMarkSons envmark "fog" -> fogmark in
  let if fogmark != nil then fogmark else XMLaddMark xmlEditSceneFile "fog" envmark nil nil -> fogmark in
  let (getOgreFogType elem) -> fogmode in
  (  
    XMLsetParam fogmark "mode" elem;
    V3DsetSceneFog sessionstr fogmode nil nil nil nil;
    
    if (fogmode == SO3_FOG_LINEAR) then
    (
      setEdCtrlFloatEnable ctrldensity 0;
      setEdCtrlFloatEnable ctrlstart 1;
      setEdCtrlFloatEnable ctrlend 1;
      0;
    )
    else if (fogmode == SO3_FOG_EXP) || (fogmode == SO3_FOG_EXP2) then
    (
      setEdCtrlFloatEnable ctrldensity 1;
      setEdCtrlFloatEnable ctrlstart 0;
      setEdCtrlFloatEnable ctrlend 0;
      0;
    )
    else
    (
      setEdCtrlFloatEnable ctrldensity 0;
      setEdCtrlFloatEnable ctrlstart 0;
      setEdCtrlFloatEnable ctrlend 0;
      0;
    );
  );
  0;;


fun cbFogSetupColor(ctrlstr, color, p)=
  if color == nil then nil else
  let p -> [viewstr val type scenemark] in
  let G2Dgetrgb color -> [r g b] in
  let ftoa ((itof r) /. 255.0) -> fr in
  let ftoa ((itof g) /. 255.0) -> fg in
  let ftoa ((itof b) /. 255.0) -> fb in    
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in
  let XMLgetMarkByValueFromMarkSons envmark "fog" -> fogmark in
  let if fogmark != nil then fogmark else XMLaddMark xmlEditSceneFile "fog" envmark nil nil -> fogmark in
  let XMLgetMarkByValueFromMarkSons fogmark "colourDiffuse" -> colormark in
  let if colormark != nil then colormark else XMLaddMark xmlEditSceneFile "colourDiffuse" fogmark nil nil -> colormark in
  (
    XMLsetParam colormark "r" fr;
    XMLsetParam colormark "g" fg;
    XMLsetParam colormark "b" fb;
    
    V3DsetSceneFog sessionstr nil (G2Drgb2rgba color 0) nil nil nil;
  );
  0;;


fun cbFogSetupLinearEnd(ctrl, value, p)=
  let p -> [[viewstr val type scenemark] ctrlstart] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getEdCtrlFloatValue ctrlstart -> startval in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in  
  let XMLgetMarkByValueFromMarkSons envmark "fog" -> fogmark in
  let if fogmark != nil then fogmark else XMLaddMark xmlEditSceneFile "fog" envmark nil nil -> fogmark in
  (
    if (startval <=. value) then nil else
    (
      XMLsetParam fogmark "linearStart" XMLgetShortFloatToString value;
      
      setEdCtrlFloatValue ctrlstart value;
    );
    
    XMLsetParam fogmark "linearEnd" XMLgetShortFloatToString value;
    
    V3DsetSceneFog sessionstr nil nil nil startval value;
  );
  0;;


fun cbFogSetupLinearStart(ctrl, value, p)=
  let p -> [[viewstr val type scenemark] ctrlend] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let getEdCtrlFloatValue ctrlend -> endval in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in  
  let XMLgetMarkByValueFromMarkSons envmark "fog" -> fogmark in
  let if fogmark != nil then fogmark else XMLaddMark xmlEditSceneFile "fog" envmark nil nil -> fogmark in
  (
    if (endval >=. value) then nil else
    (
      XMLsetParam fogmark "linearEnd" XMLgetShortFloatToString value;
      
      setEdCtrlFloatValue ctrlend value;
    );
    
    XMLsetParam fogmark "linearStart" XMLgetShortFloatToString value;
    
    V3DsetSceneFog sessionstr nil nil nil value endval;
  );
  0;;


fun cbFogSetupDensity(ctrl, value, p)=
  let p -> [viewstr val type scenemark] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in  
  let XMLgetMarkByValueFromMarkSons envmark "fog" -> fogmark in
  let if fogmark != nil then fogmark else XMLaddMark xmlEditSceneFile "fog" envmark nil nil -> fogmark in
  (
    XMLsetParam fogmark "density" XMLgetShortFloatToString value;
    
    V3DsetSceneFog sessionstr nil nil value nil nil;
  );
  0;;


/**  cbDestroyFogSetupWin [EdWindow] I
  *  callback on destroy fog setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyFogSetupWin(winstr)=
  set winFogSetup = nil;
  0;;


fun cbTreeMenuSetFogSetting(mnuitem, p)=
  if winFogSetup == nil then nil else
  (
    dsEdWindow winFogSetup;
    set winFogSetup = nil;
  );
  
  let p -> [viewstr val type markstr] in
  let [400 140] -> [iw ih] in
  let _GETWorkingAreaSize -> [sw sh] in
  let _GETscreenPos -> [mx my] in
  let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetFogMode (V3DgetSession sessionstr) -> fogmode in
  let G2Drgba2rgb SO3SceneGetFogColor (V3DgetSession sessionstr) -> fogcolor in
  let SO3SceneGetFogDensity (V3DgetSession sessionstr) -> density in
  let SO3SceneGetFogStart (V3DgetSession sessionstr) -> fogstart in
  let SO3SceneGetFogEnd (V3DgetSession sessionstr) -> fogend in
  let if fogend == nil then 1000.0 else fogend -> fogend in
  
  let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Fog setting") sWinDlgIcon -> winstr in
  
  let crEdCtrlLabel winstr 10 12 160 20 "Fog mode" nil -> labeltype in
  let crEdCtrlSelect winstr 180 10 190 120 EDWIN_RESIZE_MW -> ctrlmode in
  
  let crEdCtrlLabel winstr 10 37 160 20 "Fog color" nil -> labelscolor in
  let crEdCtrlColorButton winstr 180 35 100 20 fogcolor 0 EDWIN_RESIZE_MW nil -> ctrlcolor in
  
  let crEdCtrlLabel winstr 10 62 160 20 "Fog Density" nil -> labeldensity in
  let crEdCtrlFloat winstr 180 60 100 20 density 0.0 1.0 0.00001 5 nil EDWIN_RESIZE_MW -> ctrldensity in  

  let crEdCtrlLabel winstr 10 87 160 20 "Fog linear start" nil -> labelstart in
  let crEdCtrlFloat winstr 180 85 100 20 fogstart 0.0 10000000.0 1.0 4 nil EDWIN_RESIZE_MW -> ctrlstart in  
  let crEdCtrlLabel winstr 10 112 160 20 "Fog fade end" nil -> labelend in
  let crEdCtrlFloat winstr 180 110 100 20 fogend 0.0 100000000.0 1.0 4 nil EDWIN_RESIZE_MW -> ctrlend in  
  (
    set winFogSetup = winstr;

    if (fogmode == SO3_FOG_LINEAR) then
    (
      setEdCtrlFloatEnable ctrldensity 0;
      setEdCtrlFloatEnable ctrlstart 1;
      setEdCtrlFloatEnable ctrlend 1;
      0;
    )
    else if (fogmode == SO3_FOG_EXP) || (fogmode == SO3_FOG_EXP2) then
    (
      setEdCtrlFloatEnable ctrldensity 1;
      setEdCtrlFloatEnable ctrlstart 0;
      setEdCtrlFloatEnable ctrlend 0;
      0;
    )
    else
    (
      setEdCtrlFloatEnable ctrldensity 0;
      setEdCtrlFloatEnable ctrlstart 0;
      setEdCtrlFloatEnable ctrlend 0;
      0;
    );
    
    fillEdCtrlSelect ctrlmode "none"::"linear"::"exp"::"exp2"::nil;    
    
    selectEdCtrlSelect ctrlmode (getOgreFogByType fogmode);
    
    setEdCtrlSelectCb ctrlmode mkfun4 @cbFogSetupMode [p ctrldensity ctrlstart ctrlend];
    
    setEdCtrlColorButtonCb ctrlcolor mkfun3 @cbFogSetupColor p;
    
    setEdCtrlFloatCbChange ctrldensity mkfun3 @cbFogSetupDensity p;
    setEdCtrlFloatCbChange ctrlstart mkfun3 @cbFogSetupLinearStart [p ctrlend];
    setEdCtrlFloatCbChange ctrlend mkfun3 @cbFogSetupLinearEnd [p ctrlstart];   
    
    setEdwindowCbDestroy winFogSetup @cbDestroyFogSetupWin;
    0;
  );
  0;;


/**  cbDestroyMaterialSchemeSetupWin [EdWindow] I
  *  callback on destroy material scheme setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyMaterialSchemeSetupWin(winstr)=
  set winMatSchemeSetup = nil;
  0;;


fun cbMaterialSchemeSetupSelect(ctrl, pos, elem, p)=
  let p -> [viewstr val type scenemark] in
  let V3DgetDefaultViewport viewstr -> defaultviewportstr in
  let XMLgetMarkByValueFromMarkSons scenemark "environment" -> envmark in
  let XMLgetMarkByValueFromMarkSons envmark "materialScheme" -> schememark in
  let if schememark != nil then schememark else XMLaddMark xmlEditSceneFile "materialScheme" envmark nil nil -> schememark in
  (
    XMLsetParam schememark "name" elem;
    
    SO3ViewportSetMaterialScheme defaultviewportstr.V3D_viewport elem;
  );
  0;;


fun cbTreeMenuSetMaterialScheme(mnuitem, p)=
  if winMatSchemeSetup == nil then nil else
  (
    dsEdWindow winMatSchemeSetup;
    set winMatSchemeSetup = nil;
  );
  
  let p -> [viewstr val type markstr] in
  let getAllMaterialScheme viewstr -> lscheme in
  if !(sizelist lscheme) then
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "No material scheme found in scene" 0;
    0;
  )
  else
  (
    let [400 60] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [x y] in
    
    let V3DgetDefaultSession viewstr -> sessionstr in
    let V3DgetDefaultViewport viewstr -> viewportstr in
    
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil "Material Scheme setting") sWinDlgIcon -> winstr in
    
    let crEdCtrlLabel winstr 10 12 160 20 "Available material scheme" nil -> labeltype in
    let crEdCtrlSelect winstr 180 10 210 120 EDWIN_RESIZE_MW -> ctrlmode in
    (
      set winMatSchemeSetup = winstr;
      
      fillEdCtrlSelect ctrlmode lscheme;    
      
      selectEdCtrlSelect ctrlmode (SO3ViewportGetMaterialScheme viewportstr.V3D_viewport);
      
      setEdCtrlSelectCb ctrlmode mkfun4 @cbMaterialSchemeSetupSelect p;
      
      setEdwindowCbDestroy winMatSchemeSetup @cbDestroyMaterialSchemeSetupWin;
      0;
    );
  );
  0;;


fun saveCoordsSetup()=
  let winCoordsSetup -> [obj objstr owinstr mode ctrlpx ctrlpy ctrlpz ctrlpgx ctrlpgy ctrlpgz x y] in
  if (mode == 1) then
  (
    let XMLgetMarkByValueFromMarkSons objstr "position" -> markstr in
    let SO3ObjectGetPosition obj -> [x y z] in
    (
      XMLsetParam markstr "x" XMLgetShortFloatToString x;
      XMLsetParam markstr "y" XMLgetShortFloatToString y;
      XMLsetParam markstr "z" XMLgetShortFloatToString z;
    );
  )
  else if (mode == 2) then
  (
    let XMLgetMarkByValueFromMarkSons objstr "rotation" -> markstr in
    let SO3ObjectGetOrientation obj -> [qx qy qz qw] in
    (
      let SO3ObjectGetOrientation obj -> [qx qy qz qw] in
      (
        XMLsetParam markstr "qx" XMLgetShortFloatToString qx;
        XMLsetParam markstr "qy" XMLgetShortFloatToString qy;
        XMLsetParam markstr "qz" XMLgetShortFloatToString qz;
        XMLsetParam markstr "qw" XMLgetShortFloatToString qw;
      );
    );
  )
  else if (mode == 3) then
  (
    let XMLgetMarkByValueFromMarkSons objstr "scale" -> markstr in
    let SO3ObjectGetScale obj -> [x y z] in
    (
      XMLsetParam markstr "x" XMLgetShortFloatToString x;
      XMLsetParam markstr "y" XMLgetShortFloatToString y;
      XMLsetParam markstr "z" XMLgetShortFloatToString z;
    );
  )
  else nil;
  0;;


fun cbCoordsSetupPositionX(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalPosition obj else SO3ObjectGetPosition obj -> [opx opy opz] in
  (    
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    /*
    // reinit particle to use the same way than particles
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    */
    
    if global then
      SO3ObjectSetGlobalPosition obj [value opy opz]
    else
      SO3ObjectSetPosition obj [value opy opz];
    
    let SO3ObjectGetPosition obj -> [x y z] in
    let SO3ObjectGetGlobalPosition obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlx x;
      setEdCtrlFloatValueWithoutCallback ctrly y;
      setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
  );
  0;;


fun cbCoordsSetupPositionY(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalPosition obj else SO3ObjectGetPosition obj -> [opx opy opz] in
  (
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    /*
    // reinit particle to use the same way than particles
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    */
    
    if global then
      SO3ObjectSetGlobalPosition obj [opx value opz]
    else
      SO3ObjectSetPosition obj [opx value opz];
    
    let SO3ObjectGetPosition obj -> [x y z] in
    let SO3ObjectGetGlobalPosition obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (
      setEdCtrlFloatValueWithoutCallback ctrlx x;
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrly y;
      setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
  );
  0;;


fun cbCoordsSetupPositionZ(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalPosition obj else SO3ObjectGetPosition obj -> [opx opy opz] in
  (    
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    /*
    // reinit particle to use the same way than particles
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    */
    
    if global then
      SO3ObjectSetGlobalPosition obj [opx opy value]
    else
      SO3ObjectSetPosition obj [opx opy value];
    
    let SO3ObjectGetPosition obj -> [x y z] in
    let SO3ObjectGetGlobalPosition obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (
      setEdCtrlFloatValueWithoutCallback ctrlx x;
      setEdCtrlFloatValueWithoutCallback ctrly y;
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
  );
  0;;


fun cbCoordsSetupStatePosition(ctrl, pvalue, nvalue, p)=
  let p -> [viewstr val type objstr axis] in
  let XMLgetMarkByValueFromMarkSons objstr "position" -> objpositionstr in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetPosition obj -> [x y z] in
  (
    addObjHistoryState val objstr obj 1;
    
    if (axis == 1) then
      XMLsetParam objpositionstr "x" XMLgetShortFloatToString x
    else if (axis == 2) then
      XMLsetParam objpositionstr "y" XMLgetShortFloatToString y
    else if (axis == 3) then
      XMLsetParam objpositionstr "z" XMLgetShortFloatToString z
    else nil;
  );
  0;;


/**  cbDestroyCoordsSetupWin [EdWindow] I
  *  callback on destroy coords setting window
  *  
  *  private
  *
  *  return 0
  **/
fun cbDestroyCoordsSetupWin(winstr)=
  set winCoordsSetup = nil;
  0;;


fun cbMoveCoordsSetupWin(winstr, x, y)=
  mutate winCoordsSetup <- [_ _ _ _ _ _ _ _ _ _ x y];
  0;;


fun cbTreeMenuObjectSetPosition(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let winCoordsSetup -> [wobj wobjstr owinstr mode ctrlpx ctrlpy ctrlpz ctrlpgx ctrlpgy ctrlpgz x y] in
  let SO3ObjectGetPosition obj -> [opx opy opz] in
  let SO3ObjectGetGlobalPosition obj -> [ogpx ogpy ogpz] in
  if (wobj != obj) || (mode != 1) then
  (
    if winCoordsSetup == nil then nil else
    (
      // save previous state
      saveCoordsSetup;
      
      dsEdWindow owinstr;
      set winCoordsSetup = nil;
    );
    
    if (type == iTypeScene) || (type == nil) || (type == iTypeCompositor) || (type == iTypeSkyBox) || (type == iTypeSkyDome) || (type == iTypeSkyPlane) || (type == iTypeAnim) then nil else
    let p -> [viewstr val type markstr] in
    let [280 115] -> [iw ih] in
    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [px py] in

    let (if x == nil then px else x) -> x in
    let (if y == nil then py else y) -> y in
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat val " position") sWinDlgIcon -> winstr in
    
    let crEdCtrlLabel winstr 10 12 135 20 "Local coords." nil -> labelloc in
    let crEdCtrlLabel winstr 10 37 20 20 "X" nil -> labelx in
    let crEdCtrlFloat winstr 35 35 100 20 opx (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlx in  
    let crEdCtrlLabel winstr 10 62 20 20 "Y" nil -> labely in
    let crEdCtrlFloat winstr 35 60 100 20 opy (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrly in
    let crEdCtrlLabel winstr 10 87 20 20 "Z" nil -> labelz in
    let crEdCtrlFloat winstr 35 85 100 20 opz (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlz in

    let crEdCtrlLabel winstr 145 12 135 20 "Global coords." nil -> labelloc in
    let crEdCtrlLabel winstr 145 37 20 20 "X" nil -> labelgx in
    let crEdCtrlFloat winstr 170 35 100 20 ogpx (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgx in  
    let crEdCtrlLabel winstr 145 62 20 20 "Y" nil -> labelgy in
    let crEdCtrlFloat winstr 170 60 100 20 ogpy (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgy in
    let crEdCtrlLabel winstr 145 87 20 20 "Z" nil -> labelgz in
    let crEdCtrlFloat winstr 170 85 100 20 ogpz (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgz in 
    (
      set winCoordsSetup = [obj markstr winstr 1 ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz x y];

      setEdCtrlFloatCbChange ctrlx mkfun3 @cbCoordsSetupPositionX [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrlx mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrly mkfun3 @cbCoordsSetupPositionY [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrly mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 2];
      setEdCtrlFloatCbChange ctrlz mkfun3 @cbCoordsSetupPositionZ [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrlz mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 3];
      
      setEdCtrlFloatCbChange ctrlgx mkfun3 @cbCoordsSetupPositionX [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgx mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrlgy mkfun3 @cbCoordsSetupPositionY [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgy mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 2];
      setEdCtrlFloatCbChange ctrlgz mkfun3 @cbCoordsSetupPositionZ [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgz mkfun4 @cbCoordsSetupStatePosition [viewstr val type markstr 3];
      
      setEdwindowCbMove winstr @cbMoveCoordsSetupWin;
      setEdwindowCbDestroy winstr @cbDestroyCoordsSetupWin;
      0;
    );
  )
  else
  (
    setEdCtrlFloatValue ctrlpx opx;
    setEdCtrlFloatValue ctrlpy opy;
    setEdCtrlFloatValue ctrlpz opz;
    
    setEdCtrlFloatValue ctrlpgx ogpx;
    setEdCtrlFloatValue ctrlpgy ogpy;
    setEdCtrlFloatValue ctrlpgz ogpz;        
    0;
  );
  0;;


fun cbCoordsSetupOrientation(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let getEdCtrlFloatValue if global then ctrlgx else ctrlx -> xval in
  let getEdCtrlFloatValue if global then ctrlgy else ctrly -> yval in
  let getEdCtrlFloatValue if global then ctrlgz else ctrlz -> zval in
  let [(SO3MathsDegreeToRadian xval) (SO3MathsDegreeToRadian yval) (SO3MathsDegreeToRadian zval)] -> eang in
  let SO3MathsEulerYXZToQuat eang -> quat in
  (
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    /*
    // reinit particle to use the same way than particles
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );*/
    
    if global then
      SO3ObjectSetGlobalOrientation obj quat
    else
      SO3ObjectSetOrientation obj quat;
    
    let SO3ObjectGetGlobalOrientation obj -> gquat in
    let SO3MathsQuatToEulerYXZ gquat -> [gx gy gz] in
    let SO3MathsRadianToDegree gx -> gx in
    let SO3MathsRadianToDegree gy -> gy in
    let SO3MathsRadianToDegree gz -> gz in
    
    let SO3ObjectGetOrientation obj -> [qx qy qz qw] in
    let SO3MathsQuatToEulerYXZ [qx qy qz qw] -> [x y z] in
    let SO3MathsRadianToDegree x -> x in
    let SO3MathsRadianToDegree y -> y in
    let SO3MathsRadianToDegree z -> z in
    (      
      if (!global) then nil else
      (
        setEdCtrlFloatValueWithoutCallback ctrlx x;
        setEdCtrlFloatValueWithoutCallback ctrly y;
        setEdCtrlFloatValueWithoutCallback ctrlz z;
      );
      
      if (global) then nil else
      (
        setEdCtrlFloatValueWithoutCallback ctrlgx gx;
        setEdCtrlFloatValueWithoutCallback ctrlgy gy;
        setEdCtrlFloatValueWithoutCallback ctrlgz gz;
      );
    );
  );
  0;;


fun cbCoordsSetupStateOrientation(ctrl, pvalue, nvalue, p)=
  let p -> [viewstr val type objstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let XMLgetMarkByValueFromMarkSons objstr "rotation" -> objorientationstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  (
    addObjHistoryState val objstr obj 2;
    
    let SO3ObjectGetOrientation obj -> [qx qy qz qw] in
    (
      XMLsetParam objorientationstr "qx" XMLgetShortFloatToString qx;
      XMLsetParam objorientationstr "qy" XMLgetShortFloatToString qy;
      XMLsetParam objorientationstr "qz" XMLgetShortFloatToString qz;
      XMLsetParam objorientationstr "qw" XMLgetShortFloatToString qw;
    );
  );
  0;;


fun cbTreeMenuObjectSetOrientation(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetGlobalOrientation obj -> gquat in
  let SO3MathsQuatToEulerYXZ gquat -> [dgx dgy dgz] in
  let SO3MathsRadianToDegree dgx -> dgx in
  let SO3MathsRadianToDegree dgy -> dgy in
  let SO3MathsRadianToDegree dgz -> dgz in
  
  let SO3ObjectGetOrientation obj -> quat in
  let SO3MathsQuatToEulerYXZ quat -> [dx dy dz] in
  let SO3MathsRadianToDegree dx -> dx in
  let SO3MathsRadianToDegree dy -> dy in
  let SO3MathsRadianToDegree dz -> dz in
  
  let winCoordsSetup -> [wobj wobjstr owinstr mode ctrlpx ctrlpy ctrlpz ctrlpgx ctrlpgy ctrlpgz x y] in
  if (wobj != obj) || (mode != 2) then
  (
    if winCoordsSetup == nil then nil else
    (
      // save previous state
      saveCoordsSetup;
      
      dsEdWindow owinstr;
      set winCoordsSetup = nil;
    );
    
    if (type == iTypeScene) || (type == nil) || (type == iTypeCompositor) || (type == iTypeSkyBox) || (type == iTypeSkyDome) || (type == iTypeSkyPlane) || (type == iTypeAnim) then nil else
    let p -> [viewstr val type markstr] in

    let [280 115] -> [iw ih] in

    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [px py] in
    let (if x == nil then px else x) -> x in
    let (if y == nil then py else y) -> y in
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat val " orientation") sWinDlgIcon -> winstr in
       
    let crEdCtrlLabel winstr 10 12 135 20 "Local coords." nil -> labelloc in
    let crEdCtrlLabel winstr 10 37 20 20 "X" nil -> labelx in
    let crEdCtrlFloat winstr 35 35 100 20 dx (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlx in  
    let crEdCtrlLabel winstr 10 62 20 20 "Y" nil -> labely in
    let crEdCtrlFloat winstr 35 60 100 20 dy (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrly in
    let crEdCtrlLabel winstr 10 87 20 20 "Z" nil -> labelz in
    let crEdCtrlFloat winstr 35 85 100 20 dz (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlz in

    let crEdCtrlLabel winstr 145 12 135 20 "Global coords." nil -> labelloc in
    let crEdCtrlLabel winstr 145 37 20 20 "X" nil -> labelgx in
    let crEdCtrlFloat winstr 170 35 100 20 dgx (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlgx in  
    let crEdCtrlLabel winstr 145 62 20 20 "Y" nil -> labelgy in
    let crEdCtrlFloat winstr 170 60 100 20 dgy (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlgy in
    let crEdCtrlLabel winstr 145 87 20 20 "Z" nil -> labelgz in
    let crEdCtrlFloat winstr 170 85 100 20 dgz (-.720.0) 720.0 0.1 2 nil EDWIN_RESIZE_MW -> ctrlgz in 
    (
      set winCoordsSetup = [obj markstr winstr 2 ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz x y];
      
      setEdCtrlFloatCbValidate ctrlx mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      setEdCtrlFloatCbValidate ctrly mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      setEdCtrlFloatCbValidate ctrlz mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      
      setEdCtrlFloatCbChange ctrlx mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      setEdCtrlFloatCbChange ctrly mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      setEdCtrlFloatCbChange ctrlz mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 0];
      
      setEdCtrlFloatCbChangedValue ctrlx mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];
      setEdCtrlFloatCbChangedValue ctrly mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];
      setEdCtrlFloatCbChangedValue ctrlz mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];

      setEdCtrlFloatCbValidate ctrlgx mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      setEdCtrlFloatCbValidate ctrlgy mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      setEdCtrlFloatCbValidate ctrlgz mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      
      setEdCtrlFloatCbChange ctrlgx mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrlgy mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrlgz mkfun3 @cbCoordsSetupOrientation [viewstr val type markstr 1];
      
      setEdCtrlFloatCbChangedValue ctrlgx mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];
      setEdCtrlFloatCbChangedValue ctrlgy mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];
      setEdCtrlFloatCbChangedValue ctrlgz mkfun4 @cbCoordsSetupStateOrientation [viewstr val type markstr];
      
      setEdwindowCbMove winstr @cbMoveCoordsSetupWin;
      setEdwindowCbDestroy winstr @cbDestroyCoordsSetupWin;
      0;
    );
  )
  else
  (
    setEdCtrlFloatValue ctrlpx dx;
    setEdCtrlFloatValue ctrlpy dy;
    setEdCtrlFloatValue ctrlpz dz;
    
    setEdCtrlFloatValue ctrlpgx dgx;
    setEdCtrlFloatValue ctrlpgy dgy;
    setEdCtrlFloatValue ctrlpgz dgz;        
    0;
  );
  0;;


fun cbCoordsSetupScaleX(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalScale obj else SO3ObjectGetScale obj -> [opx opy opz] in
  let if opx == nil then 1.0 else opx -> opx in
  let if opy == nil then 1.0 else opy -> opy in
  let if opz == nil then 1.0 else opz -> opz in
  (
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    // reinit particle to use the same way than particles
    /*
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );*/
    
    if global then
      SO3ObjectSetGlobalScale obj [value opy opz]
    else
      SO3ObjectSetScale obj [value opy opz];
    
    let SO3ObjectGetScale obj -> [x y z] in
    let SO3ObjectGetGlobalScale obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (      
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlx x;
      setEdCtrlFloatValueWithoutCallback ctrly y;
      setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
    
    // update physic body
    updateSonsPhysicsBody sessionstr objstr obj;
  );
  0;;


fun cbCoordsSetupScaleY(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalScale obj else SO3ObjectGetScale obj -> [opx opy opz] in
  let if opx == nil then 1.0 else opx -> opx in
  let if opy == nil then 1.0 else opy -> opy in
  let if opz == nil then 1.0 else opz -> opz in
  (
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
        
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    // reinit particle to use the same way than particles
    /*
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );*/
    
    if global then
      SO3ObjectSetGlobalScale obj [opx value opz]
    else
      SO3ObjectSetScale obj [opx value opz];
    
    let SO3ObjectGetScale obj -> [x y z] in
    let SO3ObjectGetGlobalScale obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (
      setEdCtrlFloatValueWithoutCallback ctrlx x;
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrly y;
      setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
    
    // update physic body
    updateSonsPhysicsBody sessionstr objstr obj;
  );
  0;;


fun cbCoordsSetupScaleZ(ctrl, value, p)=
  let p -> [viewstr val type objstr global] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if global then SO3ObjectGetGlobalScale obj else SO3ObjectGetScale obj -> [opx opy opz] in
  let if opx == nil then 1.0 else opx -> opx in
  let if opy == nil then 1.0 else opy -> opy in
  let if opz == nil then 1.0 else opz -> opz in
  (    
    // reinit anim to avoid anim reset bad pose
    let winAnimSetup -> [animstr _ tbstr chkplaypause trm] in
    if (obj != animstr.V3D_meshAnim) || (!(V3DgetAnimationEnable animstr)) then nil else
    (
      if trm == nil then nil else
        _deltimer trm;
      
      V3DresetAnimation animstr;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );
    
    // reinit particle to use the same way than particles
    /*
    let winParticleSetup -> [partsystem _ tbstr chkplaypause] in
    if (obj != partsystem) || !(SO3ParticleSystemGetEnable partsystem) then nil else
    (
      SO3ParticleSystemSetEnable partsystem 0;
      SO3ParticleSystemClear partsystem;
      setEdToolBarCheckState tbstr chkplaypause 0;
    );*/
    
    if global then
      SO3ObjectSetGlobalScale obj [opx opy value]
    else
      SO3ObjectSetScale obj [opx opy value];
    
    let SO3ObjectGetScale obj -> [x y z] in
    let SO3ObjectGetGlobalScale obj -> [gx gy gz] in
    let winCoordsSetup -> [wobj _ _ mode ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz _ _] in
    (
      setEdCtrlFloatValueWithoutCallback ctrlx x;
      setEdCtrlFloatValueWithoutCallback ctrly y;
      if (!global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlz z;
      
      setEdCtrlFloatValueWithoutCallback ctrlgx gx;
      setEdCtrlFloatValueWithoutCallback ctrlgy gy;
      if (global) then nil else
        setEdCtrlFloatValueWithoutCallback ctrlgz gz;
    );
    
    // update physic body
    updateSonsPhysicsBody sessionstr objstr obj;
  );
  0;;


fun cbCoordsSetupStateScale(ctrl, pvalue, nvalue, p)=
  let p -> [viewstr val type objstr axis] in
  let XMLgetMarkByValueFromMarkSons objstr "scale" -> objscalestr in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetScale obj -> [x y z] in
  (
    addObjHistoryState val objstr obj 3;
    
    if (axis == 1) then
      XMLsetParam objscalestr "x" XMLgetShortFloatToString x
    else if (axis == 2) then
      XMLsetParam objscalestr "y" XMLgetShortFloatToString y
    else if (axis == 3) then
      XMLsetParam objscalestr "z" XMLgetShortFloatToString z
    else nil;
  );
  0;;


fun cbTreeMenuObjectSetScale(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let SO3ObjectGetScale obj -> [opx opy opz] in
  let SO3ObjectGetGlobalScale obj -> [ogpx ogpy ogpz] in
  let winCoordsSetup -> [wobj wobjstr owinstr mode ctrlpx ctrlpy ctrlpz ctrlpgx ctrlpgy ctrlpgz x y] in
  if (wobj != obj) || (mode != 3) then
  (
    if winCoordsSetup == nil then nil else
    (
      // save previous state
      saveCoordsSetup;
      
      dsEdWindow owinstr;
      set winCoordsSetup = nil;
    );
    
    if (type == iTypeScene) || (type == iTypeCamera) || (type == iTypeLight) || (type == nil) || (type == iTypeCompositor) || (type == iTypeSkyBox) || (type == iTypeSkyDome) || (type == iTypeSkyPlane) || (type == iTypeAnim) then nil else
    let p -> [viewstr val type markstr] in
    let [280 115] -> [iw ih] in

    let _GETWorkingAreaSize -> [sw sh] in
    let _GETscreenPos -> [mx my] in
    let [(if ((mx + iw) > sw) then (sw - iw) else mx) (if ((my + ih) > sh) then (sh - ih) else my)] -> [px py] in
    let (if x == nil then px else x) -> x in
    let (if y == nil then py else y) -> y in
    let setEdWindowIcon (crEdDialogWindow _channel mainInterf.MINT_winMain x y iw ih WN_NOSCOL|WN_MENU nil strcat val " scale") sWinDlgIcon -> winstr in
    
    let crEdCtrlLabel winstr 10 12 135 20 "Local coords." nil -> labelloc in
    let crEdCtrlLabel winstr 10 37 20 20 "X" nil -> labelx in
    let crEdCtrlFloat winstr 35 35 100 20 opx (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlx in  
    let crEdCtrlLabel winstr 10 62 20 20 "Y" nil -> labely in
    let crEdCtrlFloat winstr 35 60 100 20 opy (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrly in
    let crEdCtrlLabel winstr 10 87 20 20 "Z" nil -> labelz in
    let crEdCtrlFloat winstr 35 85 100 20 opz (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlz in

    let crEdCtrlLabel winstr 145 12 135 20 "Global coords." nil -> labelloc in
    let crEdCtrlLabel winstr 145 37 20 20 "X" nil -> labelgx in
    let crEdCtrlFloat winstr 170 35 100 20 ogpx (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgx in  
    let crEdCtrlLabel winstr 145 62 20 20 "Y" nil -> labelgy in
    let crEdCtrlFloat winstr 170 60 100 20 ogpy (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgy in
    let crEdCtrlLabel winstr 145 87 20 20 "Z" nil -> labelgz in
    let crEdCtrlFloat winstr 170 85 100 20 ogpz (-.10000000.0) 10000000.0 0.01 5 nil EDWIN_RESIZE_MW -> ctrlgz in 
    (
      set winCoordsSetup = [obj markstr winstr 3 ctrlx ctrly ctrlz ctrlgx ctrlgy ctrlgz x y];

      setEdCtrlFloatCbChange ctrlx mkfun3 @cbCoordsSetupScaleX [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrlx mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrly mkfun3 @cbCoordsSetupScaleY [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrly mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 2];
      setEdCtrlFloatCbChange ctrlz mkfun3 @cbCoordsSetupScaleZ [viewstr val type markstr 0];
      setEdCtrlFloatCbChangedValue ctrlz mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 3];
      
      
      setEdCtrlFloatCbChange ctrlgx mkfun3 @cbCoordsSetupScaleX [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgx mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 1];
      setEdCtrlFloatCbChange ctrlgy mkfun3 @cbCoordsSetupScaleY [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgy mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 2];
      setEdCtrlFloatCbChange ctrlgz mkfun3 @cbCoordsSetupScaleZ [viewstr val type markstr 1];
      setEdCtrlFloatCbChangedValue ctrlgz mkfun4 @cbCoordsSetupStateScale [viewstr val type markstr 3];
      
      setEdwindowCbMove winstr @cbMoveCoordsSetupWin;
      setEdwindowCbDestroy winstr @cbDestroyCoordsSetupWin;
      0;
    );
  )
  else
  (
    setEdCtrlFloatValue ctrlpx opx;
    setEdCtrlFloatValue ctrlpy opy;
    setEdCtrlFloatValue ctrlpz opz;
    
    setEdCtrlFloatValue ctrlpgx ogpx;
    setEdCtrlFloatValue ctrlpgy ogpy;
    setEdCtrlFloatValue ctrlpgz ogpz;        
    0;
  );
  0;;


/**  cbChangeEditMode [EdToolBar CompCheck I I I [V3Dview [CompCheck CompCheck CompCheck CompCheck]]] I
  *  callback on change edit mode (select, move, rotate, scale)
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeEditMode(tbstr, check, btn, mask, state, p)=
  let p -> [viewstr [chkselect chkmove chkrotate chkscale]] in
  (
    if check == chkselect then
    (
      set iViewerEditMode = 0;
      setEdToolBarCheckState tbstr chkselect 1;
      setEdToolBarCheckState tbstr chkmove 0;
      setEdToolBarCheckState tbstr chkrotate 0;
      setEdToolBarCheckState tbstr chkscale 0;
    )
    else if check == chkmove then
    (
      set iViewerEditMode = 1;
      setEdToolBarCheckState tbstr chkselect 0;
      setEdToolBarCheckState tbstr chkmove 1;
      setEdToolBarCheckState tbstr chkrotate 0;
      setEdToolBarCheckState tbstr chkscale 0;
      
      if btn != 2 then nil else
      (
        let getGraphByValue sSelected -> tgraph in
        let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in       
        if (ttype == iTypeScene) || (ttype == nil) || (ttype == iTypeCompositor) || (ttype == iTypeSkyBox) || (ttype == iTypeSkyDome) || (ttype == iTypeSkyPlane) || (ttype == iTypeAnim) then nil else
          cbTreeMenuObjectSetPosition treeitem [viewstr sSelected ttype markstr];
      );
    )
    else if check == chkrotate then
    (
      set iViewerEditMode = 2;
      setEdToolBarCheckState tbstr chkselect 0;
      setEdToolBarCheckState tbstr chkmove 0;
      setEdToolBarCheckState tbstr chkrotate 1;
      setEdToolBarCheckState tbstr chkscale 0;
      
      if btn != 2 then nil else
      (
        let getGraphByValue sSelected -> tgraph in
        let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in       
        if (ttype == iTypeScene) || (ttype == nil) || (ttype == iTypeCompositor) || (ttype == iTypeSkyBox) || (ttype == iTypeSkyDome) || (ttype == iTypeSkyPlane) || (ttype == iTypeAnim) then nil else
          cbTreeMenuObjectSetOrientation treeitem [viewstr sSelected ttype markstr];
      );
    )
    else if check == chkscale then
    (
      set iViewerEditMode = 3;
      setEdToolBarCheckState tbstr chkselect 0;
      setEdToolBarCheckState tbstr chkmove 0;
      setEdToolBarCheckState tbstr chkrotate 0;
      setEdToolBarCheckState tbstr chkscale 1;
      
      if btn != 2 then nil else
      (
        let getGraphByValue sSelected -> tgraph in
        let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in       
        if (ttype == iTypeScene) || (ttype == iTypeCamera) || (ttype == iTypeLight) || (ttype == nil) || (ttype == iTypeCompositor) || (ttype == iTypeSkyBox) || (ttype == iTypeSkyDome) || (ttype == iTypeSkyPlane) || (ttype == iTypeAnim) then nil else
          cbTreeMenuObjectSetScale treeitem [viewstr sSelected ttype markstr];
      );
    )
    else nil;
    
    // get the selected object axis and rebuild the good axe mode
    let V3DgetDefaultSession viewstr -> sessionstr in
    let SO3SceneGetObject (V3DgetSession sessionstr) sSelected -> obj in  
      V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 1;
  );
  0;;


/**  cbChangeNavigateMode [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change navigation mode
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeNavigateMode(tbstr, check, btn, mask, state, viewstr)=
  set iNavigationMode = state;
  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3ObjectGetPosition sessionstr.V3D_shellNavigate -> spos in
  if iNavigationMode then
  (
    V3DsetOrthographicMode (V3DgetDefaultCamera sessionstr) 0;
    startAvNavMode viewstr spos [0.0 0.0 0.0 1.0] [0.0 0.0 0.0 1.0] 0.5 1.60;
  )
  else
    stopAvNavMode viewstr;
  0;;


/**  cbChangeShowGrid [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change Show grid state
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeShowGrid(tbstr, check, btn, mask, state, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    V3DshowSceneGrid sessionstr state;
  set bShowGrid = state;
  0;;


/**  cbChangeShowHelpers [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change Show helpers state
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeShowHelpers(tbstr, check, btn, mask, state, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr state;
  set bShowHelpers = state;
  0;;


/**  cbChangeShowHelpers [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change Wire mode state
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeWireMode(tbstr, check, btn, mask, state, viewstr)=
  setViewWireMode viewstr !bShowWireMode;
  0;;


/**  cbChangeShowInfos [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change Show infos state
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangeShowInfos(tbstr, check, btn, mask, state, viewstr)=
  set bShowInfos = !bShowInfos;
  V3DenableScreenInfos viewstr bShowInfos;
  let V3DgetDefaultSession viewstr -> sessionstr in
    V3DphysShowDebug sessionstr bShowInfos;
  0;;


fun playEditor(viewstr, state)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) sSelected -> obj in  
  
  let mainInterf.MINT_winView -> [_ [tbstr _ chkplay chkselect chkmove chkrotate chkscale btnundo btnredo chknav chkgrid chkhelpers chkinfos chkwiremode btntop btnfront btnleft btnpers]] in
  (
    V3DsetOrthographicMode (V3DgetDefaultCamera sessionstr) 0;
    set bAppPlay = state;
    
    setEdToolBarCheckState tbstr chkplay state;
    
    if state then
    (
      setInfoMessage "Initializing application...";
      
      let SO3ObjectGetPosition (V3DgetDefaultCamera sessionstr) -> [_ _ dist] in   
        set tCameraPosition = [(V3DgetShellNavPos sessionstr) (V3DgetShellNavAng sessionstr) dist];
      
      set tLastNavPos = avNavStr.AV_pos;
      
      SO3WorldSetBodiesInitialState (V3DgetSession sessionstr);
      
      //setEdToolBarCheckState tbstr chknav 0;
      stopAvNavMode viewstr;
      //set iNavigationMode = 0;
      
      if (OS3D_DEBUG) then nil else
      (
        setEdToolBarCheckEnable tbstr chkselect 0;
        setEdToolBarCheckEnable tbstr chkmove 0;
        setEdToolBarCheckEnable tbstr chkrotate 0;
        setEdToolBarCheckEnable tbstr chkscale 0;
        setEdToolBarCheckEnable tbstr chknav 0;
        
        setEdToolBarCheckEnable tbstr chkgrid 0;
        setEdToolBarCheckEnable tbstr chkhelpers 0;
        //setEdToolBarCheckEnable tbstr chkwiremode 0;
        
        setEdToolBarButtonEnable tbstr btnundo 0;
        setEdToolBarButtonEnable tbstr btnredo 0;
        
        setEdToolBarButtonEnable tbstr btntop 0;
        setEdToolBarButtonEnable tbstr btnfront 0;
        setEdToolBarButtonEnable tbstr btnleft 0;
        setEdToolBarButtonEnable tbstr btnpers 0;
        
        SO3ObjectShowBoundingBox obj 0;
        V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 0;
              
        //V3DsetViewportPolygonMode (V3DgetDefaultViewport viewstr) SO3_POLY_SOLID;
        
        V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr 0;
        V3DshowSceneGrid sessionstr 0;
        
        shadowsDestroySetting;
        
        renderingDestroySetting viewstr;
        
        physicsDestroySetting;
        
        environmentDestroySetting;
        
        let winLightSetup -> [_ winstr] in
          dsEdWindow winstr;
        set winLightSetup = nil;
        
        let winCameraSetup -> [_ winstr] in
          dsEdWindow winstr;
        set winCameraSetup = nil;
        
        if (winCoordsSetup == nil) then nil else
          saveCoordsSetup; // save previous state

        let winCoordsSetup -> [_ _ winstr _ _ _ _ _ _ _ _ _] in
          dsEdWindow winstr;
        set winCoordsSetup = nil;
        
        let winAnimSetup -> [_ winstr _ _ _] in
          dsEdWindow winstr;
        set winAnimSetup = nil;
        
        let winParticleSetup -> [_ winstr _ _] in
          dsEdWindow winstr;
        set winParticleSetup = nil;
        
        let winCubeMapSetup -> [_ winstr _ _] in
          dsEdWindow winstr;
        set winCubeMapSetup = nil;
        
        let winReflectionMapSetup -> [_ winstr _ _] in
          dsEdWindow winstr;
        set winReflectionMapSetup = nil;
        
        let winCompositorSetup -> [_ winstr] in
          dsEdWindow winstr;
        set winCompositorSetup = nil;
        
        let winNodeSetup -> [_ winstr] in
          dsEdWindow winstr;
        set winNodeSetup = nil;
        
        let winEntitySetup -> [_ winstr] in
          dsEdWindow winstr;
        set winEntitySetup = nil;
        
        let winEntityInfo -> [_ winstr] in
          dsEdWindow winstr;
        set winEntityInfo = nil;
        
        dsEdWindow winFogSetup;
        set winFogSetup = nil;
        
        dsEdWindow winMatSchemeSetup;
        set winMatSchemeSetup = nil;
        
        dsEdWindow winImportMesh;
        set winImportMesh = nil;
        
        dsEdWindow winImportScene;
        set winImportScene = nil;
        
        let winMeshMaterialSetup -> [_ swinstr] in
          dsEdWindow swinstr;
        set winMeshMaterialSetup = nil;        
      );
      
      playSceneGraph viewstr;
      startAllPluginInstances;
      
        if !bPhysicOnPlay then nil else
          V3DphysEnablePhysic sessionstr state;
          
      setInfoMessage "Application initialized.";
    )
    else
    (
      setInfoMessage "Initializing editor...";
      
      V3DphysEnablePhysic sessionstr state;    
      stopAllPluginInstances;
      
      let tCameraPosition -> [vpos vang dist] in
      (
        SO3ObjectSetPosition (V3DgetDefaultCamera sessionstr) [0.0 0.0 dist];
        V3DsetShellNavPos sessionstr vpos;
        V3DsetShellNavAng sessionstr vang;
      );
      refreshSceneGraph viewstr;
      
      let getEdCtrlTreeFullValuesByValue ctrlSceneTree sSelected -> [_ _ type] in
        SO3ObjectShowBoundingBox obj (if (type != iTypeCamera) && (type != iTypeParticle) && (type != iTypeLight) && (type != iTypeSkyDome) && (type != iTypeSkyBox) && (type != iTypeSkyPlane) && (type != iTypeCompositor) && (type != iTypeBone) && (type != iTypeCubeMap) && (type != iTypeReflectionMap) then 1 else 0);
      
      V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 1;
      
      V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr bShowHelpers;
      V3DshowSceneGrid sessionstr bShowGrid;
      
      let if tLastNavPos == nil then [(SO3ObjectGetPosition sessionstr.V3D_shellNavigate) [0.0 0.0 0.0 1.0] [0.0 0.0 0.0 1.0]] else tLastNavPos -> [spos squat cquat] in
      if !iNavigationMode then nil else
        startAvNavMode viewstr spos squat cquat 0.5 1.60;
      
      setEdToolBarCheckEnable tbstr chkselect 1;
      setEdToolBarCheckEnable tbstr chkmove 1;
      setEdToolBarCheckEnable tbstr chkrotate 1;
      setEdToolBarCheckEnable tbstr chkscale 1;
      setEdToolBarCheckEnable tbstr chknav 1;
      setEdToolBarCheckEnable tbstr chkgrid 1;
      setEdToolBarCheckEnable tbstr chkhelpers 1;
      
      updateToolbarHistoryBtn;
      //setEdToolBarCheckEnable tbstr chkwiremode 1;
      
      setEdToolBarButtonEnable tbstr btntop 1;
      setEdToolBarButtonEnable tbstr btnfront 1;
      setEdToolBarButtonEnable tbstr btnleft 1;
      setEdToolBarButtonEnable tbstr btnpers 1;
      
      //V3DsetViewportPolygonMode (V3DgetDefaultViewport viewstr) if bShowWireMode then SO3_POLY_WIREFRAME else SO3_POLY_SOLID;
      
      setInfoMessage "Editor initialized.";
    );
  );
  V3DviewSetFocus viewstr;
  0;;


fun stopEditorFromPlugin()= playEditor v3dMain 0;;


/**  cbChangePlayStop [EdToolBar CompCheck I I I V3Dview] I
  *  callback on change Play Stop state
  *  
  *  private
  *
  *  return 0
  **/
fun cbChangePlayStop(tbstr, check, btn, mask, state, viewstr)=
  //addLogMessage strcat "Number of links : " itoa (getModNbLinks this);
  //addLogMessage strcat "Number of events : " itoa (getModNbEvents this);
  //addLogMessage strcat "Number of actions : " itoa (getModNbActions this);
  playEditor viewstr state;
  0;;


fun cbTreeMenuShowSceneGrid(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
    V3DshowSceneGrid sessionstr !(bShowGrid);
  
  set bShowGrid = !bShowGrid;
  
  let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ chkgrid _ _ _ _ _ _ _]] in
    setEdToolBarCheckState tbstr chkgrid bShowGrid;  
  0;;


fun cbTreeMenuShowSceneHelpers(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  let V3DgetDefaultSession viewstr -> sessionstr in
    V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr !(bShowHelpers);
  
  set bShowHelpers = !bShowHelpers;
  
  let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ _ chkhelpers _ _ _ _ _ _]] in
    setEdToolBarCheckState tbstr chkhelpers bShowHelpers;
  0;;


fun cbTreeMenuShowSceneInfos(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  (
    set bShowInfos = !bShowInfos;
    V3DenableScreenInfos viewstr bShowInfos;
    let V3DgetDefaultSession viewstr -> sessionstr in
      V3DphysShowDebug sessionstr bShowInfos;
  );  
  
  let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ _ _ chkinfos _ _ _ _ _]] in
    setEdToolBarCheckState tbstr chkinfos bShowInfos;
  0;;


fun cbTreeMenuAutoFitOnSelect(mnuitem, p)=
  let p -> [viewstr val type markstr] in
  (
    set bAutoFit = !bAutoFit;
  );
  0;;


fun showTreeMenu(ctrlstr, item, viewstr)=
  let getEdCtrlTreeValueByItem ctrlSceneTree item -> [val type] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let _CRpopupMenu _channel -> mnu in
  let getGraphByValue val -> [_ type alias markstr _ groupmark _ _] in
  let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
  let if ctrlstr == nil then viewstr.V3D_win else ctrlstr.EDC_father.EDW_win -> mwin in
  (
    if type == iTypeScene then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set rendering setting") @cbTreeMenuSetRenderingSetup [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set shadow method") @cbTreeMenuSetShadowMethod [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set fog setting") @cbTreeMenuSetFogSetting [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set material scheme") @cbTreeMenuSetMaterialScheme [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set physic setting") @cbTreeMenuSetPhysicSetup [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set environment setting") @cbTreeMenuSetEnvSetup [viewstr val type markstr];
      
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu (if bShowGrid then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Show scene grid") @cbTreeMenuShowSceneGrid [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if bShowHelpers then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Show scene helpers") @cbTreeMenuShowSceneHelpers [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if bShowInfos then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Show scene infos") @cbTreeMenuShowSceneInfos [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if bAutoFit then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Auto fit on select") @cbTreeMenuAutoFitOnSelect [viewstr val type markstr];
      
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add sky box") @cbTreeMenuAddSkyBox [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add sky dome") @cbTreeMenuAddSkyDome [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add sky plan") @cbTreeMenuAddSkyPlane [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add compositor") @cbTreeMenuAddCompositor [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];
      
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Import to scene") @cbTreeMenuImport [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add resources to scene") @cbTreeMenuAddResources [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add new group") @cbTreeMenuAddGroup [viewstr val type markstr item];
      0;
    )
    else if type == iTypeEntity then
    let SO3ObjectGetCastShadows obj -> meshcastshadow in
    let XMLgetBoolParam markstr "receiveShadows" -> meshreceiveshadow in
    let XMLgetBoolParam markstr "indexMaterials" -> indexmat in
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Object informations") @cbTreeMenuEntityInformations [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if meshcastshadow then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Cast shadow") @cbTreeMenuObjectCastShadow [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuEntityEditParameters [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit materials") @cbTreeMenuMeshMaterialSetup [viewstr val type markstr groupmark];
      //_CBmenu (_APPitem _channel mnu (if meshreceiveshadow then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Receive shadow") @cbTreeMenuObjectReceiveShadow [viewstr val type markstr];
      //_CBmenu (_APPitem _channel mnu (if indexmat then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Index materials") @cbTreeMenuObjectIndexMaterials [viewstr val type markstr];
      
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set physic") @cbTreeMenuSetPhysicBodySetup [viewstr val type markstr];
      
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];    
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      0;
    )
    else if type == iTypeGroup then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];      
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Import to this group") @cbTreeMenuImport [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add resources to this group") @cbTreeMenuAddResources [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add new group") @cbTreeMenuAddGroup [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Export group") @cbTreeMenuExportGroup [viewstr val type markstr item];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];    
      0;
    )
    else if type == iTypeCamera then
    (
      let SO3ObjectGetName V3DgetViewportCamera (V3DgetDefaultViewport viewstr) -> curcameraname in
      let if (!strcmp curcameraname val) then 1 else 0 -> camstate in
      _CBmenu (_APPitem _channel mnu (if camstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Set as active camera") @cbTreeMenuSetActiveCamera [viewstr val type markstr camstate];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuCameraEditParameters [viewstr val type markstr];
      if !strcmp val "default_camera" then nil else
      (
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
        _APPitem _channel mnu ME_SEPARATOR "";
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];
        _APPitem _channel mnu ME_SEPARATOR "";
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      );
      0;
    )
    else if type == iTypeLight then
    let SO3LightGetVisible obj -> lightstate in
    let SO3ObjectGetCastShadows obj -> lightcastshadow in
    (
      _CBmenu (_APPitem _channel mnu (if lightstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuLightEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if lightcastshadow then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Cast shadow") @cbTreeMenuLightCastShadow [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuLightEditParameters [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      
      if !strcmp val "default_light" then nil else
      (
        _APPitem _channel mnu ME_SEPARATOR "";
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];
        _APPitem _channel mnu ME_SEPARATOR "";
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      );
      0;
    )
    else if type == iTypeNode then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuNodeEditParameters [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set physic") @cbTreeMenuSetPhysicBodySetup [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];    
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      0;
    )
    else if type == iTypeAnim then
    let XMLgetBoolParam markstr "enable" -> animstate in
    let XMLgetBoolParam markstr "loop" -> animloop in
    let XMLgetParam markstr "type" -> animtype in
    (
      _CBmenu (_APPitem _channel mnu (if animstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuObjectEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu (if animloop then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Loop") @cbTreeMenuAnimSetLoop [viewstr val type markstr];
      if (strcmpi animtype "cinematic") then
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuAnimEditParameters [viewstr val type markstr]
      else
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuAnimEdit [viewstr val type markstr];
      
      
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      if ((strcmpi animtype "cinematic") && (strcmpi animtype "node")) then nil else
        _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuAnimRemove [viewstr item val type markstr];
      0;
    )
    else if type == iTypeBone then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set physic") @cbTreeMenuSetPhysicBodySetup [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      0;
    )
    else if type == iTypeSkyBox then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuSkyEditParameters [viewstr item val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuSkyBoxRemove [viewstr item val type markstr];
      0;
    )
    else if type == iTypeSkyDome then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuSkyEditParameters [viewstr item val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuSkyDomeRemove [viewstr item val type markstr];
      0;
    )
    else if type == iTypeSkyPlane then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuSkyEditParameters [viewstr item val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuSkyPlanRemove [viewstr item val type markstr];
      0;
    )
    else if type == iTypeCompositor then
    let XMLgetBoolParam markstr "enable" -> compstate in
    (
      _CBmenu (_APPitem _channel mnu (if compstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuObjectEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuCompositorEditParameters [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuCompositorRemove [viewstr item val type markstr];
      0;
    )
    else if type == iTypeParticle then
    let XMLgetBoolParam markstr "enable" -> partstate in
    (
      _CBmenu (_APPitem _channel mnu (if partstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuObjectEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuParticleEditParameters [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];    
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      0;
    )
    else if type == iTypeCubeMap then
    let XMLgetBoolParam markstr "enable" -> cubemapstate in
    (
      _CBmenu (_APPitem _channel mnu (if cubemapstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuObjectEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuCubeMapEditParameters [viewstr val type markstr groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];    
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      0;
    )
    else if type == iTypeReflectionMap then
    let XMLgetBoolParam markstr "enable" -> reflectionmapstate in
    (
      _CBmenu (_APPitem _channel mnu (if reflectionmapstate then ME_CHECKED|ME_ENABLED else ME_UNCHECKED|ME_ENABLED) "Enable") @cbTreeMenuObjectEnable [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Edit setting") @cbTreeMenuReflectionMapEditParameters [viewstr val type markstr groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set position") @cbTreeMenuObjectSetPosition [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set orientation") @cbTreeMenuObjectSetOrientation [viewstr val type markstr];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set scale") @cbTreeMenuObjectSetScale [viewstr val type markstr];
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Clone") @cbTreeMenuClone [viewstr val type markstr groupmark item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add mesh") @cbTreeMenuAddMesh [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add camera") @cbTreeMenuAddCamera [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add light") @cbTreeMenuAddLight [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dummy") @cbTreeMenuAddDummy [viewstr val type markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic cube map") @cbTreeMenuAddCubeMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add dynamic reflection map") @cbTreeMenuAddReflectionMap [viewstr val type markstr item groupmark];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add particle system") @cbTreeMenuAddParticle [viewstr val type markstr item groupmark];    
      _APPitem _channel mnu ME_SEPARATOR "";
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Set alias") @cbTreeMenuChangeAlias [viewstr val type alias markstr item];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Remove") @cbTreeMenuObjectRemove [viewstr val type markstr];
      0;
    )
    else if type == iTypeCinematics then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Add cinematic") @cbTreeMenuAddCinematic [viewstr val type markstr item];
      0;
    )    
    else nil;
    
    let _GETscreenPos -> [x y] in
      _DRAWmenu mwin mnu x y PM_SCREEN|PM_LEFT_ALIGN;
  );
  0;;


fun cbSceneTreeRClick(ctrlstr, father, item, value, type, nx, ny, viewstr)=
  if item == nil then nil else
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) value -> obj in
  (
    if bAppPlay && !OS3D_DEBUG then nil else
    (
      let getEdCtrlTreePreviousSelectedItem ctrlSceneTree -> fitem in
      let getEdCtrlTreeValueByItem ctrlSceneTree fitem -> [fval ftype] in
      let SO3SceneGetObject (V3DgetSession sessionstr) fval -> fobj in
      (
          SO3ObjectShowBoundingBox fobj 0;
          V3DshowObjectAxis viewstr sessionstr fobj iViewerEditMode 0;
          SO3ObjectShowBoundingBox obj (if (type != iTypeCamera) && (type != iTypeParticle) && (type != iTypeLight) && (type != iTypeSkyDome) && (type != iTypeSkyBox) && (type != iTypeSkyPlane) && (type != iTypeAnim) && (type != iTypeCompositor) && (type != iTypeBone) && (type != iTypeCubeMap) && (type != iTypeReflectionMap) then 1 else 0);
          V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 1;
      );
      
      if winCoordsSetup == nil then nil else
      (
        let getGraphByValue value -> [_ _ _ markstr _ _ _ _] in
        let winCoordsSetup -> [_ _ _ mode _ _ _ _ _ _ _ _] in
        if mode == 1 then
          cbTreeMenuObjectSetPosition item [viewstr value type markstr]
        else if mode == 2 then
          cbTreeMenuObjectSetOrientation item [viewstr value type markstr]
        else
          cbTreeMenuObjectSetScale item [viewstr value type markstr];
        V3DviewSetFocus viewstr;
      );
      
      showTreeMenu ctrlstr item viewstr;
    );
  
    set sSelected = value;
  );
  0;;


fun cbSceneTreeSelect(ctrlstr, father, item, value, type, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) value -> obj in
  (
    let getEdCtrlTreePreviousSelectedItem ctrlSceneTree -> fitem in
    let getEdCtrlTreeValueByItem ctrlSceneTree fitem -> [fval ftype] in
    let SO3SceneGetObject (V3DgetSession sessionstr) fval -> fobj in
    (
      if bAppPlay && !OS3D_DEBUG then nil else
      (
        if (!strcmpi value fval) then nil else
        let getGraphByValue fval -> [_ _ _ markstr _ _ _ _] in
          addObjHistoryState fval markstr obj 4;
        
        if (!strcmp fval "default_camera") || (type == iTypeAnim) || (type == iTypeCompositor) || (type == iTypeSkyBox) || (type == iTypeSkyDome) || (type == iTypeSkyPlane) || !bAutoFit then nil else
        let if type == iTypeEntity then V3DgetGlobalObjectCenter obj else SO3ObjectGetGlobalPosition obj -> pos in
        let SO3SceneGetObject (V3DgetSession sessionstr) "default_camera" -> camera in
        let SO3CameraGetFOVy camera -> fovy in
        let if type == iTypeEntity then (V3DgetObjectRadius sessionstr obj) else (1.0 *. (itof iGlobalUnit)) -> curdist in
        let curdist +. (curdist /. tan fovy) -> dist in
        (
          V3DsetShellNavPos sessionstr pos;
          if iNavigationMode then nil else
          (
            SO3ObjectSetPosition camera [0.0 0.0 dist];
            V3DsetOrthographicScale camera dist;
          );
        );
        SO3ObjectShowBoundingBox fobj 0;
        SO3ObjectShowBoundingBox obj (if (type != iTypeCamera) && (type != iTypeParticle) && (type != iTypeLight) && (type != iTypeSkyDome) && (type != iTypeSkyBox) && (type != iTypeSkyPlane) && (type != iTypeAnim) && (type != iTypeCompositor) && (type != iTypeBone) && (type != iTypeCubeMap) && (type != iTypeReflectionMap) then 1 else 0);
        V3DshowObjectAxis viewstr sessionstr fobj iViewerEditMode 0;
        V3DshowObjectAxis viewstr sessionstr obj iViewerEditMode 1;
        
        let getGraphByValue value -> [_ _ _ markstr _ _ _ _] in
        (
          if (winCoordsSetup == nil) then nil else
          (
            let winCoordsSetup -> [_ _ _ mode _ _ _ _ _ _ _ _] in
            if mode == 1 then
              cbTreeMenuObjectSetPosition item [viewstr value type markstr]
            else if mode == 2 then
              cbTreeMenuObjectSetOrientation item [viewstr value type markstr]
            else
              cbTreeMenuObjectSetScale item [viewstr value type markstr];
            V3DviewSetFocus viewstr;
          );
          
          if ((winEntityInfo == nil) || (type != iTypeEntity)) then nil else
            cbTreeMenuEntityInformations nil [viewstr value type markstr];
        );
      );
    );
    
    if type != iTypeScene || !bAutoFit then nil else
      V3DsetShellNavPos sessionstr [0.0 0.0 0.0];
    
    set sSelected = value;
  );
  0;;


fun cbDlgResourceRemove(msg, lp, ret)=
  if !ret then nil else
  (
    while (lp != nil) do
    (
      let hd lp -> [name lval type] in     
      let getGraphByValue sSelected -> tgraph in
      let tgraph -> [treeitem ttype _ markstr _ groupmark initstate staticgeometry] in
      let if ttype == iTypeGroup || ttype == iTypeScene then markstr else groupmark -> groupmark in  
      let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
      let XMLgetMarksByValueFromMarkSons resourcesmark "resource" -> lresourcemarks in
      (
        if (isPathInGroup groupmark "path" name) || (isPathInGroup groupmark "skeletonlink" name) then nil else
        let XMLgetMarkByValueFromMarkSons groupmark "resources" -> resourcesmark in
        let XMLgetMarkByValueAndParamValueFromMarkSons resourcesmark "resource" "path" (strlowercase name) -> resmark in
        (
          XMLdelMark xmlEditSceneFile resmark;
          delEdCtrlList ctrlResourcesList (strlowercase name);    
        );
      );
      
      set lp = tl lp;
    );
  );
  0;;


fun cbRemoveResource(ctrlstr, sessionstr)=
  let getMultiSelectedEdCtrlList ctrlResourcesList -> elems in
  if elems == nil then nil else
    _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Are you sure to remove this resources ?" 1 @cbDlgResourceRemove elems;

  // reload resources groups
  /*
  let SO3GroupList (V3DgetSession sessionstr) -> l in
  let sizelist l -> size in
  let 0 -> i in
  while i < size do
  (
    let nth_list l i -> resgroup in
    if (!strcmp resgroup "V3DdefaultResources") then nil else
      SO3GroupReload (V3DgetSession sessionstr) resgroup;
    
    set i = i + 1;
  );
  */
  0;;


fun cbDlgObjectMoveToFather(msg, p, ret)=
  if !ret then nil else
  let p -> [viewstr telem1 telem2] in
  let telem1 -> [father1 item1 val1 type1] in
  let telem2 -> [father2 item2 val2 type2] in
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) val1 -> obj1 in
  let SO3SceneGetObject (V3DgetSession sessionstr) val2 -> obj2 in
  let if obj2 == nil then SO3ObjectGetSceneRoot (V3DgetSession sessionstr) else obj2 -> obj2 in
  
  let SO3ObjectGetGlobalPosition obj1 -> newpos in
  let SO3ObjectGetGlobalOrientation obj1 -> newquat in
  let SO3ObjectGetGlobalScale obj1 -> newscale in
  let getGraphByValue val1 -> [_ _ _ markstr _ groupmark _ _] in
  let getGraphByValue val2 -> [_ _ _ markdeststr _ destgroupmark _ _] in
  (
    addObjHistoryState val1 markstr obj1 0;
    
    if markdeststr == nil then nil else
    let if (type1 != iTypeGroup && ((type2 == iTypeGroup) || (type2 == iTypeScene))) then
          XMLgetMarkByValueFromMarkSons markdeststr "graph"
        else
          markdeststr
    -> markdeststr in
      XMLmoveMark xmlEditSceneFile markstr markdeststr;
    
    moveEdCtrlTreeItem ctrlSceneTree item1 item2;
    
    selEdCtrlTreeItemByValue ctrlSceneTree val1;
    
    SO3ObjectUnlink obj1;
    SO3ObjectLink obj1 obj2;
    SO3ObjectSetGlobalPosition obj1 newpos;
    SO3ObjectSetGlobalOrientation obj1 newquat;
    SO3ObjectSetGlobalScale obj1 newscale;
    
    
    let SO3ObjectGetPosition obj1 -> newpos in
    let SO3ObjectGetOrientation obj1 -> newquat in
    let SO3ObjectGetScale obj1 -> newscale in
    let XMLgetMarkByValueFromMarkSons markstr "position" -> objpositionmark in
    let XMLgetMarkByValueFromMarkSons markstr "rotation" -> objrotationmark in
    let XMLgetMarkByValueFromMarkSons markstr "scale" -> objscalemark in
    let newpos -> [nx ny nz] in
    let newquat -> [qx qy qz qw] in
    let newscale -> [sx sy sz] in
    (
      XMLsetParam objpositionmark "x" XMLgetShortFloatToString nx;
      XMLsetParam objpositionmark "y" XMLgetShortFloatToString ny;
      XMLsetParam objpositionmark "z" XMLgetShortFloatToString nz;
      
      XMLsetParam objrotationmark "qx" XMLgetShortFloatToString qx;
      XMLsetParam objrotationmark "qy" XMLgetShortFloatToString qy;
      XMLsetParam objrotationmark "qz" XMLgetShortFloatToString qz;       
      XMLsetParam objrotationmark "qw" XMLgetShortFloatToString qw;
      
      XMLsetParam objscalemark "x" XMLgetShortFloatToString sx;
      XMLsetParam objscalemark "y" XMLgetShortFloatToString sy;
      XMLsetParam objscalemark "z" XMLgetShortFloatToString sz;
    );
    
    // update xml pos !
  );
  0;;


fun cbSceneTreeDrag(ctrlstr, telem1, telem2, viewstr)=
  if bAppPlay then nil else
  (
    let telem1 -> [father1 item1 val1 type1] in
    let telem2 -> [father2 item2 val2 type2] in
    let getGraphByValue val1 -> [_ _ _ markstr _ groupmark _ _] in
    let getGraphByValue val2 -> [_ _ _ markdeststr _ destgroupmark _ _] in
    let getEdCtrlTreeRootItem ctrlSceneTree -> rootitem in
    if (!strcmp val1 "default_camera") ||
       (!strcmp val2 "default_camera") ||
       (!strcmp val1 "default_light") ||
       (!strcmp val2 "default_light") ||
       (item1 == rootitem) ||
       (item1 == item2) ||
       (item2 == father1) ||
       (item1 == father2) ||
       (type1 == iTypeSkyDome) ||
       (type1 == iTypeSkyBox) ||
       (type1 == iTypeSkyPlane) ||
       (type1 == iTypeCompositor) ||
       (type2 == iTypeSkyDome) ||
       (type2 == iTypeSkyBox) ||
       (type2 == iTypeSkyPlane) ||
       (type2 == iTypeCompositor) ||
       (type1 == iTypeAnim) ||
       (type2 == iTypeAnim) ||
       (type1 == iTypeBone) ||
       (type2 == iTypeBone) ||
       (type1 == iTypeGroup && type2 == iTypeCamera) ||
       (type1 == iTypeGroup && type2 == iTypeEntity) ||
       (type1 == iTypeGroup && type2 == iTypeParticle) ||
       (type1 == iTypeGroup && type2 == iTypeLight) ||
       (type1 == iTypeGroup && type2 == iTypeNode) ||
       (type1 == iTypeGroup && type2 == iTypeCubeMap) ||
       (type1 == iTypeGroup && type2 == iTypeReflectionMap) ||
       (type1 == iTypeGroup && (type2 == iTypeSkyDome || type2 == iTypeSkyBox || type2 == iTypeSkyPlane || type2 == iTypeCompositor)) ||
       ((type1 != iTypeGroup) && ((type2 == iTypeGroup) || (type2 == iTypeScene)) && (groupmark != markdeststr)) ||
       ((groupmark != destgroupmark) && (type1 != iTypeGroup) && (type2 != iTypeGroup) && (type2 != iTypeScene)) ||
       (isEdCtrlTreeItemSon ctrlSceneTree item2 item1)
       
    then nil else
    let if val2 == nil then "Scene" else val2 -> val2 in
      _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" strcatn "Are you sure to move "::val1::" as son of "::val2::" ?"::nil 1 @cbDlgObjectMoveToFather [viewstr telem1 telem2];
  );
  0;;


/**  cbBtnAddResourcesDir [EdControl V3Dview] I
  *  callback on add resources directory button
  *  
  *  private
  *
  *  return 0
  **/
fun cbBtnAddResourcesDir(ctrlstr, viewstr)=
  _DLGrflopenDir (_DLGOpenDir _channel mainInterf.MINT_winMain.EDW_win nil "Add resource path") @cbDlgAddResourceDir viewstr;
  0;;


fun cbView3dUnClick(viewstr, x, y, btn)=
  if bAppPlay && !OS3D_DEBUG then nil else
  (
    if (viewstr.V3D_iClickX != x) || (viewstr.V3D_iClickY != y) then nil else
    let V3DgetDefaultSession viewstr -> sessionstr in
    let viewstr.V3D_lastMouseData -> [_ _ obj mat _ _ _ _ _] in
    let V3DgetObjectFromHelper sessionstr obj -> obj in
    let SO3ObjectGetName obj -> objname in
    let if (objname == nil) then "Scene" else objname -> objname in
    (
      let getGraphByValue objname -> found in
      let found -> [treeitem _ _ _ _ _ _ _] in
      if (btn == 1) && (found != nil) then
      (
        selEdCtrlTreeItemByValue ctrlSceneTree objname;
        set sSelected = objname;
        0;
      )
      else if (btn == 2) && (found != nil) then
      (
        selEdCtrlTreeItemByValue ctrlSceneTree objname;
        showTreeMenu nil treeitem viewstr;
        set sSelected = objname;
        0;
      )
      else nil;
      0;
    )
  );
  
  if !bAppPlay then nil else
    cbPlugView3dUnClick viewstr x y btn;
  0;;


fun cbView3dDbClick(viewstr, x, y, btn)=
  if !bAppPlay then nil else
    cbPlugView3dDbClick viewstr x y btn;
  0;;


fun cbView3dClick(viewstr, x, y, btn)=
  if !bAppPlay then nil else
    cbPlugView3dClick viewstr x y btn;
  0;;


fun cbView3dWheel(viewstr, x, y, delta, btn)=
  if !bAppPlay then nil else
    cbPlugView3dWheel viewstr x y delta btn;
  0;;


fun cbView3dCursorMove(viewstr, x, y, btn)=
  if !bAppPlay then nil else
    cbPlugView3dCursorMove viewstr x y btn;
  0;;


fun createCameraToCurrentPosition(viewstr)=
  let getGraphByValue sSelected -> tgraph in
  let tgraph -> [treeitem ttype alias markstr path groupmark initstate staticgeometry] in 
  let if (ttype == iTypeGroup || ttype == iTypeScene) then  XMLgetMarkByValueFromMarkSons markstr "graph" else markstr -> markstr in      
  if (!strcmp sSelected "default_camera") || (ttype == nil) || (ttype == iTypeCompositor) || (ttype == iTypeSkyBox) || (ttype == iTypeSkyDome) || (ttype == iTypeSkyPlane) || (ttype == iTypeAnim) then nil else
  
  let V3DgetDefaultSession viewstr -> sessionstr in
  let SO3SceneGetObject (V3DgetSession sessionstr) sSelected -> father in
  let if father == nil then SO3ObjectGetSceneRoot (V3DgetSession sessionstr) else father -> father in
  let SO3SceneGetObject (V3DgetSession sessionstr) "default_camera" -> defcam in
  let SO3CameraGetFocalLenght defcam -> fovlenght in
  let SO3CameraGetFOVy defcam -> fovy in
  let SO3CameraGetNearClipDistance defcam -> nearclip in
  let SO3CameraGetFarClipDistance defcam -> farclip in
  
  let itoa (getNewSceneIndex nil) -> id in
  let XMLaddMark xmlEditSceneFile "camera" markstr ["id" id]::["name" "camera"]::["fov" (XMLgetShortFloatToString fovy)]::nil nil -> cammark in
  let addGraphItem (strcatn "camera"::" #"::id::nil) (strcatn id::"."::"camera"::nil) iTypeCamera nil cammark nil groupmark sTreeBitmapCamera treeitem 0 0 -> treenode in
  let V3DaddCamera sessionstr (strcatn id::"."::"camera"::nil) -> camera in
  
  // get current prs
  let SO3ObjectGetPositionInObjectRef defcam father -> newpos in
  let SO3ObjectGetOrientationInObjectRef defcam father -> newquat in
  let SO3ObjectGetScaleInObjectRef defcam father -> newscale in
  (
    SO3ObjectLink camera father;
    
    SO3ObjectSetPosition camera newpos;
    SO3ObjectSetOrientation camera newquat;
    SO3ObjectSetScale camera newscale;
    
    let newscale -> [nx ny nz] in
      XMLaddMark xmlEditSceneFile "scale" cammark ["x" (XMLgetShortFloatToString nx)]::["y" (XMLgetShortFloatToString ny)]::["z" (XMLgetShortFloatToString nz)]::nil nil;
    
    let newpos -> [nx ny nz] in
      XMLaddMark xmlEditSceneFile "position" cammark ["x" (XMLgetShortFloatToString nx)]::["y" (XMLgetShortFloatToString ny)]::["z" (XMLgetShortFloatToString nz)]::nil nil;
    
    let newquat -> [nx ny nz nw] in
      XMLaddMark xmlEditSceneFile "rotation" cammark ["qx" (XMLgetShortFloatToString nx)]::["qy" (XMLgetShortFloatToString ny)]::["qz" (XMLgetShortFloatToString nz)]::["qw" (XMLgetShortFloatToString nw)]::nil nil;
    
    XMLaddMark xmlEditSceneFile "clipping" cammark ["near" (XMLgetShortFloatToString nearclip)]::["far" (XMLgetShortFloatToString farclip)]::nil nil;
    
    V3DsetCamera camera fovlenght fovy nearclip farclip;
    V3DshowObjectHelper viewstr sessionstr camera iTypeCamera 1;
    selEdCtrlTreeItem ctrlSceneTree treenode;
  );
0;;


fun cameraModeLeftView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [0.0 (-.(sqrt 0.5)) 0.0 (sqrt 0.5)];
  0;;


fun cameraModeRightView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [0.0 (sqrt 0.5) 0.0 (sqrt 0.5)];
  0;;


fun cameraModeTopView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [-.(sqrt 0.5) 0.0 0.0 (sqrt 0.5)];
  0;;


fun cameraModeBottomView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [(sqrt 0.5) 0.0 0.0 (sqrt 0.5)];
  0;;


fun cameraModeFrontView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [0.0 0.0 0.0 1.0];
  0;;


fun cameraModeBackView(camera)=
  V3DsetOrthographicMode camera 1;
  let SO3ObjectGetPosition camera -> [_ _ level] in
    V3DsetOrthographicScale camera level;
  
  SO3ObjectSetOrientation SO3ObjectGetParent camera [0.0 1.0 0.0 0.0];
  0;;


fun cameraModeProjView(camera)=
  V3DsetOrthographicMode camera 0;
  0;;


/**  cbLogKeyDown [EdWindow I I] I
  *  callback on log key down
  *  
  *  private
  *
  *  return 0
  **/
fun cbLogKeyDown(winstr, key, ascode)=
  if (key == 63) then // F5
  (
    cbRefreshPlugits nil mainInterf.MINT_meGroups;
  )
  else nil;
  0;;


fun mainKeyDown(viewstr, key, ascode)=
  if (!bAppPlay) then
  (
    if (key == 49) then // N
    (
      let mainInterf.MINT_winView -> [_ [tbstr _ chkplay chkselect chkmove chkrotate chkscale btnundo btnredo chknav chkgrid chkhelpers chkinfos chkwiremode _ _ _ _]] in
      (
        setEdToolBarCheckState tbstr chknav !iNavigationMode;
        cbChangeNavigateMode tbstr chknav nil nil !iNavigationMode viewstr;
      );
      0;
    )
    else nil;
      
    if !iNavigationMode then nil else
      cbAvNavKeyDown viewstr key ascode avNavStr;
    0;
  )
  else
  (    
    cbPlugView3dKeyDown viewstr key ascode;
  );
  0;;


fun cbViewModeTop(tbstr, cmproll, btn, mask, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    cameraModeTopView (V3DgetDefaultCamera sessionstr);
  0;;


fun cbViewModeFront(tbstr, cmproll, btn, mask, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    cameraModeFrontView (V3DgetDefaultCamera sessionstr);
  0;;


fun cbViewModeLeft(tbstr, cmproll, btn, mask, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    cameraModeLeftView (V3DgetDefaultCamera sessionstr);
  0;;


fun cbViewModePers(tbstr, cmproll, btn, mask, viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
    cameraModeProjView (V3DgetDefaultCamera sessionstr);
  0;;


fun cbViewUndo(tbstr, cmproll, btn, mask, viewstr)=
  restoreLastObjHistoryState;
  0;;


fun cbViewRedo(tbstr, cmproll, btn, mask, viewstr)=
  restorePreviousObjHistoryState;
  0;;


fun mainKeyUp(viewstr, key)=
  if !bAppPlay then
  (
    let V3DgetDefaultSession viewstr -> sessionstr in
    let getEdCtrlTreeSelectedItem ctrlSceneTree -> item in
    let getEdCtrlTreeValueByItem ctrlSceneTree item -> [val type] in
    let getGraphByValue val -> [_ _ _ markstr _ groupmark _ _] in
    (
      if (key == 31) && (_keybdstate & 2) && (_keybdstate & 1) then // Ctrl + Shift + S
      (
        cbTbBtnSaveAsOsScene nil nil nil nil viewstr;
        0;
      )
      else if (key == 49) && (_keybdstate == 2) then // Ctrl + N
      (
        cbTbBtnReset nil nil nil nil viewstr;
        0;
      )
      else if (key == 24) && (_keybdstate == 2) then // Ctrl + O
      (
        cbTbBtnOpenScene nil nil nil nil viewstr;
        0;
      )
      else if (key == 18) && (_keybdstate == 2) then // Ctrl + E
      (
        cbTbBtnExportToPlayer nil nil nil nil viewstr;
        0;
      )
      else if (key == 23) && (_keybdstate == 2) then // Ctrl + I
      (
        cbTbBtnImportScene nil nil nil nil viewstr;
        0;
      )
      else if (key == 17) && (_keybdstate == 2) then // Ctrl + Z
      (
        restoreLastObjHistoryState;
        0;
      )
      else if (key == 21) && (_keybdstate == 2) then // Ctrl + Y
      (
        restorePreviousObjHistoryState;
        0;
      )
      else if (key == 15) then // Tab
      (
        // Change Edit mode
        let mainInterf.MINT_winView -> [_ [tbstr _ _ chkselect chkmove chkrotate chkscale _ _ _ _ _ _ _ _ _ _ _]] in
        let [viewstr [chkselect chkmove chkrotate chkscale]] -> editp in
        let if iViewerEditMode == 0 then
              chkmove
            else if iViewerEditMode == 1 then
              chkrotate
            else if iViewerEditMode == 2 then
              chkscale
            else
              chkselect
        -> check in
          cbChangeEditMode tbstr check 1 0 1 editp;
      )
      else if(key == 46) && (_keybdstate == 1) then // SHIFT + C
      (
        createCameraToCurrentPosition viewstr;
        0;
      )
      else if(key == 59) then // F1
      (
        _openbrowserhttp sHelpUrl;
        0;
      )
      else if key == 339 then // suppr
      (
        if type == iTypeEntity || type == iTypeGroup || type == iTypeNode || type == iTypeParticle || type == iTypeCubeMap || type == iTypeReflectionMap then
        (
          cbTreeMenuObjectRemove item [viewstr val type markstr];
          0;
        )
        else if type == iTypeCamera then
        (
          if !strcmp val "default_camera" then nil else
          (
            cbTreeMenuObjectRemove item [viewstr val type markstr];
          );
          0;
        )
        else if type == iTypeLight then
        (
          if !strcmp val "default_light" then nil else
          (
            cbTreeMenuObjectRemove item [viewstr val type markstr];
          );
          0;
        )
        else if type == iTypeSkyBox then
        (
          cbTreeMenuSkyBoxRemove item [viewstr item val type markstr];
          0;
        )
        else if type == iTypeSkyDome then
        (
          cbTreeMenuSkyDomeRemove item [viewstr item val type markstr];
          0;
        )
        else if type == iTypeSkyPlane then
        (
          cbTreeMenuSkyPlanRemove item [viewstr item val type markstr];
          0;
        )
        else if type == iTypeCompositor then
        (
          cbTreeMenuCompositorRemove item [viewstr item val type markstr];
          0;
        )
        else if type == iTypeAnim then
        (
          let XMLgetParam markstr "type" -> animtype in
          if (strcmpi animtype "cinematic") then nil else
            cbTreeMenuAnimRemove item [viewstr item val type markstr];
        )
        else nil;
      )
      else if key == 17 then // Z
      (
        let SO3SceneGetObject (V3DgetSession sessionstr) val -> obj in
        if obj == nil then nil else
        let if type == iTypeEntity then V3DgetGlobalObjectCenter obj else SO3ObjectGetGlobalPosition obj -> pos in
        let SO3SceneGetObject (V3DgetSession sessionstr) "default_camera" -> camera in
        let SO3CameraGetFOVy camera -> fovy in
        let if type == iTypeEntity then (V3DgetObjectRadius sessionstr obj) else (1.0 *. (itof iGlobalUnit)) -> curdist in
        let curdist +. (curdist /. tan fovy) -> dist in
        (
          V3DsetShellNavPos sessionstr pos;
          if iNavigationMode then nil else
          (
            SO3ObjectSetPosition camera [0.0 0.0 dist];
            V3DsetOrthographicScale camera dist;
          );
        );
        0;
      )
      else if key == 35 then // H helpers
      (
        set bShowHelpers = !bShowHelpers;
        V3DenableHelpers (V3DgetDefaultViewport viewstr) sessionstr bShowHelpers;
        
        let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ _ chkhelpers _ _ _ _ _ _]] in
          setEdToolBarCheckState tbstr chkhelpers bShowHelpers;
        0;
      )
      else if key == 34 then // G grid
      (
        set bShowGrid = !bShowGrid;
        V3DshowSceneGrid sessionstr bShowGrid;
        
        let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ chkgrid _ _ _ _ _ _ _]] in
          setEdToolBarCheckState tbstr chkgrid bShowGrid;
        0;
      )
      else if key == 25 then // P proj
      (
        cameraModeProjView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else if key == 38 then // L (left)
      (
        cameraModeLeftView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else if key == 19 then // R (right)
      (
        cameraModeRightView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else if key == 20 then // T (top)
      (
        cameraModeTopView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else if key == 48 then // B (back)
      (
        cameraModeBackView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else if key == 33 then // F (front)
      (
        cameraModeFrontView (V3DgetDefaultCamera sessionstr);
        0;
      )
      else nil;
  
      if !iNavigationMode then nil else
        cbAvNavKeyUp viewstr key avNavStr;
      0;
    );
  )
  else
    cbPlugView3dKeyUp viewstr key;
  
  if key == 31 && _keybdstate == 2 then // Ctrl + S
  (
    saveSceneFile nil;
    0;
  )
  else if key == 14 && _keybdstate == 2 then // Ctrl + Backspace
  (
    playEditor viewstr !bAppPlay;
    0;
  )
  else if key == 25 && _keybdstate == 2 then // Ctrl + P
  (
    cbTbBtnProjectSetting nil nil nil nil viewstr;
    0;
  )
  else if key == 23 then // I infos
  (
    set bShowInfos = !bShowInfos;
    V3DenableScreenInfos viewstr bShowInfos;
    let V3DgetDefaultSession viewstr -> sessionstr in
      V3DphysShowDebug sessionstr bShowInfos;
    
    let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ _ _ chkinfos _ _ _ _ _]] in
      setEdToolBarCheckState tbstr chkinfos bShowInfos;
  )
  else if key == 61 then // F3 wire mode
  (
    setViewWireMode viewstr !bShowWireMode;
    let mainInterf.MINT_winView -> [_ [tbstr _ _ _ _ _ _ _ _ _ _ _ _ chkwiremode _ _ _ _]] in
      setEdToolBarCheckState tbstr chkwiremode bShowWireMode;
    0;
  )
  else if key == 88 then // F12 launch app in viewer
  (
    launchPlayer;
    0;
  )
  else nil;
  0;;


fun cbSceneTreeKeyDown(ctrlstr, father, item, val, type, key, ascode, viewstr)=
  mainKeyDown viewstr key ascode;
  0;;


fun cbSceneTreeKeyUp(ctrlstr, father, item, val, type, key, viewstr)=
  mainKeyUp viewstr key;
  0;;


/**  cbView3dKeyDown [V3Dview I I] I
  *  callback on key down
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dKeyDown(viewstr, key, ascode)=
  mainKeyDown viewstr key ascode;
  0;;


/**  cbView3dKeyUp [V3Dview I] I
  *  callback on key up
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dKeyUp(viewstr, key)=
  mainKeyUp viewstr key;
  0;;


/**  cbScenePreRender [V3Dsession I] I
  *  callback on scene pre render
  *  
  *  private
  *
  *  return 0
  **/
fun cbScenePreRender(sessionstr, etime)=
  if !bAppPlay then
  (
    if !iNavigationMode || (sessionstr.V3D_selectedAxis != nil) then nil else
      cbAvNavPreRender sessionstr avNavStr;  
    0;
  )
  else
    cbPlugScenePreRender sessionstr etime;
  0;;


/**  cbScenePreRender [V3Dsession I] I
  *  callback on scene pre render
  *  
  *  private
  *
  *  return 0
  **/
fun cbScenePreRender2(sessionstr, etime)=
  if !bAppPlay then nil else
    cbPlugScenePreRender2 sessionstr etime;
  0;;


/**  cbScenePreRenderPhysic [V3Dsession I] I
  *  callback on scene pre render physic
  *  
  *  private
  *
  *  return 0
  **/
fun cbScenePreRenderPhysic(sessionstr, etime)=
  if !bAppPlay then nil else
    cbPlugScenePreRenderPhysic sessionstr etime;
  0;;

  
/**  cbScenePostRender [V3Dsession I] I
  *  callback on scene post render
  *  
  *  private
  *
  *  return 0
  **/
fun cbScenePostRender(sessionstr, etime)=
  if !bAppPlay then nil else
    cbPlugScenePostRender sessionstr etime;
  0;;


/**  cbView3dPreRender [V3Dview] I
  *  callback on pre render
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dPreRender(viewstr)=
  let V3DgetDefaultSession viewstr -> sessionstr in
  if !bAppPlay then nil else
    cbPlugView3dPreRender viewstr;
  0;;


/**  cbView3dPostRender [V3Dview] I
  *  callback on post render
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dPostRender(viewstr)=
  if !bAppPlay then nil else
    cbPlugView3dPostRender viewstr;
  0;;


/**  cbView3dCameraChange [V3Dview V3Dsession SO3_OBJECT] I
  *  callback on camera default change
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dCameraChange(viewstr, sessiontstr, camera)=
  if !bAppPlay then nil else
    cbPlugView3dCameraChange viewstr sessiontstr camera;
  0;;


/**  cbView3dResize [V3Dview I I] I
  *  callback view resize
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dResize(viewstr, w, h)=
  cbPlugView3dResize viewstr w h;
  0;;


fun cbDropImportXosScene(mnuitem, p)=
  let p -> [viewstr file] in
    cbImportXos [file [viewstr nil nil nil]];
  0;;
  

fun cbDropImportScene(mnuitem, p)=
  let p -> [viewstr file] in
    importSceneWizard viewstr nil nil nil file;
  0;;


fun cbSaveOnDrag(p)=
  let p -> [viewstr file] in
  (
    let V3DgetDefaultSession viewstr -> sessionstr in
      initScene viewstr sessionstr;
    loadOs3DScene viewstr file;
  );
  0;;


fun cbSaveBeforeDragOpen(dlg, p, state)=
  let p -> [viewstr file] in
  (
    if (state == 2) then nil else // Cancel
    if (state == 1) then // OK
    (
      saveSceneFile mkfun1 @cbSaveOnDrag p;
      0;
    )
    else
    (
      let V3DgetDefaultSession viewstr -> sessionstr in
        initScene viewstr sessionstr;
      loadOs3DScene viewstr file;
      0;
    );      
  );
  0;;  


fun cbDropOpenScene(mnuitem, p)=
  let p -> [viewstr file] in
  (
    if (!bAppPlay) then nil else
      playEditor viewstr 0;
    
    if (isSceneModified) then
    (
      _DLGrflmessage _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Warning" "Do you want to save the current scene before loading a new one ?" 3 @cbSaveBeforeDragOpen p;
      0;
    )
    else
    (
      let V3DgetDefaultSession viewstr -> sessionstr in
        initScene viewstr sessionstr;
      loadOs3DScene viewstr file;
      0;
    );
  );
  0;;


fun cbDropImportMesh(mnuitem, p)=
  let p -> [viewstr file] in
    importMeshWizard viewstr nil nil iTypeScene nil file;
  0;; 


/**  cbView3dDropFile [V3Dview I I [P r1]] I
  *  callback view drop files
  *  
  *  private
  *
  *  return 0
  **/
fun cbView3dDropFile(viewstr, x, y, lp)=
  let hd lp -> pfile in
  let _PtoScol pfile -> file in
  let getFileExt file -> ext in
  if file == nil then 
  (
    _DLGMessageBox _channel mainInterf.MINT_winMain.EDW_win "Error" "Your file have to be in a scol partition." 0;
    addLogMessage "File can't be loaded !";
    0;
  )
  else
  let _CRpopupMenu _channel -> mnu in
  (
    if (!strcmpi ext "xos") then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Open scene") @cbDropOpenScene [viewstr file];
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Import scene") @cbDropImportXosScene [viewstr file];
      0;
    )
    else if (!strcmpi ext "scene") then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Import scene") @cbDropImportScene [viewstr file];
      0;
    )
    else if (!strcmpi ext "mesh") then
    (
      _CBmenu (_APPitem _channel mnu ME_ENABLED "Import to scene") @cbDropImportMesh [viewstr file];
      0;
    )
    else nil;
    
    _CBmenu (_APPitem _channel mnu ME_ENABLED "Cancel") nil nil;
    let _GETscreenPos -> [x y] in
      _DRAWmenu viewstr.V3D_win mnu x y PM_SCREEN|PM_LEFT_ALIGN;
    0;
  );
  0;;


fun getConfigParam(type, pname)=
  let XMLgetMarkByValue xmlConfigFile "config" -> configmark in
  let XMLgetMarkByValueFromMarkSons configmark type -> typemark in
  let XMLgetMarkByValueFromMarkSons typemark pname -> pmark in
    XMLgetParam pmark "value";;


fun setConfigParam(type, pname, val)=
  let XMLgetMarkByValue xmlConfigFile "config" -> configmark in
  let XMLgetMarkByValueFromMarkSons configmark type -> typemark in
  let XMLgetMarkByValueFromMarkSons typemark pname -> pmark in
  let if pmark == nil then XMLaddMark xmlConfigFile pname typemark nil nil else pmark -> pmark in
    XMLsetParam pmark "value" val;
  0;;


fun cbCloseOnSave(winstr)=
  dsEdWindow winstr;
  0;;


fun cbSaveBeforeQuit(dlg, winstr, state)=
  if (state == 2) then nil else // Cancel
  if (state == 1) then // OK
    saveSceneFile mkfun1 @cbCloseOnSave winstr
  else
    dsEdWindow winstr;
  0;;


fun cbWinMainClose(winstr)=
  if (isSceneModified) then
  (
    _DLGrflmessage _DLGMessageBox _channel winstr.EDW_win "Warning" "Do you want to save the current scene before closing OpenSpace3D Editor ?" 3 @cbSaveBeforeQuit winstr;
    0;
  )
  else
  (
    dsEdWindow winstr;
    0;
  );
  0;;


/**  cbWinMainDestroy [Edwindow] I
  *  callback on destroy main window
  *  
  *  private
  *
  *  return 0
  **/
fun cbWinMainDestroy(winstr)=
  // save current config
  let getEdWindowPosSize winstr -> [x y w h] in
  let _GETwindowPositionSize mainInterf.MINT_winHBorder.EDW_win -> [_ hy _ _] in
  let _GETwindowPositionSize mainInterf.MINT_winHBorder2.EDW_win -> [_ h2y _ _] in
  let _GETwindowPositionSize mainInterf.MINT_winVBorder.EDW_win -> [vx _ _ _] in
  (
    if (w <= 5) || (h <= 5) then nil else
    (
      setConfigParam "OS3Dmain" "posx" itoa x;
      setConfigParam "OS3Dmain" "posy" itoa y;
      setConfigParam "OS3Dmain" "width" itoa w;
      setConfigParam "OS3Dmain" "height" itoa h;
      setConfigParam "OS3Dmain" "seph" itoa hy;
      setConfigParam "OS3Dmain" "seph2" itoa h2y;
      setConfigParam "OS3Dmain" "sepv" itoa vx;
    );
  );
  
  setConfigParam "OS3Duser" "bShowGrid" itoa bShowGrid;
  setConfigParam "OS3Duser" "bShowHelpers" itoa bShowHelpers;
  setConfigParam "OS3Duser" "bShowInfos" itoa bShowInfos;
  setConfigParam "OS3Duser" "bAutoFit" itoa bAutoFit;
  setConfigParam "OS3Duser" "bWireMode" itoa bShowWireMode;
  
  XMLwrite xmlConfigFile sConfigFile;
  
  _closemachine;
  0;;


fun cbvborderMouseMove(winstr, x, y, btn)=
  if btn != 1 then nil else
  (
    let mainInterf.MINT_winInfos -> [winfostr _] in
    let mainInterf.MINT_winView -> [wviewstr _] in
    let mainInterf.MINT_winVBorder -> vborder in
    let _GETwindowPositionSize mainInterf.MINT_winMain.EDW_win -> [_ _ mw mh] in
    (
      let _GETwindowPositionSize winfostr.EDW_win -> [ix iy iw ih] in
      let _GETwindowPositionSize wviewstr.EDW_win -> [vx vy vw vh] in
      let _GETwindowPositionSize vborder.EDW_win -> [wx wy ww wh] in
      let wx + x -> xpos in
      let if xpos <= 120 then 120 else if (mw-xpos-ww) <= 350 then mw-350 else xpos -> xpos in
      (
        setEdWindowPosSize vborder xpos wy ww wh;
        setEdWindowPosSize winfostr ix iy ix+xpos ih;
        setEdWindowPosSize wviewstr xpos+ww vy mw-xpos-ww ih;
      );
    );  
  );
  0;;


fun cbHBorderMouseMove(winstr, x, y, btn)=
  if btn != 1 then nil else
  (
    let mainInterf.MINT_winInfos -> [winfostr _] in
    let mainInterf.MINT_winView -> [wviewstr _] in
    let mainInterf.MINT_winPlugins -> [pviewstr _] in
    let mainInterf.MINT_winLogs -> [winlogs _ _] in
    let mainInterf.MINT_winHBorder -> hborder in
    let mainInterf.MINT_winHBorder2 -> h2border in
    let mainInterf.MINT_winVBorder -> vborder in
    let _GETwindowPositionSize mainInterf.MINT_winMain.EDW_win -> [_ _ mw mh] in
    (
      let _GETwindowPositionSize winfostr.EDW_win -> [ix iy iw ih] in
      let _GETwindowPositionSize wviewstr.EDW_win -> [vx vy vw vh] in
      let _GETwindowPositionSize pviewstr.EDW_win -> [px py pw ph] in
      let _GETwindowPositionSize winlogs.EDW_win -> [lx ly lw lh] in
      let _GETwindowPositionSize hborder.EDW_win -> [hx hy hw hh] in
      let _GETwindowPositionSize h2border.EDW_win -> [h2x h2y h2w h2h] in
      let _GETwindowPositionSize vborder.EDW_win -> [wx wy ww wh] in
      let hy + y -> ypos in
      let if ypos <= (36+28) then (36+28) else if ypos >= (h2y - hh - 28) then (h2y - hh - 28) else ypos -> ypos in
      (
        setEdWindowPosSize hborder hx ypos hw hh;
        setEdWindowPosSize vborder wx wy ww ypos-wy;
        setEdWindowPosSize winfostr ix iy iw ypos-iy;
        setEdWindowPosSize wviewstr vx vy vw ypos-vy;
        setEdWindowPosSize pviewstr px ypos+hh pw mh-ypos-(hh*2)-lh;
      );
    );
  );
  0;;


fun cbHBorderMouseMove2(winstr, x, y, btn)=
  if btn != 1 then nil else
  (
    let mainInterf.MINT_winPlugins -> [pviewstr _] in
    let mainInterf.MINT_winLogs -> [winlogs _ _] in
    let mainInterf.MINT_winHBorder2 -> h2border in
    let mainInterf.MINT_winHBorder -> hborder in
    let _GETwindowPositionSize mainInterf.MINT_winMain.EDW_win -> [_ _ mw mh] in
    (
      let _GETwindowPositionSize pviewstr.EDW_win -> [px py pw ph] in
      let _GETwindowPositionSize winlogs.EDW_win -> [lx ly lw lh] in
      let _GETwindowPositionSize hborder.EDW_win -> [hx hy hw hh] in
      let _GETwindowPositionSize h2border.EDW_win -> [wx wy ww wh] in
      let wy + y -> ypos in
      let if ypos <= (py + 28) then (py + 28) else if ypos >= (mh - 28 - wh) then (mh - 28 - wh) else ypos -> ypos in
      (
        setEdWindowPosSize h2border wx ypos ww wh;
        setEdWindowPosSize pviewstr px py pw ypos-py;
        setEdWindowPosSize winlogs lx ypos+wh lw mh-ypos-wh;
      );
    );
  );
  0;;


fun cbWinMainSize(winstr, mw, mh)=
  if mw < 100 || mh < 100 then nil else
  (
    let mainInterf.MINT_winInfos -> [winfostr _] in
    let mainInterf.MINT_winView -> [wviewstr _] in
    let mainInterf.MINT_winPlugins -> [pviewstr _] in
    let mainInterf.MINT_winLogs -> [winlogs _ _] in
    let mainInterf.MINT_winHBorder -> hborder in
    let mainInterf.MINT_winHBorder2 -> h2border in
    let mainInterf.MINT_winVBorder -> vborder in
    if winfostr.EDW_bMinimize || wviewstr.EDW_bMinimize || pviewstr.EDW_bMinimize || winlogs.EDW_bMinimize then nil else
    (
      let _GETwindowPositionSize winfostr.EDW_win -> [ix iy iw ih] in
      let _GETwindowPositionSize wviewstr.EDW_win -> [vx vy vw vh] in
      let _GETwindowPositionSize pviewstr.EDW_win -> [px py pw ph] in
      let _GETwindowPositionSize winlogs.EDW_win -> [lx ly lw lh] in
      let _GETwindowPositionSize hborder.EDW_win -> [hx ypos hw hh] in
      let _GETwindowPositionSize vborder.EDW_win -> [xpos wy ww wh] in
      let _GETwindowPositionSize h2border.EDW_win -> [h2x y2pos h2w h2h] in
      let if xpos <= 120 then 120 else if (mw-xpos-ww) <= 350 then mw-350 else xpos -> xpos in
      let if ypos <= (36+28) then (36+28) else if ypos >= (y2pos - hh - 28) then (y2pos - hh - 28) else ypos -> ypos in
      let if y2pos <= (py + 28) then (py + 28) else if y2pos >= (mh - 28 - h2h) then (mh - 28 - h2h) else y2pos -> y2pos in
      (
        setEdWindowPosSize hborder hx ypos hw hh;
        setEdWindowPosSize vborder xpos wy ww ypos-wy;
        setEdWindowPosSize winfostr ix iy ix+xpos ypos-iy;
        setEdWindowPosSize wviewstr xpos+ww vy mw-xpos-ww ypos-vy;
        setEdWindowPosSize pviewstr px ypos+hh pw y2pos-(ypos+hh);
        
        setEdWindowPosSize h2border h2x y2pos h2w h2h;
        setEdWindowPosSize winlogs lx y2pos+h2h lw mh-y2pos-h2h;
      );
    );
    0;
  );
  0;;


fun cbSplashText(message, p)=
  let p -> [tbstr textstr tbtopstr bmpstr] in
  (
    setEdToolBarText tbstr textstr strTruncate (strcat "Loading : " message) 64 "[...]" 0xffffff;
    paintEdCtrlBitmap bmpstr;
    paintEdToolBar tbtopstr;
  );
  0;;


fun cbDestroyView3d(viewstr)=
  if (isSceneModified) then
  (
    _DLGrflmessage _DLGMessageBox _channel mainWindow.EDW_win "Warning" "Do you want to save the current scene before closing OpenSpace3D Editor ?" 3 @cbSaveBeforeQuit mainWindow;
    0;
  )
  else
  (
    dsEdWindow mainWindow;
    0;
  );
  0;;
  

/**  initOs3dEditor [S] I
  *  initialize the application
  *  
  *  return 0
  **/
fun initOs3dEditor(file) =
  InitMainChannel;
  
  //reset log file
  _storepack strcatn "OpenSpace3D Editor : "::getVersionName::" ("::getVersionDate::")"::"\n"::nil sLogFile;
  
  // init keyboards definition
  KEYBloadMaps;
      
  // Temporary hack since project is not yet managed in Editor
  set currentProject = crProject nil nil 1;
  
  // set plugins to editor mode
  set iPluginMode = 1;
  
  // set lib 2D default res path
  set sG2DDEFAULTRESOURCESPATH = "dms/3d/os3dlib/res/";
  set sV3DDEFAULTRESOURCESPATH  = "dms/3d/os3dlib/res/";
  
  //init theme resources
  set EdDefaultTheme = makeEdThemeResources _channel;
  
  //Splash
  let _GETdesktopSize -> [sw sh] in
  let [500 346] -> [iw ih] in
  (
    set winSplash = setEdWindowIcon (crEdWindow _channel nil ((sw / 2) - (iw / 2)) ((sh / 2) - (ih / 2)) iw ih WN_NOBORDER|WN_NOCAPTION nil nil (strcatn "OpenSpace3D Editor : "::getVersionName::nil)) sWinMainIcon;
    let crEdCtrlBitmap winSplash 0 20 iw 306 "dms/3d/os3dedit/res/splash.png" iG2DDEFAULTBACKGROUNDCOLOR nil -> bmpstr in
    let crEdWindowToolBar winSplash 0 0 iw 20 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbtopstr in
    let crEdToolBarText tbtopstr strcatn "OpenSpace3D Editor : "::getVersionName::" - "::getVersionDate::nil "Arial" 9 FF_PIXEL|FF_WEIGHT 0xffffff nil ETB_ALIGN_RIGHT -> verstr in
    let crEdWindowToolBar winSplash 0 (ih - 20) iw 20 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
    let crEdToolBarText tbstr "Loading ..." "Arial" 9 FF_PIXEL|FF_WEIGHT 0xffffff nil ETB_ALIGN_LEFT -> textstr in
    (
      paintEdToolBar tbtopstr;
      paintEdToolBar tbstr;
      set cbPluginLoadInfo = mkfun2 @cbSplashText [tbstr textstr tbtopstr bmpstr];
      setEdWindowTopMost winSplash;
    );
  );
  
  // init default global network callbacks
  set netcomOS3D = netCreateMinimum;
  
  netSetCbConnected netcomOS3D @cbPlugNetConnected;
  netSetCbSConnected netcomOS3D @cbPlugNetSConnected;
  netSetCbClosed netcomOS3D @cbPlugNetClosed;
  netSetCbSrvMessage netcomOS3D @cbPlugNetSrvMessage;
  netSetCbUserMessage netcomOS3D @cbPlugNetUserMessage;
  netSetCbUserPrivateMessage netcomOS3D @cbPlugNetUserPrivateMessage;
  netSetCbUserChangeLogin netcomOS3D @cbPlugUserChangeLogin;
  netSetCbNewUser netcomOS3D @cbPlugNewUser;
  netSetCbDelUser netcomOS3D @cbPlugDelUser;
  netSetCbGetFile netcomOS3D @cbPlugGetFile;
  netSetCbUserGetItem netcomOS3D @cbPlugUserGetItem;
  netSetCbRoomGetItem netcomOS3D @cbPlugRoomGetItem;
  netSetCbNbUsers netcomOS3D @cbPlugNbUsers;
  netSetCbRoomChanged netcomOS3D @cbPlugRoomChanged;
  
  set mainInterf = mkMainInterface [nil nil nil nil nil nil nil nil nil nil nil nil nil nil];
  
  let _GETdesktopSize -> [sw sh] in
  let 2 -> border in
  let 36 -> hbar in
  let 28 -> hlog in
  let 240 -> hplug in
  let [280 (iWinH - hbar - hlog - hplug -(border*2))] -> [iw ih] in
  let [(iWinW - (iw + border)) (iWinH - hbar - hlog -hplug - (border*2))] -> [vw vh] in
  (
    let setEdWindowIcon (crEdMainWindow _channel nil ((sw / 2) - (iWinW / 2)) ((sh / 2) - (iWinH / 2)) iWinW iWinH WN_HIDDEN|WN_NORMAL strcatn "OpenSpace3D Editor : "::getVersionName::nil) sWinMainIcon -> winmainstr in
    let crEdWindowToolBar winmainstr 0 0 iWinW (hbar - border) 5 4 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> maintbstr in
    let crEdWindow _channel winmainstr 0 hbar iw ih WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MH|EDWIN_RESIZE_RW nil "" -> infowinstr in    
    let crEdWindow _channel winmainstr (iw + border) hbar vw vh WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_MH nil "" -> viewwinstr in
    let crEdWindow _channel winmainstr 0 (hbar + ih + border) iWinW hplug WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_LH nil "" -> plugswinstr in
    let crEdWindow _channel winmainstr 0 (hbar + ih + hplug + (border*2)) iWinW hlog WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_LH nil "" -> logwinstr in
    
    let crEdWindow _channel winmainstr iw hbar border ih WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MH|EDWIN_RESIZE_RW nil "" -> vborder in
    let crEdWindow _channel winmainstr 0 ih+hbar iWinW border WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_LH nil "" -> hborder in
    let crEdWindow _channel winmainstr 0 (hbar + ih + hplug + border) iWinW border WN_CHILDINSIDE|WN_NOBORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_LH nil "" -> h2border in
    
    let crEdCtrl3D viewwinstr 0 28 vw (vh-28) EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> ctrl3dviewstr in
    let getEdCtrlView3d ctrl3dviewstr -> viewstr in
    let V3DgetDefaultSession viewstr -> sessionstr in
    
    let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_hseparator.png" -> asep in
    (
      setEdCtrl3DdestroyCb ctrl3dviewstr @cbDestroyView3d;
      
      set mainWindow = winmainstr;
      set mainInterf.MINT_winMain = winmainstr;
      set mainInterf.MINT_winBig = viewwinstr;
      set mainInterf.MINT_winVBorder = vborder;
      set mainInterf.MINT_winHBorder = hborder;
      set mainInterf.MINT_winHBorder2 = h2border;
      
      _SETwinCursor vborder.EDW_win EdDefaultTheme.EDT_cursorWSize;
      _SETwinCursor hborder.EDW_win EdDefaultTheme.EDT_cursorHSize;
      _SETwinCursor h2border.EDW_win EdDefaultTheme.EDT_cursorHSize;
      setEdwindowCbCursorMove vborder @cbvborderMouseMove;
      setEdwindowCbCursorMove hborder @cbHBorderMouseMove;
      setEdwindowCbCursorMove h2border @cbHBorderMouseMove2;
            
      // load config file
      set xmlConfigFile = XMLload sConfigFile;
      
      // create default config file
      if xmlConfigFile != nil then nil else
      (
        set xmlConfigFile = XMLcreate nil nil;
        let XMLaddMark xmlConfigFile "config" nil ["author" "OpenSpace3D editor configuration file"]::nil nil -> confmark in
        let XMLaddMark xmlConfigFile "OS3Dmain" confmark nil nil -> confmainmark in
        let XMLaddMark xmlConfigFile "OS3Duser" confmark nil nil -> confusermark in
        let _GETwindowPositionSize vborder.EDW_win -> [vx _ _ _] in
        let _GETwindowPositionSize hborder.EDW_win -> [_ hy _ _] in
        let _GETwindowPositionSize h2border.EDW_win -> [_ h2y _ _] in
        (
          XMLaddMark xmlConfigFile "width" confmainmark ["value" (itoa iWinW)]::nil nil;
          XMLaddMark xmlConfigFile "height" confmainmark ["value" (itoa iWinH)]::nil nil;
          XMLaddMark xmlConfigFile "posx" confmainmark ["value" (itoa ((sw / 2) - (iWinW / 2)))]::nil nil;
          XMLaddMark xmlConfigFile "posy" confmainmark ["value" (itoa ((sh / 2) - (iWinH / 2)))]::nil nil;
          
          XMLaddMark xmlConfigFile "sepv" confmainmark ["value" (itoa vx)]::nil nil;
          XMLaddMark xmlConfigFile "seph" confmainmark ["value" (itoa hy)]::nil nil;
          XMLaddMark xmlConfigFile "seph2" confmainmark ["value" (itoa h2y)]::nil nil;
          
          XMLaddMark xmlConfigFile "bShowGrid" confusermark ["value" (itoa bShowGrid)]::nil nil;
          XMLaddMark xmlConfigFile "bShowHelpers" confusermark ["value" (itoa bShowHelpers)]::nil nil;
          XMLaddMark xmlConfigFile "bShowInfos" confusermark ["value" (itoa bShowInfos)]::nil nil;
          XMLaddMark xmlConfigFile "bAutoFit" confusermark ["value" (itoa bAutoFit)]::nil nil;
          XMLaddMark xmlConfigFile "bWireMode" confusermark ["value" (itoa bShowWireMode)]::nil nil;
        );
      );
      
      // init config vars
      let atoi (getConfigParam "OS3Duser" "bShowGrid") -> bmode in
        set bShowGrid = if bmode == nil then bShowHelpers else bmode;
      let atoi (getConfigParam "OS3Duser" "bShowHelpers") -> bmode in
        set bShowHelpers = if bmode == nil then bShowHelpers else bmode;
      let atoi (getConfigParam "OS3Duser" "bShowInfos") -> bmode in
        set bShowInfos = if bmode == nil then bShowInfos else bmode;
      let atoi (getConfigParam "OS3Duser" "bAutoFit") -> bmode in
        set bAutoFit = if bmode == nil then bAutoFit else bmode;
      let atoi (getConfigParam "OS3Duser" "bWireMode") -> bmode in
        set bShowWireMode = if bmode == nil then bShowWireMode else bmode;
      
      
      set s3dMainSession = sessionstr;
      set v3dMain = viewstr;
      
      setEdwindowCbDestroy mainWindow @cbWinMainDestroy;
      setEdwindowCbClose mainWindow @cbWinMainClose;
      setEdwindowCbSize mainWindow @cbWinMainSize;
      
      V3DsetCbScenePreRender sessionstr @cbScenePreRender;
      V3DsetCbScenePreRender2 sessionstr @cbScenePreRender2;
      V3DsetCbScenePreRenderPhysic sessionstr @cbScenePreRenderPhysic;
      V3DsetCbScenePostRender sessionstr @cbScenePostRender;
      V3DsetCbClick viewstr @cbView3dClick;
      V3DsetCbUnClick viewstr @cbView3dUnClick;
      V3DsetCbKeyDown viewstr @cbView3dKeyDown;
      V3DsetCbKeyUp viewstr @cbView3dKeyUp;
      V3DsetCbPreRender viewstr @cbView3dPreRender;
      V3DsetCbPostRender viewstr @cbView3dPostRender;
      V3DsetCbCursorMove viewstr @cbView3dCursorMove;
      V3DsetCbDbClick viewstr @cbView3dDbClick;
      V3DsetCbWheel viewstr @cbView3dWheel;
      V3DsetCbCameraChange viewstr @cbView3dCameraChange;
      V3DsetCbResizeView viewstr @cbView3dResize;
      V3DsetCbDropFile viewstr @cbView3dDropFile;
      V3DsetCbFocusView viewstr @cbPlugView3dFocus;
      V3DsetCbKillFocusView viewstr @cbPlugView3dKillFocus;
      
      // Main toolbar
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopnew.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "New / Reset all (Ctrl + N)" mkfun5 @cbTbBtnReset viewstr -> tbnew in
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopopen.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Open scene (Ctrl + O)" mkfun5 @cbTbBtnOpenScene viewstr -> tbopen in
            
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopsave.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Save OpenSpace 3D scene (Ctrl + S)" mkfun5 @cbTbBtnSaveOsScene viewstr -> tbsave in
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopsaveas.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Save as OpenSpace 3D scene (Ctrl + Shift + S)" mkfun5 @cbTbBtnSaveAsOsScene viewstr -> tbsaveas in
      
      let crEdToolBarBitmap maintbstr asep ETB_ALIGN_LEFT nil nil -> tbsep in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopimport.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Import scene (Ctrl + I)" mkfun5 @cbTbBtnImportScene viewstr -> tbimport in      
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopsetup.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Project setting (Ctrl + P)" mkfun5 @cbTbBtnProjectSetting viewstr -> tbprjsetting in
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopgo.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Export to OpenSpace 3D Player (Ctrl + E)" mkfun5 @cbTbBtnExportToPlayer viewstr -> tbexport in

      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopplayer.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Launch in player (F12)" mkfun5 @cbTbBtnLaunchPlayer viewstr -> tbplayer in

      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopabout.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_RIGHT "About OpenSpace3D Editor" mkfun5 @cbTbBtnAbout viewstr -> tbabout in
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnophelp.png" -> apng in
      let crEdToolBarButton maintbstr apng ETB_ALIGN_RIGHT "Online help (F1)" mkfun5 @cbTbBtnHelp viewstr -> tbhelp in
      (
        _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode tbplayer OBJ_DISABLE|OBJ_VISIBLE 1;
        _CHANGEobjNodeFlags _CONVERTcompRollOverToObjNode tbexport OBJ_DISABLE|OBJ_VISIBLE 1;
        set mainInterf.MINT_tbMain = [tbnew tbopen tbimport tbsave tbsaveas tbprjsetting tbexport tbplayer tbabout tbhelp];
      );
      
      /*
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/btnopsetup.png" -> apng in
        crEdToolBarButton maintbstr apng ETB_ALIGN_LEFT "Setup" mkfun5 @cbTbBtnSetup viewstr;    
      */
      paintEdToolBar maintbstr;
      
      let crEdWindowToolBar infowinstr 0 0 iw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/chkminmax.png" -> apng in
      let crEdTabBarFromToolBar tbstr infowinstr 0 10 (iw - 30) 20 10 nil -> tabbarstr in
      let crEdTab tabbarstr "Scene tree" nil 1 -> tabstr1 in
      let crEdTab tabbarstr "Group Resources" nil 0 -> tabstr3 in
      let crEdTab tabbarstr "Group Meshes" nil 0 -> tabstr4 in
      let crEdTab tabbarstr "Resources Directories" nil 0 -> tabstr2 in
      let getEdTabWindow tabstr1 -> winstr1 in
      let getEdTabWindow tabstr2 -> winstr2 in
      let getEdTabWindow tabstr3 -> winstr3 in
      let getEdTabWindow tabstr4 -> winstr4 in
      let crEdToolBarCheck tbstr apng ETB_ALIGN_RIGHT "Maximize / Minimize" mkfun6 @cbMinMaxWin infowinstr -> minmaxchk in
      let crEdCtrlButton winstr3 5 5 (iw - 10) 20 "Remove resource" EDWIN_RESIZE_MW -> removebtn in
      (
        set ctrlSceneTree = crEdCtrlTree winstr1 5 5 (iw - 10) (ih - 40) EDWIN_RESIZE_MW|EDWIN_RESIZE_MH;
        set ctrlResourcesList = crEdCtrlList winstr3 5 30 (iw - 10) (ih - 65) LB_BORDER|LB_VSCROLL|ET_TABFOCUS|LB_MULTIPLE EDWIN_RESIZE_MW|EDWIN_RESIZE_MH;
        set ctrlMeshList = crEdCtrlList winstr4 5 5 (iw - 10) (ih - 40) LB_NOSELECTION|LB_BORDER|LB_VSCROLL|ET_TABFOCUS EDWIN_RESIZE_MW|EDWIN_RESIZE_MH;
        set ctrlResourcesDirList = crEdCtrlList winstr2 5 40 (iw - 10) (ih - 75) LB_NOSELECTION|LB_BORDER|LB_VSCROLL|ET_TABFOCUS EDWIN_RESIZE_MW|EDWIN_RESIZE_MH;
        
        setEdTabCbFocused tabstr3 mkfun2 @cbResourcesTabFocused ctrlResourcesList;
        setEdTabCbFocused tabstr4 mkfun2 @cbMeshesTabFocused ctrlMeshList;
        
        setEdCtrlButtonCb removebtn mkfun2 @cbRemoveResource sessionstr;
        setEdCtrlTreeCbSelect ctrlSceneTree mkfun6 @cbSceneTreeSelect viewstr;
        setEdCtrlTreeCbRclick ctrlSceneTree mkfun8 @cbSceneTreeRClick viewstr;
        setEdCtrlTreeCbKeyDown ctrlSceneTree mkfun8 @cbSceneTreeKeyDown viewstr;
        setEdCtrlTreeCbKeyUp ctrlSceneTree mkfun7 @cbSceneTreeKeyUp viewstr;
        setEdCtrlTreeCbDrag ctrlSceneTree mkfun4 @cbSceneTreeDrag viewstr;
                
        setEdCtrlButtonCb (crEdCtrlButton winstr2 ((iw / 2) -80) 10 160 20 "Add resource directory" EDWIN_RESIZE_MW) mkfun2 @cbBtnAddResourcesDir viewstr;
        
        set mainInterf.MINT_winInfos = [infowinstr [tbstr minmaxchk]];
        paintEdToolBar tbstr;
      );
      
      // 3d
      let crEdWindowToolBar viewwinstr 0 0 vw 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/chkminmax.png" -> apng in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_select.png" -> aselect in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_move.png" -> amove in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_rotate.png" -> arotate in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_scale.png" -> ascale in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_undo.png" -> aundo in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_redo.png" -> aredo in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_navigate.png" -> anavigate in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_playstop.png" -> aplaystop in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_grid.png" -> agrid in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_helpers.png" -> ahelpers in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_wiremode.png" -> awiremode in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_infos.png" -> ainfos in
      
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_top.png" -> atop in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_front.png" -> afront in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_left.png" -> aleft in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_pers.png" -> apers in
      
      let crEdToolBarCheck tbstr aplaystop ETB_ALIGN_LEFT "Play / Stop (Ctrl + Backspace)" nil -> chkplaystop in
      let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
      let crEdToolBarCheck tbstr aselect ETB_ALIGN_LEFT "Select (Tab to switch)" nil -> chkselect in
      let crEdToolBarCheck tbstr amove ETB_ALIGN_LEFT "Move (Tab to switch)" nil -> chkmove in
      let crEdToolBarCheck tbstr arotate ETB_ALIGN_LEFT "Rotate (Tab to switch)" nil -> chkrotate in
      let crEdToolBarCheck tbstr ascale ETB_ALIGN_LEFT "Scale (Tab to switch)" nil -> chkscale in
      let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
      let crEdToolBarButton tbstr aundo ETB_ALIGN_LEFT "Undo (Ctrl + Z)" mkfun5 @cbViewUndo viewstr -> btnundo in
      let crEdToolBarButton tbstr aredo ETB_ALIGN_LEFT "Redo (Ctrl + Y)" mkfun5 @cbViewRedo viewstr -> btnredo in
      let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
      let crEdToolBarCheck tbstr agrid ETB_ALIGN_LEFT "Show / Hide grid (G)" nil -> chkgrid in
      let crEdToolBarCheck tbstr ahelpers ETB_ALIGN_LEFT "Show / Hide helpers (H)" nil -> chkhelpers in
      let crEdToolBarCheck tbstr awiremode ETB_ALIGN_LEFT "Wire / Polygon (F3)" nil -> chkwiremode in
      let crEdToolBarCheck tbstr ainfos ETB_ALIGN_LEFT "Show / Hide 3d infos (I)" nil -> chkinfos in
      let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
      let crEdToolBarButton tbstr atop ETB_ALIGN_LEFT "Top view (T)" mkfun5 @cbViewModeTop viewstr -> chktop in
      let crEdToolBarButton tbstr afront ETB_ALIGN_LEFT "Front view (F)" mkfun5 @cbViewModeFront viewstr -> chkfront in
      let crEdToolBarButton tbstr aleft ETB_ALIGN_LEFT "Left view (L)" mkfun5 @cbViewModeLeft viewstr -> chkleft in
      let crEdToolBarButton tbstr apers ETB_ALIGN_LEFT "Perspective view (P)" mkfun5 @cbViewModePers viewstr -> chkpers in
      let crEdToolBarBitmap tbstr asep ETB_ALIGN_LEFT nil nil -> hsep in
      let crEdToolBarCheck tbstr anavigate ETB_ALIGN_LEFT "Navigate / Walk (N)" nil -> chknavigate in
      let crEdToolBarCheck tbstr apng ETB_ALIGN_RIGHT "Maximize / Minimize" mkfun6 @cbMinMaxViewWin viewwinstr -> minmaxchk1 in
      (
        setEdToolBarVisible tbstr 1;
        
        setEdToolBarCheckState tbstr chkselect 1;
        setEdToolBarCheckState tbstr chkgrid bShowGrid;
        setEdToolBarCheckState tbstr chkhelpers bShowHelpers;
        setEdToolBarCheckState tbstr chkinfos bShowInfos;
        setEdToolBarCheckState tbstr chkwiremode bShowWireMode;
        
        setEdToolBarCheckCbClick tbstr chkselect mkfun6 @cbChangeEditMode [viewstr [chkselect chkmove chkrotate chkscale]];
        setEdToolBarCheckCbClick tbstr chkmove mkfun6 @cbChangeEditMode [viewstr [chkselect chkmove chkrotate chkscale]];
        setEdToolBarCheckCbClick tbstr chkrotate mkfun6 @cbChangeEditMode [viewstr [chkselect chkmove chkrotate chkscale]];
        setEdToolBarCheckCbClick tbstr chkscale mkfun6 @cbChangeEditMode [viewstr [chkselect chkmove chkrotate chkscale]];
        setEdToolBarCheckCbClick tbstr chknavigate mkfun6 @cbChangeNavigateMode viewstr;
        setEdToolBarCheckCbClick tbstr chkplaystop mkfun6 @cbChangePlayStop viewstr;
        setEdToolBarCheckCbClick tbstr chkgrid mkfun6 @cbChangeShowGrid viewstr;
        setEdToolBarCheckCbClick tbstr chkhelpers mkfun6 @cbChangeShowHelpers viewstr;
        setEdToolBarCheckCbClick tbstr chkwiremode mkfun6 @cbChangeWireMode viewstr;
        setEdToolBarCheckCbClick tbstr chkinfos mkfun6 @cbChangeShowInfos viewstr;
        
        set mainInterf.MINT_winView = [viewwinstr [tbstr minmaxchk1 chkplaystop chkselect chkmove chkrotate chkscale btnundo btnredo chknavigate chkgrid chkhelpers chkinfos chkwiremode chktop chkfront chkleft chkpers]];
        paintEdToolBar tbstr;
      );
      
      // plugins
      let crEdWindowToolBar plugswinstr 0 0 iWinW 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/chkminmax.png" -> apng in
      let crEdTabBarFromToolBar tbstr plugswinstr 0 10 (iWinW - 95) 20 10 nil -> tabbarstr in
      let crEdToolBarCheck tbstr apng ETB_ALIGN_RIGHT "Maximize / Minimize" mkfun6 @cbMinMaxWinPlugs plugswinstr -> minmaxchk1 in
      /*let crEdToolBarBitmap tbstr asep ETB_ALIGN_RIGHT nil nil -> hsep in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_zoomin.png" -> azoomin in
      let crEdToolBarButton tbstr azoomin ETB_ALIGN_RIGHT "Zoom in" nil -> chkzoomin in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_zoomout.png" -> azoomout in
      let crEdToolBarButton tbstr azoomout ETB_ALIGN_RIGHT "Zoom out" nil -> chkzoomout in*/
      (
        setEdToolBarVisible tbstr 1;
        makeGroupPluginsTab plugswinstr tabbarstr "Groups" viewstr;
        
        set mainInterf.MINT_winPlugins = [plugswinstr [tbstr tabbarstr minmaxchk1]];
        
        paintEdToolBar tbstr;
      );
      
      // logs
      let crEdWindowToolBar logwinstr 0 0 iWinW 28 5 1 iG2DDEFAULTBACKGROUNDCOLOR ETB_HORIZONTAL -> tbstr in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_log.png" -> logpng in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/tb_clslog.png" -> clslogpng in
      let _LDalphaBitmap _channel _checkpack "dms/3d/os3dedit/res/chkminmax.png" -> apng in
      let crEdToolBarCheck tbstr apng ETB_ALIGN_RIGHT "Maximize / Minimize" mkfun6 @cbMinMaxWinLogs logwinstr -> minmaxchk1 in
      let crEdToolBarCheck tbstr logpng ETB_ALIGN_RIGHT "Enable / Disable PlugIT's Log" mkfun6 @cbEnablePlugitLog plugswinstr -> pluglogchk1 in
      let crEdToolBarButton tbstr clslogpng ETB_ALIGN_RIGHT "Clear Logs" mkfun5 @cbClearLog plugswinstr -> clearlogbtn in
      let crEdToolBarText tbstr "Logs" "Arial" 9 FF_PIXEL|FF_WEIGHT 0xffffff nil ETB_ALIGN_LEFT -> lastlog in
      let crEdCtrlText logwinstr 5 5+28 (iWinW - 10) (hlog - 12 - 28) nil ET_VSCROLL|ET_AHSCROLL|ET_BORDER EDWIN_RESIZE_MW|EDWIN_RESIZE_MH -> logtext in
      (
        setEdwindowCbKeyDown logwinstr @cbLogKeyDown;
        set mainInterf.MINT_winLogs = [logwinstr [tbstr minmaxchk1 lastlog] logtext];
        paintEdToolBar tbstr;
      );
      
      V3DaddViewport viewstr 0.0 0.0 1.0 1.0 0x0;
      
      // load plugins files
      loadPlugins sPLUGINSPATH;
      
      initScene viewstr sessionstr;
      
      // TODO DEBUG don't work if called before initscene
      V3DsetScreenInfos viewstr 5 5 300 200 14 0xffffff;
      V3DenableScreenInfos viewstr bShowInfos;
      
      set DMSerror = @cbDmsLogs;
      
      // load default scene
      loadOs3DScene viewstr file;
      
      //force an update
      //SO3BufferUpdate viewstr.V3D_buffer;
      
      dsEdWindow winSplash;
      set winSplash = nil;
      
      //apply last setting
      let (atoi (getConfigParam "OS3Dmain" "posx")) -> nx in
      let (atoi (getConfigParam "OS3Dmain" "posy")) -> ny in
      let (atoi (getConfigParam "OS3Dmain" "width")) -> nw in
      let (atoi (getConfigParam "OS3Dmain" "height")) -> nh in
      let (atoi (getConfigParam "OS3Dmain" "sepv")) -> xpos in
      let (atoi (getConfigParam "OS3Dmain" "seph")) -> ypos in
      let (atoi (getConfigParam "OS3Dmain" "seph2")) -> y2pos in
      (
        setEdWindowPosSize mainWindow nx ny nw nh;
        
        //test if we have to maximize window
        let getEdWindowExPosSize mainWindow -> [mx my mw mh] in
        if mw >= sw && mh >= sh then
          _SHOWwindow mainWindow.EDW_win WINDOW_MAXIMIZED
        else
          _SHOWwindow mainWindow.EDW_win WINDOW_UNHIDDEN;
        
        if xpos == nil || ypos == nil || y2pos == nil then nil else
        let mainInterf.MINT_winInfos -> [winfostr _] in
        let mainInterf.MINT_winView -> [wviewstr _] in
        let mainInterf.MINT_winPlugins -> [pviewstr _] in
        let mainInterf.MINT_winLogs -> [winlogs _ _] in
        let mainInterf.MINT_winHBorder -> hborder in
        let mainInterf.MINT_winHBorder2 -> h2border in
        let mainInterf.MINT_winVBorder -> vborder in
        let _GETwindowPositionSize mainInterf.MINT_winMain.EDW_win -> [_ _ mw mh] in
        (
          let _GETwindowPositionSize winfostr.EDW_win -> [ix iy iw ih] in
          let _GETwindowPositionSize wviewstr.EDW_win -> [vx vy vw vh] in
          let _GETwindowPositionSize pviewstr.EDW_win -> [px py pw ph] in
          let _GETwindowPositionSize winlogs.EDW_win -> [lx ly lw lh] in
          let _GETwindowPositionSize hborder.EDW_win -> [hx hy hw hh] in
          let _GETwindowPositionSize h2border.EDW_win -> [h2x h2y h2w h2h] in
          let _GETwindowPositionSize vborder.EDW_win -> [wx wy ww wh] in
          (            
            if (ypos >= mh) then nil else
            (
              setEdWindowPosSize hborder hx ypos hw hh;
              setEdWindowPosSize vborder xpos wy ww ypos-wy;
              setEdWindowPosSize winfostr ix iy ix+xpos ypos-iy;
              setEdWindowPosSize wviewstr xpos+ww vy mw-xpos-ww ypos-vy;
              setEdWindowPosSize pviewstr px ypos+hh pw y2pos-(ypos+hh);
              
              if (y2pos >= mh) then nil else
              (
                setEdWindowPosSize h2border h2x y2pos h2w h2h;
                setEdWindowPosSize winlogs lx y2pos+h2h lw mh-y2pos-h2h;
              );
            );
          );
        );
        
        setEdWindowTopMost mainWindow;
      );
    );
  );
  0;;